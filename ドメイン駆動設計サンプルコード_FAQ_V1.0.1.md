ドメイン駆動設計 サンプルコード&FAQ
松岡幸一郎　著
2021-10-30版
はじめに
前書「ドメイン駆動設計 モデリング/実装ガイド*1」(以下、モデリング/実装ガイド) では、ドメイン駆動設計 (以下、DDD)の基礎について解説し、ありがたいことに参考に なったという声を多くいただきました。しかし、実際に開発に適用しようとするとつまず くことは多く、質問箱*2では 1年間に数百件の質問をいただいています。 そこで、本書では前書で解説しきれなかった重要トピック「モデリング」「集約」「テス ト」について解説し、その他のトピックでは頻出の質問への回答と具体的なサンプルコー ドを示しました。モデリングに関しては、モデリング/実装ガイドで示したモデリング手 法から、より成果を出しやすい形式にアップデートした内容を紹介します。
本書の構成 「第 2章 モデリング」「第 5章 集約」「第 7章 テスト」は解説が中心、それ以外の章は
Q&Aが中心となっています。Q&Aは、質問箱に寄せられた質問から重要なもの、頻出 なものをピックアップしています。 具体例を多くし、本書のみでも読めるように心がけていますが、基礎的な概念の解説が 必要な場合はモデリング/実装ガイドを参照してください。
「第 1章 DDD全般」では、DDD の目的や導入方法などに関する質問に対して解説し ます。 「第 2章 モデリング」では、DDDで実践しやすいモデリング手法と、その結果をコー ドに落とすまでを具体的に解説します。 「第 3章 エンティティ/値オブジェクト」「第 4章 リポジトリ」「第 6章 ドメインサー ビス/ファクトリー」では、各トピックの頻出の質問に対して、サンプルコードを交えて 解説します。
*1 <https://little-hands.booth.pm/items/1835632> *2 匿名で質問を受け付けるサービス。 <https://peing.net/ja/little_hands>
2
「第 5章 集約」では、集約を実装する上で一番迷う、複数集約の整合性を確保する実装 や、集約の設計について解説します。 「第 7章 テスト」では、DDDにおける基本的なテスト方針と、レイヤーごとの具体的 なテストコードを解説します。 「第 8章 アーキテクチャ」では、例外処理、外部サービスへのアクセス、認証情報の扱 い、といったアーキテクチャ全般における頻出質問に対してサンプルコードを交えて解説 します。 「第 9章 その他」では、プログラミング一般における頻出質問に対して解説します。
DDDではモデリングとコーディングがセットで価値が最大限発揮されますが、寄せら れる質問は時間が多く割かれるコーディングに関するものが多いです。また、手を動かす にあたって具体的に詰まることが多いのもコーディングであることも事実です。そのた め、本書ではモデリングの重要性を考慮しつつも、ボリュームとしてはコーディングに関 するものが多くなります。ご了承ください。
用語の定義 本書を読んでいく上で重要な用語について定義します。 それぞれの用語の詳細な解説はモデリング/実装ガイドに記載があるため、必要に応じ
てご参照ください。
▼表 1 重要な単語の定義
名前 意味 ドメイン ソフトウェアで問題解決しようとする対象領域。 モデル 問題解決のために、物事の特定の側面を抽象化したもの。
エンティティ ドメインモデルを表現するオブジェクトで、同一判定を識別子で行うもの。 不変でも可変でもよい。
値オブジェクト ドメインモデルを表現するオブジェクトで、同一判定を保持する値で行うもの。 必ず不変になる。
集約 必ずひとまとまりで永続化する、強い整合性を持ったエンティティ/値オブジェ クトの単位。
リポジトリ エンティティ/値オブジェクトを永続化機構 (DB等)に対して入出力するオブ ジェクト。入出力は必ず集約単位で行う。
3
サンプルコードの言語 Kotlinについて 本書ではサンプルコードに Kotlinを使用しますが、Kotlinを学んだことがない方にも わかる記述を心がけています。そのため、短い記述で「Kotlinらしく」実装できる場合で も、あえてわかりやすい記述を選択していることがあります。Kotlin を普段使っている 方からすると違和感がある実装があるかもしれませんが、ご了承ください。
アーキテクチャ DDDを実装するアーキテクチャには、オニオンアーキテクチャを採用しています。こ
のアーキテクチャの概要については、モデリング/実装ガイド、もしくは脚注*3の記事を ご覧ください。
パッケージ表記について 本書のサンプルコードでは、説明上必要なところだけパッケージを表記し、それ以外は 省略しています。 パッケージ方針として、第 2階層がレイヤーを表し、それ以降は整理のためのパッケー ジとしています。例として、「package dddfaq.domain.user」であればドメイン層のユー ザー集約に関するパッケージ、「package dddfaq.infra.repository」であればインフラ層の リポジトリに関するパッケージです。
免責事項 本書に記載された内容は、情報の提供のみを目的としています。したがって、本書を用 いた開発、運用は、必ずご自身の責任と判断によって行ってください。これらの情報によ る開発、運用の結果について、著者はいかなる責任も負いません。
*3 <https://little-hands.hatenablog.com/entry/2018/12/10/ddd-architecture>
4
目次
はじめに 2 本書の構成 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 用語の定義 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 サンプルコードの言語 Kotlinについて . . . . . . . . . . . . . . . . . . . . . . 4 アーキテクチャ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 パッケージ表記について . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 免責事項 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
第 1章 DDD全般 10 1.1 DDDの目的、適用範囲 . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.1.1 主要な単語の定義 . . . . . . . . . . . . . . . . . . . . . . . . . 10 1.1.2 DDDの目的 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 1.1.3 DDDの向き・不向き . . . . . . . . . . . . . . . . . . . . . . . 11 1.1.4 新しい物を作るのに適用できる？ . . . . . . . . . . . . . . . . 12 1.1.5 BtoCのサービスに適用できる？ . . . . . . . . . . . . . . . . . 12
1.2 導入方法 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 1.2.1 どこから手をつければよいか . . . . . . . . . . . . . . . . . . . 13 1.2.2 レガシーコードへの実装パターン導入 . . . . . . . . . . . . . . . 13
1.3 設計時の原則 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 1.3.1 高凝集/低結合とテスト容易性 . . . . . . . . . . . . . . . . . . . 14
第 2章 モデリング 16 2.1 [解説]モデリング方法と具体的サンプル . . . . . . . . . . . . . . . . . . 16
2.1.1 システム関連図 . . . . . . . . . . . . . . . . . . . . . . . . . . 17 2.1.2 ユースケース図 . . . . . . . . . . . . . . . . . . . . . . . . . . 18 2.1.3 ドメインモデル図 / オブジェクト図 . . . . . . . . . . . . . . . 19
5
目次
2.1.4 モデリングと実装のつながり . . . . . . . . . . . . . . . . . . . 22 2.1.5 サンプルコード . . . . . . . . . . . . . . . . . . . . . . . . . . 22
2.2 モデリング . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 2.2.1 紹介されたモデル図は常に全部作る必要はある？ . . . . . . . . 28 2.2.2 モデリングはいつ行う？ . . . . . . . . . . . . . . . . . . . . . 28 2.2.3 モデル図は保守していかないといけない？ . . . . . . . . . . . . 29 2.2.4 4つのモデル図さえあればよい？ . . . . . . . . . . . . . . . . . 29 2.2.5 モデル図を管理するツール . . . . . . . . . . . . . . . . . . . . . 30
2.3 ユビキタス言語 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 2.3.1 ユビキタス言語ってこういう意味？ . . . . . . . . . . . . . . . 30 2.3.2 日本語で開発する場合のユビキタス言語 . . . . . . . . . . . . . 31 2.3.3 ユビキタス言語の管理方法 . . . . . . . . . . . . . . . . . . . . . 32
第 3章 エンティティ/値オブジェクト 33 3.1 混同しやすいものとの違い . . . . . . . . . . . . . . . . . . . . . . . . . 33
3.1.1 データモデルや ORマッパークラスとの違い . . . . . . . . . . . 33 3.1.2 ORマッパークラスの扱い方 . . . . . . . . . . . . . . . . . . . 36
3.2 エンティティの生成 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 3.2.1 DBの値からインスタンスを再構成するには？ . . . . . . . . . 37 3.2.2 プライマリコンストラクタが 1つしか実装できない場合 . . . . . 37 3.2.3 コンストラクタと ファクトリーメソッドの違い . . . . . . . . . 39 3.2.4 生成メソッドには値オブジェクトを渡してもよい？ . . . . . . . 40
3.3 エンティティが保持する値 . . . . . . . . . . . . . . . . . . . . . . . . . 41 3.3.1 ORマッパーが自動生成するカラムの扱い . . . . . . . . . . . . 41 3.3.2 楽観ロック用のバージョン情報はどう扱う？ . . . . . . . . . . 42
3.4 リポジトリからの取得 . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 3.4.1 処理に使用しない値も取得する必要はある？ . . . . . . . . . . 44
3.5 IDの扱い . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 3.5.1 DBのオートインクリメントの値を IDに使用してよい？ . . . . 45 3.5.2 識別子に日付を使用してもよい？ . . . . . . . . . . . . . . . . 47
第 4章 リポジトリ 48 4.1 リポジトリでやってよいこと、わるいこと . . . . . . . . . . . . . . . . 48
4.1.1 リポジトリで集約の一部のみアップデートしてもよい？ . . . . 48 4.1.2 リポジトリに件数チェックメソッドを書いてもよい？ . . . . . . 48
6
4.1.3 リポジトリでソート順を指定してもよい？ . . . . . . . . . . . . 49 4.1.4 リポジトリでページングしてもよい？ . . . . . . . . . . . . . . 50 4.1.5 複数エンティティを一括更新してもよい？ . . . . . . . . . . . . 52 4.1.6 リポジトリで悲観ロックをかけてもよい？ . . . . . . . . . . . . 52 4.1.7 insertと updateのメソッドを一緒にしてもよい？ . . . . . . . 53
4.2 実装上の注意点 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 4.2.1 集約の子オブジェクトをどうやって更新する？ . . . . . . . . . 54 4.2.2 リポジトリはどの層に定義すべき？ . . . . . . . . . . . . . . . 55 4.2.3 ファイルや外部サービスにデータを保存する処理 . . . . . . . . . 55
第 5章 集約 57 5.1 [解説]複数集約の整合性を確保する方法 . . . . . . . . . . . . . . . . . . 57
5.1.1 題材とする事例 . . . . . . . . . . . . . . . . . . . . . . . . . . 57 5.1.2 実装方法 1. ユースケースで複数集約を更新する . . . . . . . . . 58 5.1.3 実装方法 2. ドメインサービスを使用する . . . . . . . . . . . . . 60 5.1.4 実装方法 3. ドメインイベントを使用する . . . . . . . . . . . . . 63 5.1.5 どの実装方法を選択すればよいか . . . . . . . . . . . . . . . . . 71
5.2 集約の取り扱い . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72 5.2.1 複数集約を 1トランザクションで更新してよい？ . . . . . . . . 72
5.3 集約の設計 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72 5.3.1 集約の範囲の判断基準は？ . . . . . . . . . . . . . . . . . . . . 72
第 6章 ドメインサービス 75 6.1 ドメインサービス . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
6.1.1 ドメインサービスの命名 . . . . . . . . . . . . . . . . . . . . . . 75 6.1.2 ドメインサービスでリポジトリを使用してもよい？ . . . . . . . 76
第 7章 テスト 78 7.1 [解説]DDDにおけるテスト . . . . . . . . . . . . . . . . . . . . . . . . 78
7.1.1 テスト対象のモデル図 . . . . . . . . . . . . . . . . . . . . . . . 78 7.2 [解説]エンティティのテスト . . . . . . . . . . . . . . . . . . . . . . . . 80
7.2.1 生成メソッドのテスト . . . . . . . . . . . . . . . . . . . . . . . 80 7.2.2 ミューテーションメソッドのテスト . . . . . . . . . . . . . . . . 82 7.2.3 再構成メソッドのテスト . . . . . . . . . . . . . . . . . . . . . . 84
7.3 [解説]値オブジェクトのテスト . . . . . . . . . . . . . . . . . . . . . . 86 7.3.1 値オブジェクトが独立することによるテスト容易性の向上 . . . . 87
7
目次
7.4 [解説]ユースケースのテスト . . . . . . . . . . . . . . . . . . . . . . . . 87 7.4.1 更新系ユースケース . . . . . . . . . . . . . . . . . . . . . . . . 87 7.4.2 参照系ユースケース . . . . . . . . . . . . . . . . . . . . . . . . 89 7.4.3 テスト用インスタンス生成オブジェクト . . . . . . . . . . . . . 92 7.4.4 ユニットテストのメリット . . . . . . . . . . . . . . . . . . . . . 94
7.5 [解説]リポジトリのテスト . . . . . . . . . . . . . . . . . . . . . . . . . 94 7.5.1 インサートと ID検索メソッドのテスト . . . . . . . . . . . . . . 95 7.5.2 テストデータ作成用オブジェクト . . . . . . . . . . . . . . . . . 97 7.5.3 その他の条件で取得するメソッドのテスト . . . . . . . . . . . . 98
7.6 テスト実装時に迷うこと . . . . . . . . . . . . . . . . . . . . . . . . . . 100 7.6.1 モックを使ったテストに意味はある？ . . . . . . . . . . . . . . 100 7.6.2 外部サービス呼び出しはテストを書く？ . . . . . . . . . . . . . 102
第 8章 アーキテクチャ 105 8.1 例外処理 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
8.1.1 ユーザー表示するエラーメッセージを直接返してよい？ . . . . 105 8.1.2 投げられた例外はどう処理する？ . . . . . . . . . . . . . . . . 106
8.2 外部システムへのアクセス . . . . . . . . . . . . . . . . . . . . . . . . . 108 8.2.1 外部システムのクライアントクラスはどの層に書くべき？ . . . 108
8.3 認証情報 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109 8.3.1 認証情報はどう扱えばよい？ . . . . . . . . . . . . . . . . . . . 109 8.3.2 ユーザークラスを認証用クラスとして使用してよい？ . . . . . . 112
8.4 クエリモデル (軽量 CQRS) . . . . . . . . . . . . . . . . . . . . . . . . 113 8.4.1 ユーザー一覧をどう返す？ . . . . . . . . . . . . . . . . . . . . 113 8.4.2 参照系処理を全てクエリモデルにする必要がある？ . . . . . . . 115 8.4.3 クエリサービスにどこまでドメイン知識を持たせてよい？ . . . 116
8.5 それぞれの層の責務 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118 8.5.1 ユースケースの戻り値クラスはどこに定義すればよい？ . . . . 118 8.5.2 ユースケースの戻り値クラスに書式変換メソッドを実装してよ
い？ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119 8.5.3 ユースケースからドメイン層のオブジェクトを返してもよい？ . 119 8.5.4 エンティティ/値オブジェクトはどの層で組み立てるべき？ . . . 120 8.5.5 cronからの呼び出しはどの層に書くべき？ . . . . . . . . . . . 121 8.5.6 ライブラリに依存してよいのはどの層まで？ . . . . . . . . . . 121 8.5.7 トランザクションはどう扱えばよい？ . . . . . . . . . . . . . . 122
8
8.6 アーキテクチャその他 . . . . . . . . . . . . . . . . . . . . . . . . . . . 122 8.6.1 ユースケースからユースケースを呼んでよい？ . . . . . . . . . 122 8.6.2 複数集約で使用されるオブジェクトはどこに定義する？ . . . . 124 8.6.3 「業務ロジック」とは？ . . . . . . . . . . . . . . . . . . . . . 124 8.6.4 1つのアプリケーションで DDDのアーキテクチャとそうでない
ものを混在させてよい？ . . . . . . . . . . . . . . . . . . . . . 125 8.6.5 クリーンアーキテクチャの「エンティティ」との違いは？ . . . 125 8.6.6 インターフェイスを定義するメリットは？ . . . . . . . . . . . . 126 8.6.7 ファーストクラスコレクションはどこに定義すべき？ . . . . . . 127
第 9章 その他 129 9.1 プログラミング一般 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
9.1.1 オブジェクト指向である必要はある？ . . . . . . . . . . . . . . 129 9.1.2 1ファイルに複数クラスを定義してもよい？ . . . . . . . . . . . 129 9.1.3 エンティティをイミュータブルな実装にしてもよい？ . . . . . . 130 9.1.4 オブジェクトで値の詰め替えをするのがつらい . . . . . . . . . . 131
著者紹介 133 著者紹介 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133 謝辞 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
9
第 1章
DDD全般
本章では、DDDの目的や導入方法などに関する質問に対して解説します。
1.1 DDDの目的、適用範囲 1.1.1 主要な単語の定義 ドメインとはソフトウェアを適用して問題を解決しようとする領域のこと、ドメインモ デルとはドメインの問題を解決するために物事の特定の側面を抽象化したものです*1。 ドメインエキスパートとは、ドメインについて詳しい知識を持つ人のことです。
1.1.2 DDDの目的
  DDDの目的は何でしょうか？  DDDの目的は、「ソフトウェアの機能性と保守性の両方を高めること」です。 ソフトウェア開発は、ソフトウェアを使って特定の領域の問題を解決するために行われ ます。その問題を解決する能力が、機能性です。ユーザーの要求を満たす能力ともいえ ます。また、一度開発したソフトウェアの修正/拡張しやすさが、保守性です。つまり、 DDDでは、役に立つソフトウェアを、長期間保守性を下げずに作り続けられるようにす
*1 ドメイン、ドメインモデルなどの単語についてはモデリング/実装ガイド「第 1章 DDD概要」に詳細に 解説があります。
10
1.1 DDDの目的、適用範囲
ることを目指します。
そのために、DDDでは次のアプローチを行います。
• ①ドメインエキスパートと共に行うドメインモデリング
• ②頻繁なモデルの更新に耐えられる実装パターン
①は機能性向上のためのアプローチです。ドメインモデルにドメインの知識を反映する ことで、ソフトウェアが役に立つものになる可能性を高めます。また、開発初期だけでは なく、開発の各フェーズで得られた発見を頻繁にモデルにフィードバックすることで、機 能性の改善速度を向上させます。 ②は保守性向上のためのアプローチです。ドメインモデルの形をそのままコードで表現 することで、頻繁なモデルの更新をコードに反映しやすくします。頻繁な変更に耐えられ るように、保守性の高いデザインパターンを適用します。このパターンとして定義されて いるのがエンティティやリポジトリなどです。
たまに「DDDはモデリングしないと意味がない」と言う人がいますが、そんなことは ありません。2 つのアプローチは、目的さえ明確であれば個別でも十分に価値を発揮し ます。 ただし、2つのアプローチは「ドメインモデル」でつながっており、一緒に適用すると より大きな価値を発揮するようになっています。現場の問題に合わせてどのアプローチか ら導入するかを検討し、徐々に両方のアプローチに手を広げられるとよいでしょう。
1.1.3 DDDの向き・不向き
  DDD というのはさまざまな設計手法の中でも上位互換的な位置付けなのでしょ うか？  いいえ、そんなことはありません。向き不向きがあります。 DDD は、複雑なドメインの問題を解決するのに向いています。一方、簡単な CRUD
で済むようなアプリケーションの場合、提唱されるパターンで実装する上でのオーバー ヘッド、習得にかかるコストが、得られるものに見合わないことがあります。また、ソフ トウェアの価値の中心が技術的な複雑さであるもの、たとえば大量データの高速処理や機
11
第 1章 DDD全般
械学習処理自体が価値の中心であるようなソフトウェアの場合、DDDのアプローチが効 果を発揮しないことがあります。 常に DDDを採用すべきというわけではなく、問題と向き不向きを考慮して適用するか を判断する必要があります。
1.1.4 新しい物を作るのに適用できる？
  DDDは現実世界にドメインが存在しない新たな物を作ろうとするのには向いていな いでしょうか？  そんなことはありません。ドメインとは「ソフトウェアを適用して問題解決しようとす る領域」のことです*2。そう考えると、「ドメインが存在しない」ということは基本的にな いことがわかります。もし何の問題解決をするかわからないのであれば、まずはそこにつ いてきちんと定義する必要があります。 問題解決する対象が定まったら、そのドメインに詳しい人と一緒に解決策を考え続け、 それを保守性の高い形で実装していく、ということは、新しいものを作る時に十分価値が あると言えるでしょう。
1.1.5 BtoCのサービスに適用できる？
  DDDは BtoCのサービスでもうまく機能するのでしょうか？ BtoCのサービスの場 合、どのようにドメインエキスパートを探す、あるいは設定するのでしょうか。  BtoC でももちろん機能します。大切なことは、ドメインエキスパートという「個人」 が存在することではありません。 なぜドメインエキスパートのような存在が必要なのでしょうか？ それは、作ったソフ トウェアをちゃんと人の役に立ち、問題解決ができるものにするためには、ソフトウェア を適用する領域 (ドメイン)に詳しい人からきちんと知識を得ることが必要だからです。
*2 エンターテイメント系では「問題解決」を「利用者を楽しませる」とするなど、必要に応じて読み替えて ください。
12
1.2 導入方法
もしも「うちにはドメインエキスパートがいません」と諦めてしまう場合は、どうやっ てソフトウェアを役に立つものにするのでしょうか？ 誰かの知識を得ずに開発し、リリー スしてから反応をみるのも重要ですが、それだけでなく開発初期から詳しい人の知識をイ ンプットとして開発した方が、試行錯誤のサイクルやコストを小さくできるでしょう。
BtoC で特定のドメインエキスパートと呼べる個人がいなくても、「何を作るか」を決 める人は存在しているはずです。そういった場合は、何を作るか決める人自身がドメイン に詳しくなるか、ヒアリングなどでドメインに詳しい人の知見を吸い上げることが必要で しょう。
1.2 導入方法 1.2.1 どこから手をつければよいか
  DDDを導入するには、どこから手をつければよいですか？  大きく分けて、モデリングから着手するか、実装パターンの導入から着手するかに分け られます。 モデリングを新規開発機能に対して行うと、ドメインの問題を早期から深く理解し、解 決策の精度を上げて機能性を高められます。また、既存機能に対して行うと、暗黙知の可 視化や改善点の発見、知識の伝達に使える資料が作成できるなどの効果があります。 実装パターンの導入は、新規/既存にかかわらず、コードの保守性を高められます。 これらは個別に導入できますし、片方だけでも十分に価値があります。問題の大きさ、 興味関心、着手コストなどを考慮して着手するところを決めましょう。
1.2.2 レガシーコードへの実装パターン導入
  保守性改善のために DDD の実装パターンでレガシーコードをリファクタリングす る場合、どのように始めたらよいでしょうか？  既存プロジェクトへの実装パターン導入には、大きく分けて 2つの方針があります。 1つ目は、ボトムアップで少しずつコードを改善していく方針です。エンティティや値
13
第 1章 DDD全般
オブジェクトをくくり出す形で少しずつリファクタリングしていきます。メリットは、実 行コストが低く、すぐに始められることです。導入のために同意や交渉があまり必要な く、既存のリファクタリングの延長として実施できます。デメリットは、改善効果が限定 的で、ソフトウェア全体にまたがる問題解決には至りにくいことです。
2つ目は、トップダウンでアーキテクチャの改善方針 (特にレイヤーの定義、それぞれの レイヤーに書くべき責務)を決め、それを目標としてリファクタリングを進める方針です。 メリットは、全体として改善の方向性が定まり、成功時の改善効果を大きくできることで す。レイヤーとしてドメイン層がくくり出されると、モデリング結果を実装する先が明確 になり、モデリングとのつながりが作りやすくなります。デメリットは、方針をチームで 議論して合意する必要があるため実行までのコストが大きいこと、技術的難易度が高くな ることです。理想のアーキテクチャを描く力だけでなく、現状のアーキテクチャとの共存 方針を考えて推進する力も必要になるため、ボトムアップに比べると難易度は高いです。 この 2つの方針は並行可能です。まずはボトムアップで改善しつつ、改善の手応えをつ かめたら全体のアーキテクチャを考え出すような進め方をしてもよいでしょう。チームメ ンバーの技術力によっても取れる選択肢は変わってくるので、柔軟に進め方を検討してく ださい。
1.3 設計時の原則 1.3.1 高凝集/低結合とテスト容易性
  保守性向上のために、設計/実装時に意識するべき原則はありますか。  コードの保守性を高めるために、次の 2つの原則は常に意識する必要があります。
• ①責務を意識して、高凝集/低結合な実装にすること
• ②テスト容易性が高い実装にすること
この 2つは関連があり、高凝集/低結合になるほどテストしやすくなり、逆も然りです。 責務とは、「このクラスは何をする (何を表す)クラスか？」という問いに対する答えで
す。凝集度とは 1つのクラスについて「責務、データ、振る舞いの関連の強さ」の尺度で、 結合度とは複数のクラス同士が依存している度合いの尺度です。凝集度は高く、結合度は
14
1.3 設計時の原則
低くなるほど保守性が高まります*3。 設計/実装についてはたくさんのプラクティスがありますが、この 2つの原則をおさえ ると多くのケースで改善できます。「責務！ テスト！」をキーワードに、まずはこの原則 を常に意識するとよいでしょう。
なお、DDDの実装パターンは、2つの原則を実現するために有効なデザインパターン となっています。ただパターンの形を真似するだけでなく、2つの原則の観点からパター ンの意図を考察するとより理解を深めて設計/実装できます。
*3 凝集度/結合度に関しては、モデリング/実装ガイド「4.1 凝集度・結合度について」に詳細な解説があり ます。
15
第 2章
モデリング
本章では、DDDにおけるモデリングと、そこからコードに落とし込むまでを具体的に 解説します。
DDDにおけるモデリング手法は具体的に定められているものはなく、開発者が必要に 応じて選択する必要があります。本書では、筆者が複数の現場でモデリングをしてきた中 で、最も導入ハードルが低く効果を出しやすいと考えている手法を紹介します。
2.1 [解説]モデリング方法と具体的サンプル 本節では、
• システム関連図
• ユースケース図
• ドメインモデル図
• オブジェクト図
の 4つを使うモデリング方法を紹介します*1。頭文字をとって「"sudo"モデリング」と 覚えましょう。それぞれについて、具体例を用いて説明します。
モデリングの題材 モデリングの題材は、人事などの採用担当者が企業への応募者を管理する、採用管理 システムとします。システム開発初期のモデリングをシミュレーションしながら解説し ます。
DDDでは、「モデルは最初から完成せず、どんどん更新していくもの」というスタンス
*1 モデリング/実装ガイドから、システム関連図、オブジェクト図が追加されました。
16
2.1 [解説]モデリング方法と具体的サンプル
に立つことが非常に重要です。各モデル図は初版を作成後、開発の各タイミングで得られ た発見を随時反映していきます。今回の事例ではより現実感を持たせるために、実際に発 生する「まずはこの想定で仮置きして進めよう」「ここは決まっていないけど後回しにし よう」といった内容も表現しています。
2.1.1 システム関連図 システム関連図は、開発するシステムと、関わりのあるアクターや外部システムとの関 連を示す図です。例として、採用管理システムを開発する初期フェーズでモデリングを 行ったものが次の図です。
▲図 2.1 システム関連図
簡単な図のようですが、この図を整理するためには次のような疑問に対して答えを出す 必要があります。
• これは誰が使うシステムなのか？
• 開発するシステムで応募を直接受け付けるのか？
これらついてモデリング時に議論し、意思決定した結果をモデル図に反映します。 今回の例では、開発するのは採用担当者のみが直接操作するシステムとし、応募は簡易 的なフォームで受け付け、応募者情報は採用管理システムに手入力することにしました。 このような意思決定は、後から見直した時にすぐわかるように①②のように記述しておき
17
第 2章モデリング
ます。
ここで、もし応募をシステムで直接受け付けるという結論になった場合、開発するもの のスコープが大きく変わります。この認識を揃えずに開発を進めると後続のモデリングや 開発で議論がすれ違ってしまう原因となるため、早期にシステム関連図を整理して認識を 合わせておくことは重要です。 今後直接応募を受け付けるシステムになる可能性はありますが、まずは受け付けない前 提で開発を進めるという決定をし、次のモデリングに進みます。
2.1.2 ユースケース図 ユースケース図は、ユーザーの要求に対するシステムの振る舞いを定義する図です。 図 2.1①「開発するシステム」と書かれているものが図 2.2①と対応しており、このシ
ステムのアクターに応募者が存在しない点はシステム関連図の意思決定結果を反映してい ます。
▲図 2.2 ユースケース図
このシステムのユースケースとしては多くのものが考えられますが、まずはこのタイミ ングでのドメインモデル図作成の対象とするものを絞り込みます (②)。今回は、まず採用 選考や面接を登録するユースケースを対象とし、メール送信などは必要になりそうですが 後に回すことにします。 なお、ユースケース図作成時点で何か発見があった場合、システム関連図に戻って更新 します。4つのモデル図は一方通行ではなく、常に行き来して更新する必要があります。
18
2.1 [解説]モデリング方法と具体的サンプル
2.1.3 ドメインモデル図 / オブジェクト図 続いて、ドメインモデル図とオブジェクト図を作成します。この 2つは、抽象物と具体
例の関係なので、同時に行き来しながら作成します。 ドメインモデル図は、簡易化したクラス図のようなもので、次のようなルールで記述し ます。
• オブジェクトの代表的な属性を書くが、メソッドは書かなくてよい
• 「ルール/制約 (ドメイン知識)」を吹き出しに書き出す
• オブジェクト同士の関連を示す
• 多重度を定義する
• 集約の範囲を定義する
• 日本語と英語の対訳を定義する
オブジェクト図は、ドメインモデルの具体例を記した図です。 ここで具体例を書き出していくことが、モデリング参加者の認識を合わせ、発見を生み 出すために非常に重要になります。具体的な情報があった方が、モデリング対象について イメージし、理解しやすいからです。
ドメインモデル図/オブジェクト図の例 図 2.2ユースケース図で登場する「採用選考」「面接」について、オブジェクト図から 書き始めます。例として、サーバーサイドエンジニアの採用ポジションに対する「2次選 考まで進んでいる、進行中の採用選考」と、「1次面接で不採用になった採用選考」を記し たのが次の図です。
19
第 2章モデリング
▲図 2.3 オブジェクト図
オブジェクト図の具体例をもとに抽象化したものが次のドメインモデル図です。
▲図 2.4 ドメインモデル図
ドメインモデル図では、最終的にエンティティ/値オブジェクトとなるオブジェクトと、 それに関わるルール/制約 (=ドメイン知識) を記載します (①)。たとえば、「選考ステー
20
2.1 [解説]モデリング方法と具体的サンプル
タスってどんなのがある？」といった疑問が生じたら、その場で議論して決定した内容を 記載します。 モデリング時に発生した未決事項や今後の展開に関しては、②③のようにメモしておき ましょう。正式な仕様書という感覚ではなく、議事録のように話した内容を気軽にメモす る感覚で書くとよいでしょう。ドメインモデル図をもとに発見を誘発し、関係者の認識を 残しておくために必要なものは積極的に記述しましょう。 多重度は④のように記します。「採用選考から採用ポジションを紐づけることは必須な のか？」といったことは、ルール/制約として大切な意思決定となります。 オブジェクト、ルール/制約の記述がある程度できてきたら、集約の範囲を決定します
(⑤)。リポジトリは集約に対して 1つ作るので、集約の範囲が決まるとエンティティ、値 オブジェクト、リポジトリがどういう形で実装されるかが決まります。ただし、集約の範 囲の良し悪しは実装してみないとわからないことが多いです。ここで一旦決定したあと、 実装して問題があればいつでもドメインモデル図に戻って更新します。 なお、必須ではありませんが、実装時に集約内はインスタンス参照、集約外は ID参照 になるので、それを関連の線でも表現します。ここでは集約内はコンポジション表記 (◆ -)、集約外は矢印表記 (→)としています。 実装直前に、オブジェクトの日本語名の対訳として英語名を決めます (⑥)。ここで英語 名を決めると、この後のエンドポイント名、テーブル名、クラス名などで使われる名称が 表記揺れするのを防げます。このモデル図上の日本語名、英語名を合わせてユビキタス言 語とします。
具体例 (オブジェクト図)の重要性 まったく採用業務について知識がなかった場合、図 2.3のオブジェクト図と図 2.4のド
メインモデル図ではどちらがパッと見で理解し、開発していくイメージを持ちやすいで しょうか。多くの場合、図 2.3 の具体例から入った方が理解しやすいでしょう。なぜな ら、「具体例→抽象化」はある程度スキルがあればできますが、「抽象物→具体化」は知識 がないとできないからです。 そのため、モデリングにドメインエキスパートが参加し、ドメインに関する具体的な知 識を提供することがとても重要になります。そして、ドメインエキスパートの知識をオブ ジェクト図、ドメインモデル図という形に落とし込めば、その後の開発で携わる人たちに 知識を引き継いでいくことが可能になります。
オブジェクト図とドメインモデル図の作成順 本節の冒頭で記した通り、この 2つの図はセットで、同時に行き来しながら作成します。 今回は誌面の都合上ある程度まとまった段階のものをいきなり記載していますが、実際は
21
第 2章モデリング
「具体例を出し、抽象化」を少しずつ、何度も行き来しながらこの段階まで到達します。
オブジェクト図とドメインモデル図の配置 2つの図を別々に描かずに、ドメインモデル図上にオブジェクトの具体値を重ねて描い ても構いません。認識を揃えて、発見を促すという目的が達成できれば、細かいルールに 縛られる必要はありません。ぜひ描きやすい方法を探求してください。
2.1.4 モデリングと実装のつながり ドメインモデル図を作成後、その決定をもとに最初の実装を行います。その後、開発の 各工程で生まれた発見からドメインモデル図は随時更新され、その更新をコードに反映す る必要が生まれます。この時、モデルとコードの形が大きく乖離していると、モデルの更 新をコードのどの部分に反映するかの判断が難しくなります。これが続くと、せっかく理 想のモデルはできているのに、コードに反映できず、ソフトウェアの機能性向上につなげ られない、ということが発生してしまいます。 そのような事態を避けるためには、モデルとコードの形を近づけることが重要になりま す。そして、モデルとコードの形を近づけるためのベストプラクティスとして定義されて いるのが、エンティティや値オブジェクトといった実装パターンです。
また、モデルの更新は開発の各工程で起こり得るため、頻度が高くなります。その頻繁 な更新をコードに反映するにあたり、回帰テストを毎回手動で行っていては、手動テスト の負担に耐えられずコードへの反映を断念してしまったり、バグを埋め込んでしまったり する可能性があります。そのような事態を防ぐため、DDDではテストの自動化はとても 重要な要素で、欠かすことはできません。 テストに関しては、「第 7章 テスト」で詳細に解説します。
2.1.5 サンプルコード 作成したドメインモデル図を実装したコードを掲載し、それぞれについて解説します*2。 言語は Kotlinです。
採用選考エンティティ まずは、採用選考を表すエンティティは、次のようになります。
*2 本節では最終的なコードのみ掲載しますが、ドメインモデル貧血症からリファクタリングしていく流れは モデリング/実装ガイド「第 2章 モデリングから実装まで」に解説があります。
22
2.1 [解説]モデリング方法と具体的サンプル
▼リスト 2.1 採用選考エンティティ
package dddfaq.domain.screening
/** *採用選考 */
class Screening private constructor(// ④ screeningId: ScreeningId, positionId: PositionId, applicant: Applicant, interviews: Interviews, status: ScreeningStatus, applyDateTime: LocalDateTime,
) { // ① エンティティが保持する属性 val screeningId = screeningId // 採用選考ID val positionId = positionId // 採用ポジションID val applicant = applicant // 応募者 val applyDateTime = applyDateTime // 応募日時 var interviews = interviews // 面接
private set var status = status // 選考ステータス
private set
companion object { /** ② 新規採用選考を作成します */ fun create(positionId: PositionId, applicant: Applicant): Screening {
return Screening( // 以下の値は初期値を設定 screeningId = ScreeningId(), // IDは新規生成 interviews = Interviews.empty(), // 面接の集合は初期値として0件 status = ScreeningStatus.IN_PROGRESS, // ステータスは選考中から始まる applyDateTime = LocalDateTime.now(), // 応募日はインスタンス生成タイミング
// 以下の値は引数の値を設定 positionId = positionId, applicant = applicant,
) }
/**③ DBなどの値からインスタンスを再構成します */ fun reconstruct(
screeningId: ScreeningId, positionId: PositionId, applicant: Applicant, interviews: Interviews, status: ScreeningStatus, applyDateTime: LocalDateTime
): Screening { return Screening(
screeningId = screeningId, positionId = positionId, applicant = applicant, interviews = interviews, status = status, applyDateTime = applyDateTime,
) }
}
/** 面接を追加します */ fun addInterview(interviewDateTime: LocalDateTime) {
if (!status.canAddInterview) { // ⑤ throw DomainException("面接が選考中ではありません")
} this.interviews = this.interviews.addInterview(interviewDateTime)
}
23
第 2章モデリング
/**ステータスを「採用」にします */ fun adopt() {
this.status = ScreeningStatus.ADOPTED }
/** ステータスを「不採用」にします */ fun reject() {
this.status = ScreeningStatus.REJECTED }
}
①: エンティティが保持する属性について、不変な値は valで、可変な値は varで定義 します。セッターを公開するとドメイン知識 (ルール/制約) の制御をかけずに勝手に値 を変更できてしまうので、それを防ぐためにセッターの可視性を private にしています。 Kotlinではこれをプロパティ定義直後に private set と記述します。 ②: 新規インスタンス生成用のファクトリーメソッドです。初期ステータスが「進行中」 である、などのドメイン知識を表現します。ユースケースクラスからはこちらのメソッド を使用します。なお、Kotlinの文法で companion objectブロック内にあるメソッドはス タティックメソッドとなり、createメソッドは Screening.create という記述で呼び出せ ます。 ③: リポジトリの実装クラスから DBの値を取得してインスタンス生成時に使用するメ ソッドです。このメソッドはユースケースクラスなどから呼ばせたくないので、命名規 則、静的解析、言語仕様で可能なら可視性制御などで制御します。 ④: コンストラクターが privateになっているので、クラスの外側からは②③のいずれ かのファクトリーメソッドを使用しないとインスタンスが生成できないように制御されて います。 ⑤: 図 2.4ドメインモデル図の「選考ステータスが『選考中』の時のみ面接を追加できる」 というドメイン知識 (ルール/制約)を表現しています。具体的な判定は ScreeningStatus に委譲しています。
なお、Kotlinにおける①のプロパティの定義方法は次のような記述の方が自然で、リス ト 2.1と同じ意味になりますが、Kotlinに詳しくない方でも読めるようにリスト 2.1のよ うな記述にしています。本書で同様の記述は同じ狙いですので、ご了承ください。
▼リスト 2.2 Kotlinらしいプロパティの記述方法
class Screening private constructor( val screeningId: ScreeningId, val positionId: PositionId, val applicant: Applicant,
24
2.1 [解説]モデリング方法と具体的サンプル
val applyDateTime: LocalDateTime, interviews: Interviews, status: ScreeningStatus,
) { var interviews = interviews
private set var status = status
private set
選考ステータス enum 続いて、選考ステータスを表す enumは次のようになります。
▼リスト 2.3 選考ステータス enum
package dddfaq.domain.screening
/*** 選考ステータス */
enum class ScreeningStatus( /**面接追加可否 */ val canAddInterview: Boolean // ①
) { /** 選考中 */ IN_PROGRESS(true), // ②
/**採用 */ ADOPTED(false),
/** 不採用 */ REJECTED(false),
}
この enumが取りうる値は図 2.4ドメインモデル図の「選考ステータスは『選考中』『採 用』『不採用』」というドメイン知識を反映しています。 ①: 選考ステータス enumに面接追加可否の情報を持たせました。「選考中ステータス であればは面接追加可能」といった具体的な設定は②のように定義できます。enumにこ のような変数を持たせると、区分値ごとのルールが明確になるため可読性が上がります。 また、区分値追加時に対応する値を記述しないとコンパイルエラーになるため、定義し忘 れて想定外の挙動になることを防止できます。
採用選考と採用ポジションの IDを表す値オブジェクト IDを表す値オブジェクトは次のようになります。
▼リスト 2.4 採用選考 ID を表す値オブジェクト
25
第 2章モデリング
package dddfaq.domain.screening
/*** 採用選考ID */
data class ScreeningId(val value: String) { constructor() : this(ULID.random()) // ①
}
▼リスト 2.5 採用ポジション ID を表す値オブジェクト
package dddfaq.domain.position
/*** 採用ポジションID */
data class PositionId(val value: String) { constructor() : this(ULID.random())
}
①: インスタンス生成時には ScreeningId() と記述をすることで、ランダムな文字列で 新規生成できます。今回は省略しましたが、ランダムな文字列の生成は ID 採番用オブ ジェクトに処理を委譲して共通化が可能です。
面接を表す値オブジェクト、そのファーストクラスコレクション 面接を表す値オブジェクトと、そのファーストクラスコレクションは次のようになりま す。ファーストクラスコレクションとは、コレクションをラップして、独自のメソッドを 持たせたクラスです。
26
2.1 [解説]モデリング方法と具体的サンプル
▼リスト 2.6 面接値オブジェクトとそのファーストクラスコレクション
package dddfaq.domain.screening
/*** 面接 */
data class Interview( /**面接次数 */ val phase: Int, /** 面接日時 */ val dateTime: LocalDateTime
)
/*** 面接のファーストクラスコレクション */
data class Interviews(val value: List<Interview>) {
/**面接を追加します */ fun addInterview(interviewDateTime: LocalDateTime): Interviews {
val newInterview = Interview( phase = this.value.size + 1, // 既存の面接の1つ後の面接次数を設定 dateTime = interviewDateTime
) return Interviews(this.value + newInterview)
}
companion object { /* 初期状態のインスタンスを生成します */ fun empty() = Interviews(emptyList())
} }
「面接を 1件追加する」といった集合に対する操作は、親となる採用選考クラスに持た せるより、面接の集合を表すファーストクラスコレクションとして実装した方が責務が明 確になり、保守性が高まります。 なお、ファーストクラスコレクション自体はエンティティでも値オブジェクトでもあり ませんが、ドメインの知識を表現するクラスとして適切であれば、そのようなクラスをド メイン層に定義しても問題ありません。
応募者を表す値オブジェクト 最後に、応募者を表す値オブジェクトは次のようになります。
▼リスト 2.7 応募者値オブジェクト
package dddfaq.domain.screening
/** *応募者
27
第 2章モデリング
*/ data class Applicant(val name: String, val mailAddress: String)
図 2.4のドメインモデル図では名前とメールアドレスしか定義しなかったので保持する 情報が少ないですが、実際はもっと増えていくことが予想されます。変更が必要となった 場合は随時ドメインモデル図を更新し、実装にも反映します。
2.2 モデリング 2.2.1 紹介されたモデル図は常に全部作る必要はある？
  4種類のモデル図は常に全て作成しなければいけませんか？  いいえ、必要に応じて作成すれば大丈夫です。 システム関連図は、関連するシステム数が少なく、そこに認識ずれの余地があまりなけ れば省略してもよいでしょう。 ユースケース図は、新規機能開発時には作成することをおすすめします。アクターとし て誰が使うのか、開発する機能で何ができるのか、といったことの認識ずれが後で判明す ると大きく手戻りが発生する原因になります。ただし、誰がどう使うのかをユーザース トーリー形式で言語化するなど、別のアプローチで代替できれば必須ではありません。 ドメインモデル図とオブジェクト図は極力作成しましょう。シンプルな機能だと思って も、モデル図を作成してみると意外な発見が見つかることは多いです。
2.2.2 モデリングはいつ行う？
  モデリングはいつ行うのがよいでしょうか？  要件定義の段階から始め、開発の各フェーズで行いましょう。モデルに関する疑問や発 見があれば随時議論し、決定事項をモデル図に反映します。 画面モック作成時、開発チケット詳細化時、実装時、機能拡張検討時…など、開発中は 常に疑問や発見が生まれる可能性があります。要件定義フェーズ、設計フェーズのような
28
2.2 モデリング
「モデリングフェーズ」は存在せず、モデルは常に更新し続けるものだと認識しましょう。
2.2.3 モデル図は保守していかないといけない？
  一度作成したモデル図は、その後保守・更新していく必要がありますか？  システム関連図は、システム全体を俯瞰する資料として価値があるので可能ならば保守 できるとよいでしょう。 ユースケース図は保守しなくてもよいでしょう。実際のユースケースは開発を進めると 随時変わっていきますが、ユースケース図をそこに追従させてもコストに対して得られる ものがあまり多くありません。 ドメインモデル図とオブジェクト図は必ず保守対象にします。ドメインモデル図とコー ドを乖離させないことは、その後ドメインモデルの更新をコードに反映していくために必 要です。ここで重要なのは、「先にドメインモデル図を更新し、その後にコードに反映」と いう順番を守ることです。ドメイン知識に認識ずれがあった場合、動くものを作成した後 よりもドメインモデル図検討段階で認識合わせした方が、修正コストが圧倒的に小さくな るためです。また、この順番であればモデル図の更新が漏れることもありません。
2.2.4 4つのモデル図さえあればよい？
  4つのモデル図さえ作れば、他には何も作る必要はありませんか？  そんなことはありません、モデル図によって得意不得意はあるため、別のモデル図を 作った方が役に立つこともあります。「sudoモデリング」の 4つの図は、DDDを進める 上で多くのケースで必要になる組み合わせというだけです。 複雑な状態遷移を整理したい場合は状態遷移図、外部サービスとのやりとりを整理した い場合はシーケンス図、など、必要に応じて別の表現は検討してください。
29
第 2章モデリング
2.2.5 モデル図を管理するツール
  モデル図を管理するのにどんなツールを使うとよいでしょうか。  オンラインでリアルタイム編集ができる製図ツールである、diagrams.net*3、miro*4を
おすすめします。ブラウザ上や専用アプリケーション上で直感的に操作できるため、議論 しながらモデリングする際にホワイトボードの代わりに使用できます。また、体裁を整え て成果物を正式な保守対象ドキュメントとしても扱うことができます。 どちらも非常に優れたツールですが、多少の機能性の違いと操作感の好みがありますの で、実際に使って比べてみてください。 以前は PlantUML*5も紹介していましたが、現在はあまりおすすめしていません。テキ ストで記述できて版管理できるメリットはあるものの、複雑な図を作成するのが難しいた めです。 なお、ツールは常に新しいものが出てくるため、推奨内容は 2021年秋時点のものです。
2.3 ユビキタス言語 2.3.1 ユビキタス言語ってこういう意味？
  ユビキタス言語というのは、要は「表記の揺れをなくそう」という意味ですか？  いいえ、そう捉えられがちですが、それ以上に大きな意味があります。 ユビキタスとは、「in everywhere」という意味です。これはつまり、「会話でも、ドキュ メントでも、画面でも、コードでも」ということを示します。 会話とドキュメントで使われている言葉が統一されていても、画面やコードの言葉が異 なっていたらそれはユビキタスではありません。たとえば、会話では「通知」、画面では
*3 <https://www.diagrams.net/> *4 <https://miro.com/> *5 <https://plantuml.com/ja/>
30
2.3 ユビキタス言語
「お知らせ」、コードでは「Message」が使われていたらどうでしょう。これらの言葉は微 妙にニュアンスが異なるものであり、この違いは認識のずれを生んでしまいます。そのた め、これらの言葉を統一することで、不要な認識ずれの発生を防ぐことを目指します。
では、その言葉の定義は何を正とすべきでしょうか。それは、ドメインモデルです。ド メインモデルは、ドメインエキスパートと開発者が一緒によりよい表現を求めて探求する 成果物です。だからこそ、そこで定められる言葉こそがユビキタス言語とするのにふさわ しいものになります。使用する言葉を変更する必要があれば、まずドメインモデルを更新 し、それを元にしてコードやその他のドキュメントなどに反映します。
ドメインエキスパートと開発者が一緒に作るドメインモデルをバックボーンとし、それ を会話でも、ドキュメントでも、コードでも使う。それがユビキタス言語です。
2.3.2 日本語で開発する場合のユビキタス言語
  コードではクラス名などに英語を使っていますが、普段のコミュニケーションは日本 語で行っています。この場合ユビキタス言語は何語で定義すればよいのでしょうか。  いくつか方法は考えられますが、おすすめの方法は「2.1.3 ドメインモデル図/ オブジェ
クト図」で解説した通り、ドメインモデル図作成時に対訳を定義する方法です。 もちろん英語で統一できれば理想ですが、それが難しい場合は最低 1回は翻訳が必要に なります。その 1 回を行うならば、ユビキタス言語を定めるドメインモデル図作成時が 最も適しています。モデル図上に記される「日本語と英語のペア」をユビキタス言語とし ます。
なお、翻訳をしない方法としては、コードでも日本語を使用する、もしくはローマ字表 記を使用するというものもあります。母国語でそのままユビキタスにできる英語圏の開発 者は少し羨ましいですね。
31
第 2章モデリング
2.3.3 ユビキタス言語の管理方法
  ユビキタス言語はどのような形で管理すればよいでしょうか？  「正となる言葉を定義する」という感覚からか用語集のようなものを作るアプローチを 取られることがありますが、そのようなテキストによる管理ではなく、モデリングで作成 したドメインモデル図を原本として管理しましょう。 重要なポイントは、管理コストを下げ、更新し忘れないようにすることです。用語集を 原本として管理しようとすると、モデリングしたあとに別途用語集を更新することになり ますが、モデリングからコードに落とす上で必要性を感じにくく、更新し忘れやすくなり ます。 一方、ドメインモデル図自体を原本として「モデル図を更新してから実装に入る」とい う流れを守れば、常に原本が最新化されるので更新し忘れることがありません。
32
第 3章
エンティティ/値オブジェクト
本章では、エンティティ/値オブジェクトについて、頻出の質問に具体的なコードを示 しながら解説します。
3.1 混同しやすいものとの違い 3.1.1 データモデルや ORマッパークラスとの違い
  エンティティや値オブジェクトは、データモデルや OR マッパーのクラスとどう違 うのでしょうか。  エンティティ/値オブジェクトはドメインモデルをそのまま表現したクラスです。表現 する際に、RDBのテーブル設計に関する制約や、ORマッパー固有の実装方法などの影 響を受けないようにします。 一方、データモデルはデータを永続化するためのモデルで、RDBであればテーブルと
して表現されます。ORマッパーのクラスはデータベースにプログラムのデータをマッピ ングするクラスです。 これらはそれぞれ目的や最適な形が異なります。例題をもとに比較してみましょう。次 のようなドメインモデルを実装する場合を考えます。
33
第 3章エンティティ/値オブジェクト
▲図 3.1 ドメインモデル
このドメインモデルをそのままの形でコードに落としたエンティティ/値オブジェクト が次のものです。
▼リスト 3.1 エンティティと値オブジェクト
data class User( val userId: String, val name: String, val mailAddresses: List<MailAddress>
)
data class MailAddress( val value: String
) { init {
// 書式のバリデーションを実装する }
}
それぞれのクラスが保持している情報が同じで、図 3.1のモデルの形を維持しているこ とがわかります。Userクラスは userId*1を識別子とするエンティティ、MailAddressク ラスは値オブジェクトです。
一方、これを保存する RDBのテーブル (データモデル)は次のようになります。
*1 通常は IDに型を持たせますが、ここではシンプルにするために省略しています。
34
3.1 混同しやすいものとの違い
▲図 3.2 RDB テーブル
①に、図 3.1のドメインモデル図には存在しなかったユーザー IDが増えています。こ れは、RDBではテーブル同士の関連を示すために、子テーブルから親テーブルの向きで カラムを保持して参照する必要があるからです。逆に、ユーザーを表すテーブルにはメー ルアドレスに関する情報がなくなりました。 また、他にも子テーブルとしてメールアドレスを持つテーブルが作られる可能性があ るので、mail_addressesテーブルではなく user_mail_addressesテーブルという命名に なっています。
このテーブルに対して、ORマッパーのクラスは次のようになります*2。
▼リスト 3.2 User オブジェクトと UserMailAddress オブジェクト
@Table(tableName = "users") data class User(
val userId: String, val name: String, val mailAddresses: List<UserMailAddress>
)
@Table(tableName = "user_mail_addresses") data class UserMailAddress(
val user: User // ① val mailAddress: String
){ init {
// 書式のバリデーションを実装する }
}
テーブルと対応するため、UserMailAddressクラスは①のように親クラスを参照し、相 互参照になっています*3。クラス名、保持する属性、参照方向などに図 3.1のドメインモ デル図との乖離が生まれ、UserMailAddressクラス単体で何を表すのか若干わかりにくく
*2 架空の ORマッパーを想定したイメージ実装です。 *3 この実装方法は ORマッパーによって異なりますが、ポピュラーな ORマッパーでみられる実装です。
35
第 3章エンティティ/値オブジェクト
なります。このようなずれは、ドメインモデルが複雑になるほど大きくなっていきます。 また、メールアドレスのバリデーションに関するユニットテストを実装する際、リスト
3.1のMailAddressクラスであればシンプルに 1クラスだけでテストが書けますが、リス ト 3.2の UserMailAddressクラスにテストを書こうとするとテスト観点に関係なくても Userクラスのインスタンスが必要になり、テスト容易性が相対的に低くなっています。
以上のように、エンティティ/値オブジェクトと、データモデル、ORマッパーのクラ スは役割が異なり、最適な形が異なります。そして、エンティティ/値オブジェクトを用 いてドメインモデルをそのまま表した形でクラスを実装することは、ドメインモデルの更 新を反映しやすくする点、クラスの可読性やテスト容易性を高める点で重要になります。
3.1.2 ORマッパークラスの扱い方
  エンティティ/値オブジェクトと ORマッパーのクラスはどのように使い分ければよ いでしょうか？  OR マッパーのクラスは、インフラ層のリポジトリの実装クラス*4の中でだけ使用し、
ドメイン層とユースケース層では参照されないようにします。前節で解説した通り、OR マッパーのクラスをそのままエンティティや値オブジェクトとして使用することは非推奨 です。 具体的な処理としては、リポジトリの更新系メソッドでは引数に渡されたエンティ ティ/値オブジェクトを ORマッパーのクラスに詰め替え、insert、updateクエリを実行 します。参照系メソッドでは OR マッパーのクラスを使用して DB から値を取得し、結 果からエンティティ/値オブジェクトインスタンスを生成して返します。 詳しくは「7.5.1 インサートと ID 検索メソッドのテスト」にサンプルコードと解説が あるので、そちらをご覧ください。
*4 リポジトリはインターフェイスをドメイン層、実装クラスをインフラ層に実装します。
36
3.2 エンティティの生成
3.2 エンティティの生成 3.2.1 DBの値からインスタンスを再構成するには？
  ドメイン知識に基づいた初期値を設定する生成メソッドでは、リポジトリ内で DB の値からインスタンスを組み立てることができません。どうしたらよいでしょうか。  DBの値からインスタンスを再構成する専用の生成メソッドを作成します。具体例は次 節の再構成メソッドを参照してください。
3.2.2 プライマリコンストラクタが 1つしか実装できない場合
  プライマリコンストラクタが 1つしか定義できないのですが、2種類の生成メソッド をどう実装すればよいでしょうか。  Javaでは引数の異なるコンストラクタを複数定義して、それぞれを同等に扱うことが できます。一方、Kotlinでは、1つのコンストラクタが「プライマリコンストラクタ」と 定義され、残りのコンストラクタは必ずそれを経由する必要があります。 その場合は、プライマリコンストラクタをプライベートにして、残りのコンストラクタ もしくはファクトリーメソッド (以下、生成メソッド)からプライマリコンストラクタを 呼び出すようにします*5。
▼リスト 3.3 可視性が private なプライマリコンストラクタとそれを呼び出す生成メソッド
class Task private constructor( // ① name: String, postponeCount: Int, status: TaskStatus
) { val name: String = name var postponeCount: Int = postponeCount
private set var status: TaskStatus = status
*5 コンストラクタの仕様は言語によって異なるので、他の言語での実装方法はそれぞれ検討してください。
37
第 3章エンティティ/値オブジェクト
private set
fun postpone() { this.postponeCount += 1
}
companion object { /** 新しいタスクを作成します */ fun create(name: String): Task { // ②
return Task( name = name, postponeCount = 0, status = TaskStatus.TODO
) }
/** タスクを再構成します */ fun reconstruct( // ③
name: String, postponeCount: Int, status: TaskStatus ): Task {
return Task(name, postponeCount, status) }
} }
①はプライマリコンストラクタですが、可視性を privateにしているので Taskクラス 外からは呼べなくなっています。②はドメイン知識を表現した初期値を設定している生成 メソッドです。③は任意の値からインスタンスを再構成するための生成メソッドです。 ①のコンストラクタを公開すると次のような不整合なインスタンスを作成できてしまう ので、これを防ぎます。
▼リスト 3.4 不整合なインスタンスを生成できてしまうコンストラクタ
// 任意の値を設定できると、不整合なインスタンスが作成できてしまう val wrongTask = Task(
name = "wrong", postponeCount = -100, // ×: 延期回数がマイナス status = TaskStatus.DONE // ×: 作成していきなり完了状態
)
// ドメインの知識を表現した生成メソッドであれば、不整合なインスタンスは作成できない val rightTask = Task.create(name = "right")
リスト 3.3 ③の再構成メソッドは次のようにインスタンスを再構成していることをメ ソッド名で明示します。
38
3.2 エンティティの生成
▼リスト 3.5 再構成メソッド
// taskTableというORマッパーのクラスがDBからデータを取得した想定 val task = Task.reconstruct(
name = taskTable.name, postponeCount = taskTable.postponeCount, status = TaskStatus.valueOf(taskTable.status)
)
再構成メソッドは、プロダクトコードではリポジトリの実装クラスで DBの値からイン スタンス再構成する場合のみ使用します。 一方、テストコードの中では、テストに必要な任意のインスタンスを作成するために使 用できます。そのため、fromRepository といった名前ではなく reconstruct という名称 にしていますが、名前は任意のものをつけて構いません。 再構成メソッドをプロダクトコードではリポジトリ以外で使わせないという制限は、 コード規約として定義する、静的解析で違反検知する、可視性で制御するという方針が考 えられます。ただし、言語やライブラリによってはコード規約でしか対応できない場合が あります。筆者の経験では、シンプルなルールなのでコード規約だけでも十分運用可能だ と考えています。
3.2.3 コンストラクタとファクトリーメソッドの違い
  コンストラクタと、staticな ファクトリーメソッドは何が違うのでしょうか？  名前が付けられるということです。それ以外に大きな違いはありません。 リスト 3.3 ②のメソッドは createというファクトリーメソッドにしていますが、③の
reconstructと同列にファクトリーメソッドで揃えた方がわかりやすいという理由で揃え ています。これは名前のないコンストラクタで実装しても問題ありません。 ただし、前節の説明の通り、リスト 3.3 ③の再構成メソッドに関しては、名前をつけて 専用のメソッドであることを示すのがよいでしょう。
39
第 3章エンティティ/値オブジェクト
3.2.4 生成メソッドには値オブジェクトを渡してもよい？
  生成メソッドには値オブジェクトで渡さなければいけませんか、プリミティブな値を 渡してもよいですか。  どちらでも大丈夫ですが、値オブジェクトを引数にした方が可読性が少し高まります。
2パターン、それぞれ実装を比較してみましょう。 ▼リスト 3.6 引数が値オブジェクトとプリミティブの比較
data class MailAddress(val value: String) { // バリデーションが実装されているとする
}
class User(val mailAddress: MailAddress) { companion object {
fun fromValueObject(mailAddress: MailAddress): User { // ① return User(mailAddress)
}
fun fromPrimitive(mailAddress: String): User { // ② return User(MailAddress(mailAddress))
} }
}
①が値オブジェクトを渡す生成メソッド、②はプリミティブな Stringを渡す生成メソッ ドです。 どちらが間違いというほどの違いはありませんが、①のように引数を値オブエジェクト にした方が、何が渡されるかが型で明確になり、メールアドレスとは関係ない文字列が来 ないことが明確になります。この点からは、値オブジェクトで渡した方が若干可読性が高 いと言えるでしょう。
なお、どちらのパターンでも、メールアドレスに関するバリデーションはMailAddress クラスに実装する必要があります。2つの観点から説明します。
1 つは責務の観点です。メールアドレスの書式のチェックは MailAddress クラスの責 務とする方が自然で、Userクラスに実装すると責務と関連が弱い実装がされることにな ります。これを繰り返すと Userクラスがどんどん低凝集になり、保守性が低下します。 もう 1 つは再利用性の観点です。MailAddress クラスは他のメールアドレスを保持す
40
3.3 エンティティが保持する値
るクラスでも再利用できますが、Userクラスにメールアドレスのバリデーションを書い てしまうと、バリデーションが他クラスで再利用できなくなってしまいます。
値オブジェクトの責務がきちんと考慮され、凝集度の高いオブジェクトになっていれ ば、それを組み立てるタイミングはあまり問題にならないことが多いです。ただし、メ ソッドの引数は値オブエジェクトにした方が少し可読性が高まるので、迷ったらそのよう にするとよいでしょう。
3.3 エンティティが保持する値 3.3.1 ORマッパーが自動生成するカラムの扱い
  ORマッパーが自動で生成する created_at(作成日時)や updated_at(更新日時)に ついて、画面表示に使ってもよいでしょうか？  画面表示に使用するのであればエンティティ/値オブジェクトに「作成日時」などの属
性を定義し、値の設定はクラス内のメソッドで制御しましょう。理由は 2つあります。 1つは、値を設定するタイミングの問題です。ORマッパーはリポジトリの実装クラス 内でのみ使用するので、エンティティ/値オブジェクトのインスタンスを生成してからリ ポジトリに渡すまでは ORマッパー側で設定できません。そのため、リポジトリに渡すま で一時的に作成日時/更新日時が null状態のインスタンスが存在することになりますが、 それは「常に正しいインスタンスしか存在させない」という方針*6に反します。 もう 1 つは、値の設定内容の問題です。特に更新日時は、OR マッパーが設定する日 時とドメイン層のロジックで意図する日時が異なることがあります。たとえば、ORマッ パーは更新処理が走ったら毎回更新する一方、ドメイン層のロジックとしては特定のカラ ムの更新は更新日判定に含めない、といったことが考えられます。ここをドメイン層のロ ジックにしたがって制御したい場合は、ドメイン層に自分で実装する必要があります。
*6 モデリング/実装ガイド「2.3 ドメイン層オブジェクト設計の基本方針」参照
41
第 3章エンティティ/値オブジェクト
3.3.2 楽観ロック用のバージョン情報はどう扱う？
  複数ユーザーからの同時更新を防ぐために、バージョンカラムを使用した楽観ロック を導入したいです。このバージョンは RDBの関心事と考えると、ドメイン層のエン ティティに入れるのは不自然なように思いました。ドメイン層の責務を守って楽観 ロックを実現するにはどうしたらよいでしょうか。  バージョン情報は、インフラ層でどのように排他制御を行うかという知識の一部なの で、それがドメイン層のクラスに実装されるのは厳密にはレイヤーの責務違反と言えま す。しかし、楽観ロックを実現するにはバージョン情報の保持が避けられないため、「責 務違反を許容するが最低限に抑える」という方針で考える必要があります。 実装方法は複数考えられますが、一例として「楽観ロック可能」を示すインターフェイ スにバージョン情報を持たせる実装を紹介します。まず、次のようなバージョンを保持す るインターフェイスと、バージョンを示すクラスを作成します。
▼リスト 3.7 楽観ロック可能インターフェイス実装
package dddfaq.domain.shared.lock
/** 楽観ロックが可能であることを示すインターフェイス */ interface OptimisticLockable {
val version: Version // ① }
/**楽観ロックに使用するバージョン情報 */ data class Version(val value: Int) {
companion object { /** 初期状態のバージョンを生成します */ fun initial(): Version { // ②
return Version(0) }
} }
①は楽観ロックに使用するバージョンを表す属性です。シンプルに Int型でも実現でき ますが、専用の型を用意することで意図が明確になります。また、②のように初期化処理 もメソッドで明示的に表現できます。 これらのインターフェイスとクラスはドメイン層に定義します。ドメイン層のクラスが
42
3.3 エンティティが保持する値
楽観ロックを意識する是非は議論の余地がありますが、ドメイン層には「楽観ロックでき ること」は表現されていてもその実現方法は実装されないので OK、という判断をしまし た。このあたりはまさに「責務違反を許容するが最低限に抑える」という観点で考慮する ポイントになります。 そして、このクラスを実装するエンティティは次のようになります。
▼リスト 3.8 楽観ロックを行うエンティティ
package dddfaq.domain.dog
class Dog private constructor( dogId: DogId, name: String, version: Version
) : OptimisticLockable { // ① val dogId: DogId = dogId var name: String = name
private set override val version: Version = version // ②
companion object { fun create(name: String): Dog {
return Dog( dogId = DogId(), name = name, version = Version.initial() // ③
) }
fun reconstruct( dogId: DogId, name: String, version: Version // ④
): Dog { return Dog(dogId, name, version)
} }
fun updateName(name: String) { this.name = name // ⑤
} }
①で OptimisticLockableの実装を宣言し、そこに定義されている version属性の保持 を②で定義します。③で新規 Dog生成時にバージョンの初期値を設定し、④で再構成時 に DBに保存されているバージョンの値を使用します。この属性が val(不変)で、インス タンス作成以降は変更不可であることがポイントです。⑤のように名前を更新するメソッ ドでは versionを更新することはありません。 このバージョン情報を用いて、更新時にリポジトリ実装クラス (インフラ層)内部で次 のようなクエリを実行することにより楽観ロックを実現します。
43
第 3章エンティティ/値オブジェクト
▼リスト 3.9 バージョン情報を使用した更新クエリ
UPDATE dogs SET
name = 'new_name', version = version + 1 // ①
WHERE dog_id = '01' and version = 1 // ②
②のように、エンティティが保持するバージョンで更新対象の絞り込みを行い、①で他 のカラムの更新と同時にバージョンをインクリメントします。すると、ほぼ同タイミング で後から実行されたリクエストでは①の条件を満たすレコードがなくなり、更新件数が 0 件になります。クエリ実行時、更新件数をもとに分岐し、0件だったら処理が失敗したと して例外を投げます。 このような実装をすれば、ドメイン層の責務違反の実装最小限に抑えつつ、楽観ロック を実現できます。
なお、このような場合にインターフェイスの代わりにエンティティの基底クラス (抽象 クラス) を定義し、そこにバージョン情報を持たせる選択肢もありますが、全てのエン ティティが楽観ロックに対応するとは限らないため、用途を名前で明示したインターフェ イスとしています。また、Kotlinの場合インターフェイスは複数実装できますが、抽象ク ラスだと 1つしか継承できないため、不要な制約がかからないようにインターフェイスに しています。
3.4 リポジトリからの取得 3.4.1 処理に使用しない値も取得する必要はある？
  エンティティに 5 つの属性があった時、あるエンドポイントの処理ではそのうち 2 つしか必要になりません。残りの 3つを DBから取得するのは無駄ではないでしょ うか。  DDDの実装パターンでは、DBアクセスの効率性を多少犠牲にし、保守性を高めるこ とを目指します。実装パターンの採用に関しては、このトレードオフを考慮して判断する 必要があります。
44
3.5 IDの扱い
具体例で説明します。オブジェクトに対応するテーブルので一部のカラムだけ更新する 場合は、SQL効率だけを考えれば UPDATE文 1回で実行できます。しかし、SQL実行 にあたって分岐やバリデーションが入ってくると、ドメイン知識 (ルール/制約)がドメイ ン層とインフラ層に散在して結合度が高まる、テスト時にインフラ層をモックしにくくな るといった問題が発生します。 それを避けるために、エンティティ/値オブジェクトのメソッドでドメイン知識に関す る実装を完結し、インフラ層ではシンプルな DBとの入出力だけに留めます。そうするこ とで、高凝集/低結合となり、可読性やテスト容易性が向上します。そして、これを実現 するために「一度リポジトリでエンティティ/値オブジェクトの値を全て取得してインス タンスを再構成し、更新されたインスタンスをリポジトリ経由で DBに反映する」という 手法をとります。 ここで大切なことは、「DB アクセス効率が下がる」というコストと「可読性やテスト 容易性を上げる」というリターンを考えた時に、リターンの方が大きいと考えられるかで す。そのように考えられる場合はこの方法を採用し、そうでない場合は目的にあった実装 を検討しましょう。
なお、「DBアクセス効率が下がる」ことが参照系処理で許容されない場合があります。 その場合はドメイン (更新用)モデルとは別にクエリ (参照用)のモデルを使用するという 手段があります。詳しくは本書「8.4 クエリモデル (軽量 CQRS)」、もしくはモデリング/ 実装ガイドの「第 8章 CQRS」をご覧ください。 また、更新系においても、バッチ処理などで大量な処理が必要な場合は、前述の保守性 を犠牲にしても処理効率を高める判断が必要になることはあります。その場合は保守性低 下の可能性を把握した上でクエリで一括更新をするなどの実装を行います。 参照、更新ともに、このような例外を適用する場合は、適用条件を言語化し、無基準に 濫用されることを防ぐとよいでしょう。
3.5 IDの扱い 3.5.1 DBのオートインクリメントの値を IDに使用してよい？
  エンティティの識別子に、DBのオートインクリメントの値を使用することは可能で しょうか。 
45
第 3章エンティティ/値オブジェクト
可能ですが、考慮事項がいくつかあります。 まず、実装方法を整理します。オートインクリメントの値を識別子として扱う方針は次 の 2通りが考えられます。
• 方針 1: リポジトリ内でエンティティを永続化する際に初めて採番する
• 方針 2: エンティティ生成前に DBで採番した値を取得し、エンティティに渡す
方針 1は、Active Record型の ORマッパーを使った時の挙動と近いため、そのような ORマッパーに慣れている人には馴染みやすい実装になります。しかし、リポジトリに渡 す前に一時的に ID が存在しないインスタンスができてしまうため、「常に正しいインス タンスしか存在させない」という方針*7に違反します。また、次のコードのように、本来 であれば nullableではない IDが、上記の理由で nullableな属性として定義せざるを得な くなります。
▼リスト 3.10 UserId が nullableになった場合の実装
val user = User(userName = "松岡")
val task = Task( name= "タスク1", userId = user.id // ① この実装ではIDはnullになってしまう
)
Task の引数が not null であると定義されていた場合、UserId が nullable だと①で Null チェックが必要になります。これでは不要な分岐を発生させ、保守性を下げてしま います。 以上の理由から、DBのオートインクリメントの値を使用するのであれば方針 2の実装 をおすすめします。
なお、IDの事前採番に関しては、DBのオートインクリメント以外に ULIDや UUID などのアルゴリズムの使用を検討してみてください。プログラムコードのみで採番できる ため、ID採番が DBに依存しなくなり、保守性が向上します。
*7 モデリング/実装ガイド「2.3 ドメイン層オブジェクト設計の基本方針」参照
46
3.5 IDの扱い
3.5.2 識別子に日付を使用してもよい？
  エンティティの識別子についての質問です。日付がユニークになるようなエンティ ティで、日付そのものを識別子に使ってもよいでしょうか？  問題ありません。エンティティの定義としては「一意な識別子」が必要なので、日付に よって一意になるのであればよいでしょう。
ID生成には複数の方法があり、それぞれメリットデメリットがあります。実践ドメイ ン駆動設計*8「第 5章 5.2 一意な識別子」で ID生成方法について詳しく紹介されている ので、そちらも参考にしてみてください。
*8 <https://www.amazon.co.jp/dp/479813161X/>
47
第 4章
リポジトリ
本章では、リポジトリに関する頻出の質問に対して、具体的なコードを示しながら解説 します。
4.1 リポジトリでやってよいこと、わるいこと 4.1.1 リポジトリで集約の一部のみアップデートしてもよい？
  エンティティの一部だけを更新するメソッドをリポジトリに定義してもよいでしょ うか。  推奨しません。一部の値を更新する際にバリデーションや分岐があった場合、ドメイン 層の知識がインフラ層に漏れ出てしまうことになります。 更新のロジックはドメイン層のオブジェクトに寄せ、リポジトリは DBへの書き込み処
理のみを実装しましょう。するとドメイン層とインフラ層が高凝集/低結合になり、可読 性やテスト容易性が高まります。
4.1.2 リポジトリに件数チェックメソッドを書いてもよい？
  リポジトリに件数を取得するメソッド、存在をチェックするメソッドを定義してもよ いでしょうか？ 
48
4.1 リポジトリでやってよいこと、わるいこと
問題ありません。リポジトリはエンティティ/値オブジェクトの集合を表すオブジェク トであり、件数や存在チェックなど集合に関する情報を返すメソッドは責務として矛盾が ないと考えられます。 存在チェックはエンティティを返すメソッドや件数取得メソッドでも代用できますが、
Booleanを返すメソッドを別途用意してもよいでしょう。
4.1.3 リポジトリでソート順を指定してもよい？
  リポジトリを通じた値の取得結果をソートするにはどうしたらよいでしょうか？  リポジトリの引数に「並び替えに使用する条件」を表す enumを渡すのがよいでしょう。
▼リスト 4.1 リポジトリでのソート
package dddfaq.domain.user
enum class UserOrderKey { NAME, USER_ID
}
interface UserRepository { fun findByStatus(status: UserStatus, userOrderKey: UserOrderKey): List<User>
}
ここで、OrderKey はドメイン層が持つ知識として問題ないのか、という疑問が生じ ます。
OrderKeyが示すものが RDBのテーブル定義されているカラム名だとすると、ドメイ ン層にインフラ層の知識を持つことになるので問題があります。しかし、「ユーザーエン ティティの名前で並び替えて」「IDで並び替えて」というように、ドメイン層にある情報 のみで表現されていれば問題ありません。「ソートをどのように実現するか (SQLであれ ば ORDER BY句を使用する)」がドメイン層に漏れ出ていなければよいのです。
OrderKeyを受け取ったリポジトリがソートを実現するには、次のように実装します。 ORマッパーには jOOQ*1を使用しています。
*1 Java製の ORマッパー、Kotlinからも使用可能。 <https://www.jooq.org/>
49
第 4章リポジトリ
▼リスト 4.2 引数でソート順を指定するリポジトリメソッド
package dddfaq.infra.repository
class UserJooqRepository{ override fun findByStatus(
status: UserStatus, userOrderKey: UserOrderKey
): List<User> { val orderColumn = buildOrderColumn(userOrderKey) // ① return jooq.selectFrom(USERS)
.where(USERS.STATUS.eq(status.name))
.orderBy(orderColumn) // ②
.fetch()
.map { userRecord -> // Recordからエンティティに詰め替え User.reconstruct(
id = UserId(userRecord.userId), name = userRecord.name
) }
}
private fun buildOrderColumn(userOrderKey: UserOrderKey): SortField<String> { return when (userOrderKey) { // ③
UserOrderKey.USER_ID -> USERS.USER_ID.asc() UserOrderKey.ROLE -> USERS.ROLE.asc()
} }
}
①で buildOrderColumnメソッドを使用して UserOrderKeyを② orderByに渡すカラ ム情報に変換することにより、指定した順序でのソートを実現します。 ③は Kotlin の文法で、when に渡す値で分岐した処理を記述できます。他の言語では
Switch というキーワードで定義されていることがあります。Kotlin では、③のように whenの条件に使用されている値が enumの場合、分岐に全ての区分値を実装しないとコ ンパイルエラーになるため、enumに新たな区分値を追加した際に実装漏れが発生するこ とを防げます。
4.1.4 リポジトリでページングしてもよい？
  リポジトリにおいて取得結果をページングするにはどうしたらよいでしょうか？  リポジトリメソッドの戻り値を、ページを表すオブジェクトでラップして返します。
50
4.1 リポジトリでやってよいこと、わるいこと
▼リスト 4.3 ページオブジェクト
package dddfaq.domain.shared.page
data class Page<T>( /**取得したエンティティ */ val items: List<T>,
/** ページング情報 */ val paging: Paging,
)
data class Paging( /**指定した条件に該当する全件数 */ val totalCount: Int,
/** 1ページ当たりの件数 */ val pageSize: Int,
/**取得結果のページ番号 */ val pageNumber: Int,
)
リクエストには次のようなオブジェクトを使用します。
▼リスト 4.4 ページング条件を表すオブジェクト
package dddfaq.domain.shared.page
data class PagingCondition( val pageSize: Int, val pageNumber: Int,
)
interface UserRepository { fun fetchPageByName(name: String, pagingCondition: PagingCondition): Page<User>
}
実際のページング処理は、インフラ層のリポジトリ実装クラスでライブラリに合わせた 方法で実装します。 ページ情報はドメイン層に定義してよいのか？ という疑問が生まれますが、ページと いうのは、「集合の一部を、関連する件数情報とあわせて返したもの」という抽象的な概 念のため、「リポジトリがその集合の一部をページとして返す」ことは責務として問題な いと考えられます。重要なのはページング処理を実際にどのように実現するかをインフラ 層に隠蔽することです。
51
第 4章リポジトリ
4.1.5 複数エンティティを一括更新してもよい？
  リポジトリに、複数のエンティティをまとめて更新するメソッドを設けてもよいで しょうか？  問題ありません。次のように、単一エンティティを処理するメソッドとは別に、複数エ ンティティをまとめて更新するメソッドを設けることができます。
▼リスト 4.5 一括更新メソッド
interface UserRepository { fun insert(user: User) // ① 1エンティティのみインサート fun insert(users: Set<User>) // ② 複数エンティティ同時にインサート
}
こうすることにより、②の実装クラスのメソッドの中で一括処理パフォーマンスを最適 化できます (RDBであれば、バッチインサートを行うなど)。 ①のメソッドをユースケースから複数回呼ぶ実装でパフォーマンスに問題がある場合 は、②のメソッドの作成を検討します。実装の複雑度が少し上がり、必要なテストが増え るため、パフォーマンスに問題がなければ必ずしも作成する必要はありません。
4.1.6 リポジトリで悲観ロックをかけてもよい？
  リポジトリで、DBに対して悲観ロックを取得してもよいでしょうか？ その場合、ド メイン層のインターフェイスにはどう表現するとよいでしょうか？  ドメイン層の表現が特定の技術に依存したものになっていなければ、問題ないと考えま す。例として、次のような実装です。
52
4.1 リポジトリでやってよいこと、わるいこと
▼リスト 4.6 排他制御を引数で指定する
interface UserRepository { fun findByUserId(
userId: UserId, exclusiveAccess: Boolean // ①
): User? }
①でリポジトリに対して「排他的なアクセスをする」ということを示すパラメーターを 渡します。このパラメーターの名前を「ロックを取る」といった特定のデータソースを意 識した用語ではなく、「リポジトリ内の要素に対する排他的なアクセス」という抽象的な 用語を選ぶことで、ドメイン層に定義してもよいと解釈しています。 そして、ユースケースの入り口でトランザクションを開始し、インフラ層のリポジトリ 実装クラスの中で、select for updateなどの記述*2でロックを取得します。これにより、 同タイミングで同じリソースにアクセスが来た場合、先に始まった処理のトランザクショ ンが完了するまで後続処理では findByUserIdメソッドから値が返されなくなり、排他制 御が実現できます。 なお、この実装はメソッド自体を分けても構いません。その場合は「findByUserIdEx-
clusively」といったメソッド名で排他的アクセスをすることを明示します。
4.1.7 insertと updateのメソッドを一緒にしてもよい？
  insertと updateの両方を行える、saveや upsertといったメソッドを作成してもよ いでしょうか。  問題ありません。ただし、メリットデメリットを考慮して使い所は検討しましょう。 メリットとしては、呼び元のユースケースで新規保存か更新かを意識しないで使える ようになることです。一方、デメリットとしてはリポジトリのメソッドの中で「insertか updateか」を判断し処理を分岐するため、実装が複雑になることです。凝集度の観点か らすると、責務が 2つになり低凝集になると説明できます。 ユースケースの段階で新規保存か更新が分かれていることは多く、そのような場合はデ メリットがメリットを上回ります。本当に 1つのメソッドにする必要があるかは検討し、
*2 記述方法は RDBMSに依存します
53
第 4章リポジトリ
必要なところだけ統合するのがよいでしょう。
4.2 実装上の注意点 4.2.1 集約の子オブジェクトをどうやって更新する？
  集約ルートが子オブジェクトを複数持っている場合、リポジトリの updateメソッド で子オブジェクトをどのように更新すればよいでしょうか？  たとえば、Userエンティティが集約ルート*3で、集約内の子オブジェクトとして追加/
削除可能な複数の MailAddress を持っているような場合ですね。次のようなコードで、 usersテーブルと、email_addressesテーブルに永続化しているとします。
▼リスト 4.7 ユーザーエンティティとリポジトリ
data class MailAddress(val value :String)
class User( val name: String, val mailAddresses: Set<MailAddress>
){ // メールアドレスの追加メソッド、削除メソッドを持つものとする
}
interface UserRepository { fun insert(user: User) fun update(user: User) // ①
}
User エンティティが集約ルートなので、① update メソッドには複数の MailAddress を子オブジェクトとして保持した Userインスタンスを渡します。ここで、子オブジェク トのMailAddressは新規保存するのか、更新するのか、削除するのか、どのように判断す ればよいでしょうか。 一番簡単な方法は、一度該当 Userに紐づく email_addressesテーブルのデータを削除 して、Userエンティティが保持していたmailAddressesを全てインサートする実装です。 シンプルで、バグを生みにくいというメリットがありますが、他のテーブルから外部キー 参照されていたり、create_atといった自動設定カラムの値を保持する必要がある場合は
*3 リポジトリに出し入れする際に親オブジェクトとなるエンティティ。集約に対して必ず 1つ定めます。
54
4.2 実装上の注意点
この手段が取れません。 もう 1つの方法は、リポジトリの中で email_addressesテーブルのデータを取得し、リ
ポジトリに渡されたmailAddressesと比較して「新規保存する値・更新する値・削除する 値」を分岐する方法です。実装が複雑になりますが、1つ目の方法が取れない場合は避け られません。テストをしっかり書いて動作を保証しましょう。
4.2.2 リポジトリはどの層に定義すべき？
  リポジトリのインターフェイスはドメインモデルを使う側なので、ユースケース層に 定義するべきではないでしょうか？  ドメイン層に定義するべきです。なぜなら、リポジトリが集約の範囲をコードで表現す る唯一のものだからです。 ユースケース層にリポジトリを定義してしまうと、集約の範囲に関する情報がドメイン 層になくなります。そして、ユースケース層で 1つのエンティティに対して複数リポジト リが作られ、それらが定義する集約の範囲が異なっていても、ドメイン層としては検知で きなくなってしまいます。 集約の範囲はドメイン層の重要な知識なので、それを表現するリポジトリもドメイン層 に定義する必要があります。
4.2.3 ファイルや外部サービスにデータを保存する処理
  ファイルを保存したり、外部サービスにデータ登録するようなオブジェクトも、リポ ジトリという名称で揃えた方がよいでしょうか？  性質が異なるものには、個別の名前をつけた方がよいでしょう。 特に、もし他のリポジトリがロールバック可能な場合、ロールバック可否はユースケー スで意識する必要がある重要な性質です (明示されていなくても、ユースケースの入り口 でトランザクションをかけていればどこの処理がロールバックできるか意識していること になります)。同じ「永続化である」としてロールバック可否まで隠蔽してしまうと、ロー
55
第 4章リポジトリ
ルバック発生時に想定外の挙動になり、データ不整合が発生する原因になります。 そういった性質のものに関しては、リポジトリとは異なる名前をつけ、すぐに区別がつく ようにした方がよいでしょう。例として、ファイル保存するオブジェクトは XxxStorage、 外部サービスにリクエストするオブジェクトは XxxClientといった名称が考えられます。 なお、他のリポジトリがロールバック不可で、意識するべき性質に違いがない場合は、 同じような名前に揃えてもよいでしょう。
56
第 5章
集約
本章では、集約の実装について解説します。集約とは、必ずひとまとまりで永続化す る、強い整合性を持ったエンティティ/値オブジェクトの単位です。 集約の定義に関する詳細な解説は、モデリング/実装ガイドの「第 3章 DDD 固有のモ デリング手法 3.1 集約」もご参照ください。本章ではより具体的な実装について解説し ます。
5.1 [解説]複数集約の整合性を確保する方法 集約を実装する上で難しいのは、複数集約にまたがった整合性を確保する方法です。そ の方法について、本節では具体的なコードを交えて解説します。
5.1.1 題材とする事例 複数集約間の整合性確保が必要な例として、次のようなものを考えます。 とあるタスク管理アプリケーションで、タスクを作成したら「{タスク名}が作成されま
した」という活動履歴を作成することになりました。履歴に漏れがあると困るため、タス ク作成時には確実に活動履歴が作成されるようにしたいです。つまり、タスク集約と活動 履歴集約、という 2つの集約間に確保したい整合性があるということです。このような場 合、どう実装すればよいでしょうか。 なお、活動履歴はタスク以外のオブジェクトに関連したものも生成されるため、タス クとは集約を分けるという設計判断をしたものとします。ドメインモデル図は次の通り です。
57
第 5章集約
▲図 5.1 複数集約ドメインモデル図
実装方法は、主に次の 3つに分かれます。

1. ユースケースで複数集約に更新をかける 2. ドメインサービスを使用する 3. ドメインイベントを使用する
1つずつ解説します。
5.1.2 実装方法 1. ユースケースで複数集約を更新する 一番シンプルな実装は、ユースケースで複数集約のインスタンスを生成し、それぞれを リポジトリに渡す方法です。まずはドメイン層のコードは次のようになります。
▼リスト 5.1 タスク集約のエンティティとリポジトリ
package dddfaq.domain.task
/** タスク */ class Task(
val taskName: String )
interface TaskRepository{ fun insert(task: Task)
}
58
5.1 [解説]複数集約の整合性を確保する方法
▼リスト 5.2 活動履歴集約のエンティティとリポジトリ
package dddfaq.domain.activityhistory
/**活動履歴 */ class ActivityHistory private constructor(val detail: String) {
companion object { fun createFromTask(task: Task): ActivityHistory {
return ActivityHistory("${task.taskName}が作成されました")) }
} }
interface ActivityHistoryRepository{ fun insert(activityHistory: ActivityHistory)
}
このクラスを使用するユースケースは次のようになります。
▼リスト 5.3 2 つの集約を更新するユースケース
package dddfaq.usecase.task
class CreateTaskUseCase( private val taskRepository: TaskRepository, private val activityHistoryRepository: ActivityHistoryRepository,
) { @Transactional fun execute(taskName: String) {
// Taskの作成と保存 val task = Task(taskName) taskRepository.insert(task)
// 生成したTaskを使用してActivityHistoryを作成し、保存 val activityHistory = ActivityHistory.createFromTask(task) activityHistoryRepository.insert(activityHistory)
} }
ユースケースの記述で 2 つの集約の整合性が確保されています。シンプルに実装でき るというメリットがあるため、DDD導入初期にはまずこの方法が採用されることが多い です。 しかし、デメリットがあります。次のように、別のユースケースでうっかりと集約間の 整合性を破壊してしまうことが可能だということです。
59
第 5章集約
▼リスト 5.4 活動履歴の作成を忘れてしまったユースケース
class CreateWrongTaskUseCase(private val taskRepository: TaskRepository) { @Transactional fun execute(taskName: String) {
val task = Task(taskName) taskRepository.insert(task) // うっかりActivityHistory作成を忘れてしまった
} }
また、「タスクが作成されたら活動履歴も作成される」ということはドメイン層の知識 として重要なのに、その知識がドメイン層に書かれておらず、ドメイン層のコードを読ん でも認識できないという問題もあります。
5.1.3 実装方法 2. ドメインサービスを使用する 実装方法 1のデメリットに対する改善案が、ドメインサービスを使用する方法です。 まず、ユースケースは次のように変わります。
▼リスト 5.5 ドメインサービスを使用するユースケース
package dddfaq.usecase.task
class CreateTaskUseCase( private val taskCreator: TaskCreator
) { @Transactional fun execute(taskName: String) {
taskCreator.create(taskName) }
}
TaskCreatorはドメインサービスです。「サービス」という文言をクラス名につけがち ですが、責務が不明確になるので非推奨で、責務にあった名称をつけることをおすすめし ます。詳細は「6.1.1 ドメインサービスの命名」を参照してください。 ユースケースからはドメインサービスを呼ぶだけになり、2つの集約間の整合性を確保 する責務はそちらに委譲します。 ▼リスト 5.6 2 つの集約を更新するドメインサービス
package dddfaq.domain.task
class TaskCreator( private val taskRepository: TaskRepository, private val activityHistoryRepository: ActivityHistoryRepository
60
5.1 [解説]複数集約の整合性を確保する方法
) { fun create(taskName: String) {
val task = Task(taskName) taskRepository.insert(task)
val activityHistory = ActivityHistory.createFromTask(task) activityHistoryRepository.insert(task)
} }
ひとまず集約間の整合性の知識をドメイン層に委譲できました。しかし、まだ問題があ ります。これでも他のユースケースで整合性を破壊することを防げないのです。
▼リスト 5.7 ドメインサービスを呼ばず活動履歴の作成を忘れてしまったユースケース
class CreateWrongTaskUseCase(private val taskRepository: TaskRepository) { @Transactional fun execute(taskName: String) {
val task = Task(taskName) taskRepository.insert(task) // TaskCreatorの存在を知らず、 // 再度うっかりActivityHistoryをし忘れてしまった
} }
これを防ぐために 1つ工夫をします。 なお、この実装は Kotlinの言語仕様に依存した実装になっているため、異なる言語で
は必要に応じてカスタマイズしてください。
まず、Taskエンティティの実装は次の通りです。
▼リスト 5.8 create の引数がパラメーターオブジェクトになったタスクエンティティ
class Task private constructor(val taskName: String) { companion object {
fun create( param: TaskCreateParameter // ①
): Task { return Task(param.taskName)
} }
}
① create メソッドの引数が TaskCreateParameter に変わりました。これは何でしょ うか。ドメインサービスを見てみます。
61
第 5章集約
▼リスト 5.9 TaskCreator.kt
package dddfaq.domain.task.creator
/** *Task.createメソッドの呼び出しを* TaskCreatorからのみに制限するためのインターフェイス */
sealed interface TaskCreateParameter( // ① val taskName: String
)
/**TaskCreateParameterの実装クラス*/ private data class TaskCreateParameterImpl : TaskCreateParameter { // ②
override taskName: String }
class TaskCreator( private val taskRepository: TaskRepository, private val activityHistoryRepository: ActivityHistoryRepository
) { fun create(taskName: String) {
val task = Task.create(TaskCreateParameterImpl(taskName)) // ③ taskRepository.insert(task)
val activityHistory = ActivityHistory(task) activityHistoryRepository.insert(task)
} }
この実装は、TaskCreator.kt というファイルに実装されているものとします。①の TaskCreateParameterはリスト 5.8① Taskクラスの createメソッドの引数になってい るインターフェイスで、②にその実装クラスが定義されています。このクラスを使用し て、③のように createメソッドに値を渡しています。 ここで重要なのは、①のインターフェイスと②のクラスの可視性を制御している点で す。Kotlinの文法では、①のようにインターフェイスの可視性を sealedにすると、同じ パッケージ内でしか実装クラスを作成できなくなります。また、②のようにクラスの可視 性を privateにすると、そのクラスを同じファイル内でしか参照できなくなります。これ により、TaskCreator.kt とは別のパッケージ、別のファイルで次のような実装をすると コンパイルエラーになるのです。
▼リスト 5.10 CreateWrongTaskUseCase.kt
package dddfaq.usecase.task
data class UseCaseTaskCreateParameter: TaskCreateParameter { // ① override taskName: String
}
62
5.1 [解説]複数集約の整合性を確保する方法
class CreateWrongTaskUseCase() { @Transactional fun execute(taskName: String) {
val task = Task(TaskCreateParameterImpl(taskName)) // ② taskRepository.insert(task)
} }
①は TaskCreateParameter を dddfaq.domain.task.creator パッケージ外で実装しよ うとしたため、②は TaskCreateParameterImplを TaskCreator.kt外で参照しようとし たため、それぞれコンパイルエラーになります。 これを組み合わせることにより、「Task.createメソッドを絶対に TaskCreator以外か ら呼べない」という制約がかかりました。すると、TaskCreatorでは活動履歴を必ずセッ トで作成するため、「絶対にタスクと活動履歴がセットで作られる」という制約をかける ことができたのです。 これにより、実装方法 1のデメリット「集約間の整合性の知識がユースケースに漏れ出 ている」「うっかり集約間の整合性を破壊できる」という点を克服できました。
実装方法 2のデメリットは、ドメイン層の「サービス」の濫用を招き、ファットなドメ インサービス、ドメインモデル貧血症 (ドメインロジックを持たない)なエンティティ/値 オブジェクトを誘発する可能性があることです。ドメインサービスは手続き的な記述にな りがちなため、つい DDD導入以前の書き方に戻ってしまうきっかけになるのです。 この対策は 2つあります。1つは、ドメインサービスの採用は最小限にし、どうしても 必要な時だけにすることです。採用する際にも、ドメインサービスが持つ責務は最小限に なるように意識しましょう。 もう 1つは、ドメインサービスに「サービス」という名前をつけず、責務を反映した名 前にすることです。今回の例では、TaskDomainServiceではなく、TaskCreatorという 名前を使用しています。これにより、このクラスにさまざまなメソッドが追加されて低凝 集なクラスになることを防ぎます。
5.1.4 実装方法 3. ドメインイベントを使用する 3つ目の方法では、ドメインイベントを使用します。 まず、ドメインモデル図にドメインイベントを表現します。
63
第 5章集約
▲図 5.2 ドメインイベントを表現したドメインモデル図
活動履歴がタスク自体に依存するのではなく、タスク作成イベントに依存する形に変わ り、よりオブジェクト同士の関係性が明確になりました。
これを実装でも表現していきます。全体の流れは次の 3ステップになります。
1. エンティティの特定の処理のタイミングでドメインイベントを作成し、エンティ ティ内に蓄積する
2. リポジトリの insert/updateが成功後、イベントを発行 (publish)する 3. 発行されたイベントをイベントリスナーの仕組みで拾い、他集約の処理を実施する
2,3 のイベント発行とそれを拾う仕組みはフレームワークに依存した実装になります。 本書では Java のフレームワーク Spring の仕組みを使って実装したサンプルを示します が、他のフレームワークに適用する際には適宜カスタマイズしてください。
まず、ユースケースの実装から見ていきます。
▼リスト 5.11 ドメインイベントを作成・発行するユースケース
64
5.1 [解説]複数集約の整合性を確保する方法
package dddfaq.usecase.task
class CreateTaskUseCase( private val taskRepository: TaskRepository, private val domainEventPublisher: DomainEventPublisher
) { @Transactional fun execute(taskName: String) {
val task = Task.create(taskName) // ① taskRepository.insert(task, domainEventPublisher) // ②
} }
▼リスト 5.12 ドメインイベントを発行するオブジェクトのインターフェイス
package dddfaq.domain.shared.event
interface DomainEventPublisher { fun publish(event: DomainEvent)
}
この処理の中で、①エンティティ内に TaskCreatedEventが作成、蓄積され、② insert 成功時に TaskCreatedEvent が発行される仕組みです。ここで特徴的なのが、②で Do-mainEventPublisherをリポジトリに渡している点ですね。これをどのように使用してい るかは、インフラ層の実装で解説します。 発行された TaskCreatedEventは次のようなイベントリスナーで拾われます。
▼リスト 5.13 TaskCreatedEventが発行されたら呼び出されるクラス
package dddfaq.domain.activityhistory
class ActivityHistoryEventListener( private val activityHistoryRepository: ActivityHistoryRepository
) { @EventListener // ① internal fun createActivityHistory(event: TaskCreatedEvent) { // ②
// ③ 受け取ったイベントをもとに活動履歴を作成し、保存 val activityHistory = ActivityHistory.fromTaskCreatedEvent(event) // ④ activityHistoryRepository.insert(activityHistory)
} }
Springの仕組みを利用し、①のように@EventListenerアノテーションを付与し、②で 拾うイベントのクラスを引数で定義すると、そのイベントが発行された時にこのメソッド が呼ばれるようになります。このメソッド内で受け取った TaskCreatedEvent をもとに ③で活動履歴を作成、保存します。イベント同士の関係を表すために、ここだけはドメイ
65
第 5章集約
ン層ですが Springのアノテーションへの依存を許容しています。
ドメインイベントを使用した実装のメリットは主に 3つあります。
1. 集約同士の整合性がドメイン層で確実に保証できること 2. ユースケース、イベントリスナーの実装がシンプルになること 3. 集約同士の関係がイベントを通じて明示的になること
1 については、今回の実装をするとタスク作成時には必ず ActivityHistoryEventLis-tener経由で活動履歴が作成されるため、ユースケース層で絶対に整合性を破壊できなく なっています。
2については、イベント関連の仕組みを導入する際のハードルはありますが、導入以降 の個別の実装はドメインサービスのパラメーターで可視性制御をする場合よりもシンプル にできます。
3 については、リスト 5.2 の ActivityHistory ではインスタンスを Task から生成して いしましたが、リスト 5.13の④では TaskCreatedEventから生成するようになりました。 これにより、ActivityHistoryが何をもとに生成されるかがより明確になりました。Task が引数のままだと、Taskが延期された時、Task名が変更された時、といったパターンが 増えた時に引数の Taskクラスだけで違いを表現するのが難しくなります。 一方、導入時に若干複雑な実装が必要になること、ドメインイベントの概念の説明が必 要になることが、これまでに紹介した実装方法に比べた時のデメリットです。
全体像を把握できたところで、ドメインイベントの生成と発行処理を追っていきます。 まず、ドメインイベントの基底インターフェイスは次のようになります。
▼リスト 5.14 ドメインイベント
package dddfaq.domain.shared.event
/**ドメインイベントの基底インターフェイス */ interface DomainEvent
個別のドメインイベントは次のように、DomainEventを実装したクラスとして定義し、 イベントごとに必要な属性を定義します。
66
5.1 [解説]複数集約の整合性を確保する方法
▼リスト 5.15 タスク作成イベント
package dddfaq.domain.task
/**タスクが作成されたことを示すイベント */ class TaskCreatedEvent(val taskName: String) : DomainEvent
TaskCreatedEventでは、履歴に必要なタスク名を保持します。これは Taskエンティ ティと同じパッケージに定義します。
ドメインイベントを作成するクラスは、次の基底クラスを継承します。
▼リスト 5.16 ドメインイベントを蓄積する基底クラス
package dddfaq.domain.shared.event
/** ドメインイベントを蓄積可能であることを示す基底クラス */ abstract class DomainEventStorable { // ①
private val domainEvents: MutableList<DomainEvent> = mutableListOf() // ②
protected fun addDomainEvent(domainEvent: DomainEvent) { // ③ this.domainEvents.add(domainEvent)
}
fun getDomainEvents(): List<DomainEvent> { // ④ return this.domainEvents
}
fun clearDomainEvents() { this.domainEvents.clear()
} }
①はドメインイベントを蓄積可能であることを表す基底クラスで、②空のリストで初期 化している MutableList にドメインイベントを蓄積します。③はドメインイベントを追 加するメソッドですが、継承先のクラスからしか呼べないように可視性を protectedにし ています。④では、MutableListのまま domainEventsを返してしまうとエンティティの 外から domainEventsに任意の値を直接設定できてしまうので、戻り値の型はイミュータ ブルな List型として定義しています。 これを継承し、実際にドメインイベントを作成するエンティティは次のようになります。
67
第 5章集約
▼リスト 5.17 ドメインイベントを作成するエンティティ
package dddfaq.domain.task
class Task private constructor( val taskName: String
) : DomainEventStorable() { // ① companion object {
fun create(taskName: String): Task { val task = Task(taskName = taskName) task.addDomainEvent(TaskCreatedEvent(taskName)) // ② return task
} }
}
interface TaskRepository { fun insert(task: Task, domainEventPublisher: DomainEventPublisher)
}
リスト 5.16 の基底クラスを、①で Task クラスが継承しています。こうすることによ り、②のようにクラス内の処理で TaskCreatedEventを親クラスに蓄積できます。このタ イミングではイベントは発行されず、蓄積されるのみです。 なお、リスト 5.16①の基底クラスを「AggregateRoot」のように全ての集約ルートと なるエンティティの基底クラスとする選択肢もありますが、全ての集約ルートでドメイン イベントが必要になるわけではないので、ここでは用途を限定したクラスとして定義して います。
蓄積されたドメインイベントを発行するのはインフラ層のリポジトリの実装クラスで、 次のようなコードになります。 ▼リスト 5.18 タスクリポジトリの実装クラス
package dddfaq.infra.repository
class TaskJooqRepository( private val jooq: DSLContext // ORマッパーのDBアクセス用インスタンス ①
) : TaskRepository {
override fun insert( task: Task, domainEventPublisher: DomainEventPublisher // ②
) { // DBにインサートする処理をここに実装する // jooq.insertInto(TASKS) // :
// イベントを発行 task.getDomainEvents().forEach {
68
5.1 [解説]複数集約の整合性を確保する方法
event -> domainEventPublisher.publish(event) } // ③ task.clearDomainEvents() // ④
} }
②で引数に渡された DomainEventPublisher を使って、③でイベントを発行してい ます。forEach を使用した場合、getDomainEvents の戻り値が 0 件の場合は Domain-EventPublisherを呼ぶ回数は 0回になります。発行したイベントは、④のようにクリア しておくと安全です。 なお、ここで DomainEventPublisherは insertメソッドの引数で渡していますが、こ れは insert実行時にドメインイベントが発行されうる、ということを明示するためです。 リポジトリにエンティティ以外を渡すという例外的な設計ですが、ドメインイベントは暗 黙的に動作させると挙動が追いにくくなるため、ここではあえてそのような設計にしてい ます。別の選択肢として、①のように DIしても構いません。
DomainEventPublisherの実装クラスは、次の通りになります。
▼リスト 5.19 イベント発行オブジェクトの実装クラス
package dddfaq.inrfa.event
class SpringDomainEventPublisher( private val applicationEventPublisher: ApplicationEventPublisher // ①
) : DomainEventPublisher {
override fun publish(event: DomainEvent) { applicationEventPublisher.publishEvent(event) // ②
} }
① Springが提供するApplicationEventPublisherをDIし、② publishメソッド内でイ ベントを発行します。発行されたイベントは、リスト 5.13の ActivityHistoryEventLis-tenerで拾われます。 これで、一通りの実装は完了です。
ドメインイベント作成に制約をつける この実装の問題として、「ユースケースの記述を見て、ドメインイベントがどこで作成 されているかが読み解けない」というものがあります。 そこで、ここでもうひと工夫を入れてみます。ユースケースの実装を次のように変更し ます。
69
第 5章集約
▼リスト 5.20 ドメインイベントの作成を明示的にしたユースケース
class CreateTaskUseCase( private val taskRepository: TaskRepository, private val domainEventPublisher: DomainEventPublisher, private val domainEventSeedFactory: DomainEventSeedFactory
) { @Transactional fun execute(taskName: String) {
val seed: DomainEventSeed = domainEventSeedFactory.createSeed() // ① val task = Task.create(taskName, seed) // ② taskRepository.insert(task, domainEventPublisher)
} }
DomainEventSeedというものを定義し、②のように「中でドメインイベントを作成す るメソッドには必ず DomainEventSeed を渡さなければいけない」という制約をかけま す。こうすることで、「DomainEventSeed が渡されているということは、中でドメイン イベントが作成され、他の集約に影響があるんだな」と読み解けるようになります。どの 集約に影響があるかは、メソッド内で作成されているドメインイベントから参照を追って いけば把握できます。
DomainEventの実装は次のようになります。
▼リスト 5.21 ドメインイベントの基底クラス
abstract class DomainEvent( seed: DomainEventSeed // ①
)
① DomainEvent を作成する際に引数で DomainEventSeed のインスタンスを渡すよ うにします。これは DomainEvent内の処理で必要なわけではなく、DomainEventSeed を渡さないとインスタンスを生成できないという制約をかけるためです。
TaskCreatedEventは次のようになります。
▼リスト 5.22 タスク作成イベント
class TaskCreatedEvent( val taskName: String, seed: DomainEventSeed // ①
) : DomainEvent(seed) // ②
①引数で DomainEventSeed を受け取って親クラスの DomainEvent のコンストラク タに渡します。Kotlin の文法では、①のように val がついていない値は、コンストラ クタには渡されますが TaskCreatedEvent クラスの属性として保持せず、②親クラスの
70
5.1 [解説]複数集約の整合性を確保する方法
DomainEventに渡されるのみになります。 DomainEventSeed は、次のように DomainEventSeedFactoryを経由しないと取得で きないように制約をかけます。
▼リスト 5.23 DomainEventSeedFactory.kt
package dddfaq.domain.shared.event.seed
sealed interface DomainEventSeed // ①
private class DomainEventSeedImpl() : DomainEventSeed // ②
class DomainEventSeedFactory { fun createSeed(): DomainEventSeed {
return DomainEventSeedImpl() }
}
①でインターフェイスの可視性を sealedにすることで、DomainEventSeedを実装する クラスをこのパッケージ以外で定義できなくなります。また、② DomainEventSeedImpl の可視性を private にしているので、このファイル以外から参照できなくなっていま す。この 2つの可視性制御により、DomainEventSeedインスタンスが必要な場合は必ず DomainEventSeedFactory経由で取得する、という制約を加えられました。 このような制御を入れることで、ユースケースの記述をシンプルに保ちつつ、「他の集 約の処理が発生する」ことを示せるようになります。
なお、テストクラスで DomainEventSeedインスタンスが必要になる場合は、Domain-EventSeedFactoryを経由せず、モックライブラリで DomainEventSeedのモックインス タンスを作ることで代用できます。
5.1.5 どの実装方法を選択すればよいか 複数集約間の整合性を確保する実装方法を 3つ紹介しました。 この 3つはどれが正解ということはなく、実装コストと整合性を守る重要性のバランス を考えてどれを採用するか決定します。バランスを考慮した結果、1つのプロジェクトの 中で複数の実装方法が混在しても問題ありません。
なお、この節の実装は同期的に処理を行う前提で作られています。非同期処理する場 合は、ロールバックが効かないため例外発生時の対応などの検討事項が増えますが、パ フォーマンス向上などの観点から選択されることがあります。応用的な内容になるため、
71
第 5章集約
本書では取り扱いません。
5.2 集約の取り扱い 5.2.1 複数集約を 1トランザクションで更新してよい？
  DDDでは 1トランザクションで 1集約しか更新してはいけないという記述をみたこ とがあります。実際には 1 つの処理の中で複数集約を更新したいこともあるのです が、これはよくないことでしょうか？  1トランザクションにおける複数集約更新に関しては賛否両論がありますが、メリット デメリットを考慮した上で判断できれば問題ないと考えています。筆者は普段は許可する 方針で開発しており、十分に実践的です。
1トランザクションで複数集約更新するデメリットは「トランザクションをかける範囲 が大きくなり、ロック取得や排他エラーにする範囲が大きくなりすぎる場合がある」こと です。一方メリットは途中で例外が発生した場合ロールバックができることです。この 2 つの考慮した結果、メリットの方が大きいと判断すれば、1トランザクションでの複数集 約を許容しています。 一方、「集約の範囲が適切か？」という観点での検討は常に必要です。ほとんどのユー スケースで同時に更新する 2 つの集約があった場合、それは同じ集約とするべき可能性 があります。その場合、集約の範囲を再定義し、それに従ってリファクタリングしていき ます。
5.3 集約の設計 5.3.1 集約の範囲の判断基準は？
  集約の範囲はどのように判断すればよいでしょうか？  具体的な題材を元に考えます。次の図のように、「学校」と「部」というモデルがあり、 集約の範囲のパターン A、パターン Bの 2種類を示しています。
72
5.3 集約の設計
▲図 5.3 学校と部の集約
学校と部の間には守りたい整合性 (①)があります。この場合集約の範囲はパターン A と Bどちらにするのがよいでしょうか。 集約の範囲に関しては、次のようなメリットデメリットから判断します。
• 集約を大きくするメリット – 整合性を確保する実装とテストが簡単になる
• 集約を大きくするデメリット – 処理するデータ量が増える – 排他制御の範囲が大きくなる
守りたい整合性が 1 集約内に閉じている場合、その整合性を確保するための実装は集 約内のクラスのみで行えるため、コードが非常にシンプルになります。また、テストをユ ニットテストで完結できるので、テスト容易性が高くなります。 図 5.3のパターン Aでは、学校クラスに部の承認や追加メソッドを定義し、その中でバ リデーションをすれば整合性の確保が簡単にできます。テストは学校クラスに対して書け ばよく、他の集約やデータベースのことを考える必要がありません。 しかし、パターン Bの場合、本章「5.1 複数集約の整合性を確保する方法」で解説した 通り、必要な実装が大きく増え、テスト容易性も下がります。この違いが集約の範囲が変 わることの大きな影響です。
一方、集約の範囲を大きくすると、リポジトリからは必ずまとめて取得、更新処理を行 うことになります。これにより、子オブジェクト数が多い場合はパフォーマンスが悪くな ることがあります。また、更新する際に排他制御の範囲が大きくなるため、その範囲が適 切かの検討が必要になります。排他制御は、楽観ロック、悲観ロック、後勝ちなど方法は
73
第 5章集約
いくつかありますが、いずれにせよ何らかの考慮が必要になります。 図 5.3の例では、排他制御の範囲が問題になります。たとえば、2つの部をほぼ同時に 更新した場合を考えてみましょう。野球部とサッカー部が同時に更新した際、パターン A では片方の操作を排他エラーとする必要があります。更新処理をするのは、「学校」集約 単位だからです。一見何の関係もない 2つの部の名前をそれぞれ変えただけなのにエラー になってしまうのには、違和感があるのではないでしょうか。
ここまでの議論を考慮して、最終的に集約の範囲を決めることになります。集約の範囲 に関しては、どちらの選択肢を選んでも一長一短になることがあるため、常に最適なもの が明確になるわけではありません。最初は正解だと思っても、実装を進めていくと別の案 がよかったと後から判明することもあります。 重要なのは、きちんとメリットデメリットを考慮して意思決定することです。それさえ あれば、後で判断を変更する際も根拠が明確になります。
74
第 6章
ドメインサービス
本章では、ドメインサービスに関する質問に対して解説します。
6.1 ドメインサービス 6.1.1 ドメインサービスの命名
  他のドメインオブジェクトと同様、ドメインサービスも責務に応じた名前が付けられ ると思います。何らか計算をするサービスに対して、XxxCalculationServiceではな く、XxxCalculatorといった Serviceが付かない名前でも問題ないでしょうか。  問題ありません。むしろ、そのように命名するべきです。この命名の観点がドメイン サービスを使用する上で非常に重要なポイントになります。 「サービス」と名付けられたクラスは責務が曖昧になり、肥大化していきがちです。そ の要因の 1つに名前があります。たとえば、UserDomainServiceというクラスは、「それ は何をするクラスなのか？」と責務について質問をした時、「ユーザーに関する…ドメイ ン処理をするクラス？」と、クラス名からの推測が難しく答えに詰まってしまいます。こ れは、責務を名前で表現できていないということを示しています。結果として、クラスに 書いて良いこと/悪いことの判断が曖昧になり、さまざまな処理が詰め込まれ、肥大化し ていきます。 それを防ぐために、責務をきちんと定め、クラス名として表現することはコードの保守 性を高めるために重要です。クラス名が「UserApprover」に変わると、そこにユーザー の作成や退会処理を書いたら違和感を覚えやすいでしょう。ドメイン層の「サービス」は
75
第 6章ドメインサービス
責務を考えて都度適切な名前を検討し、「サービス」という単語を使わないことをおすす めします。
6.1.2 ドメインサービスでリポジトリを使用してもよい？
  ドメインサービスがリポジトリを使用するのは良くないでしょうか？  賛否両論ありますが、問題ないと考えています。 ドメインサービスの定義から検討します。ドメインサービスは「エンティティ、値オブ ジェクトとしてモデリングすると不自然なドメイン知識 (ルール/制約)を実現する物」と いう定義です。その代表例が、集合に対する操作です。 たとえば「予約」というエンティティについて、「この時間に予約が既に埋まっている か」というのは予約エンティティ自体が知っているとするのは不自然です。そこで、予約 有無に関するドメイン知識を実現するものとしてドメインサービスを定義し、予約の集合 に対する操作を行うためにリポジトリを使用することになります。このような用途を考え るとドメインサービスがリポジトリを使用することは必要になると考えます。
ただし、リポジトリの使用を許可した際に、クラスの責務が増えすぎないように注意が 必要です。たとえば、リポジトリを使用した処理を行うファクトリークラスは、オブジェ クトの「生成」は行っても、「永続化」はしない方が責務が少なく、凝集度が高いと言え ます。(ファクトリーは、ドメインサービスの一環と捉えることができます。)
▼リスト 6.1 ファクトリーを使用するユースケース
class CreateReservationUseCase( private val reservationFactory: ReservationFactory, private val reservationRepository: ReservationRepository
) { @Transactional fun execute(someParameter: String) {
val reservation = reservationFactory.createReservation(someParameter) // ① reservationRepository.insert(reservationRepository) // ②
} }
この例では、ファクトリーの責務は生成までとし、ファクトリーとリポジトリを使っ てユースケースを実現するのをユースケースクラスの責務としています。この方が、
76
6.1 ドメインサービス
ReservationFactory に対するユニットテストが書きやすくなりますし、それぞれのクラ スの記述がシンプルになり可読性・保守性が高まります。
77
第 7章
テスト
DDDにおいて、モデルを頻繁に更新し、随時コードに反映するためにはテストの自動 化は必要不可欠です。また、テスト容易性が高い実装を目指すと自然に高凝集/低結合に なり、保守性の高いコードになっていきます。 本章では、DDDにおけるテストについて、具体的なモデル図、コードを交えながら解 説します。
7.1 [解説]DDDにおけるテスト 7.1.1 テスト対象のモデル図 各レイヤーの代表的なクラスに対するテストの実例を解説します。 まず、実装の題材となるユースケース図、ドメインモデル図、オブジェクト図を示しま す。ユースケース図は次のようになります。
78
7.1 [解説]DDDにおけるテスト
▲図 7.1 ユースケース図
作業者が自分のタスクを管理するシステムとして、登録、延期、完了するユースケース があることを確認しました。
続いて、ドメインモデル図/オブジェクト図は次のようになります。
▲図 7.2 ドメインモデル図/オブジェクト図
タスクのステータスや期日などのルール/制約を記述し、今回の実装スコープを定めま
79
第 7章テスト
した。本章では、ユーザーに関わる実装はスコープアウトし、タスクのステータスや期日 に関する実装を主として行うこととします。
このモデル図をもとに、プロダクトコードとテストコードを解説していきます。テス ティングフレームワークは JUnit5*1を使用しています。
7.2 [解説]エンティティのテスト エンティティはインスタンスを作成する生成メソッド (コンストラクタもしくはファク トリーメソッド)、内部状態を変更するミューテーションメソッド、DBの値などからイン スタンスを生成する再構成メソッドの 3つについて、それぞれプロダクトコードとテスト コードを解説します。
7.2.1 生成メソッドのテスト テスト対象の Taskクラス、createメソッドの実装は次のようになります。
▼リスト 7.1 Taskクラス create メソッド
class Task private constructor( // ① id: TaskId, name: TaskName, userId: UserId, status: TaskStatus, postponeCount: Int, dueDate: LocalDate
) { // 不変な属性 val id = id val name = name val userId = userId
// ② 可変な属性 var status = status
private set var postponeCount = postponeCount
private set var dueDate = dueDate
private set
companion object { /** 新しいタスクを作成します */ fun create(name: TaskName, dueDate: LocalDate, userId: UserId): Task { //③
return Task( id = TaskId(), name = name, userId = userId, status = TaskStatus.UNDONE, postponeCount = 0,
*1 <https://junit.org/junit5/docs/current/user-guide/>
80
7.2 [解説]エンティティのテスト
dueDate = dueDate )
} }
}
①プライマリコンストラクタの可視性を privateにして Taskクラス内からしか呼べな いようにし、③ドメインのルール/制約を表現する生成メソッドである createメソッドの み公開しています。また、②可変な属性 status、postponeCount、dueDate はセッター を privateにし、外部から直接任意の値を設定できないようにしています*2。 このメソッドに対するテストは次のようになります。
▼リスト 7.2 create メソッドのテスト
internal class TaskTest { @Test fun `新しくタスクを作成すると、未完了で延期回数0のインスタンスが生成される`() { // ①
// given(前提条件): ②
// when(操作): ③ val taskName = TaskName("新しいタスク") val dueDate = LocalDate.of(2021, 12, 1) val userId = UserId("user1") val task = Task.create(taskName, dueDate, userId)
// then(期待する結果): ④ assertEquals(TaskStatus.UNDONE, task.status) assertEquals(0, task.postponeCount, "延期回数の初期値は0で生成される") // ⑤
// 以下の属性は引数の値がそのまま設定される ⑥ assertEquals(taskName, task.name) assertEquals(dueDate, task.dueDate) assertEquals(userId, task.userId)
} }
テストコードは、「何を確認するか」の What がテスト観点、それを確認するための Howが具体的なテストコード記述です。テスト観点が明確でないと、「とりあえずテスト コードはあるものの何を確認しているのかはよくわからない」となってしまいます。観点 を明確にするために、①のようにテストメソッド名にテスト観点を記述します。
テストメソッド名にテスト観点を記述したら、「given(前提条件)、when(操作)、then(期 待する結果)」を明示的に記述します (②③④)。今回は②のように前提条件がありません
*2 Kotlinにおける属性やセッターの可視性を定義する文法については、「2.1.5 サンプルコード」に解説が あるので参照してください。
81
第 7章テスト
でしたが、その場合は givenは省略しても構いません。 このテストは、新規生成時の初期状態を確認するテストで、③で生成したインスタンス に対して④以下のコードで初期値に対してアサーションを書いています。 テストの可読性を高めるために、必要であればテスト観点を補足コメントとして記述し ます。JUnitでは、⑤のようにアサートメソッドにメッセージを渡す形で記述すると、テ スト失敗時のエラーメッセージに出力させることができます。複数行に渡ってまとめたい ものは⑥のように通常コメントで書いてもよいでしょう。これらはテストメソッド名など で内容が十分に表現できていれば省略可能です。
7.2.2 ミューテーションメソッドのテスト 続いて、ミューテーション (状態遷移)メソッドです。テスト対象の postponeメソッド は次のようになります。
▼リスト 7.3 Taskクラス postpone メソッド
class Task { // 略
/** タスクの期日を延期します */ fun postpone() {
if (this.postponeCount >= MAX_POSTPONE_COUNT) throw DomainException("最大延期回数を超えています")
this.dueDate = dueDate.plusDays(1) this.postponeCount += 1
}
companion object { // ① /**最大延期回数 */ private const val MAX_POSTPONE_COUNT = 3 // ②
} }
postponeメソッドはタスク期日を延期するメソッドで、延期すると期日と延期回数が 1ずつインクリメントされますが、延期回数が最大値を超えると例外が発生します。 ①②は Kotlinの文法で、MAX_POSTPONE_COUNTを staticなクラス変数として
定義しています。 このメソッドに対するテストは次のようになります。
▼リスト 7.4 postpone メソッドのテスト延期成功の場合
82
7.2 [解説]エンティティのテスト
@Test fun `タスクを延期すると、期日が1日後になり延期回数が1回増える`() { // ①
// given: val dueDate = LocalDate.of(2021,8,1) val task = Task.create(TaskName("タスク"), dueDate, UserId("user1") // ②
// when: task.postpone() // ③
// then: ④ assertEquals(LocalDate.of(2021, 8, 2), task.dueDate) assertEquals(1, task.postponeCount)
}
まずは、生成後 1回目の延期が成功するテストです。②事前条件として、生成直後のタ スクインスタンスを準備します。 続いて、③テスト対象のメソッドを呼び出し、④結果として期日と延期回数が期待値通 りであることをアサーションしています。このテストコード記述が、①のテスト観点を検 証する Howとして必要十分であることを確認します。
次に、最大回数を超えて延期が失敗する場合のテストを作成します。
▼リスト 7.5 postpone メソッドのテスト延期失敗の場合
@Test fun `最大回数延期されている場合、再度延期すると例外が発生する`() {
// given: タスクが既に3回延期されている ① val task = Task.create(TaskName("タスク"), LocalDate.now(), UserId("user1")) task.postpone() task.postpone() task.postpone()
// when: val target: () -> Unit = { // ②
task.postpone() }
// then: val exception = assertThrows<DomainException>(target) // ③ assertEquals("最大延期回数を超えています", exception.message) // ④
}
今度は①のように、事前条件として最大回数延期した状態のインスタンスを作成します。 ②テスト対象メソッドの呼び出しを関数として定義し、③でその処理を実行すると
DomainExceptionという例外が投げられること、④で投げられた例外のメッセージをア サーションしています。 なお、前提条件のインスタンスは次節で解説する再構成メソッドを使って次のようにも
83
第 7章テスト
生成できます。
▼リスト 7.6 再構成メソッドを使用して 3 回延期済タスクを作成
// given: タスクが既に3回延期されている val task = Task.reconstruct( postponeCount = 3, // 最大回数延期している id = TaskId(), name = TaskName("taskName"), status = TaskStatus.UNDONE, dueDate = LocalDate.of(2021, 8, 1), userId = UserId("user1")
)
再構成メソッドを使った方が任意の状態のインスタンスを生成することが容易ですが、 バリデーションがないため誤って不整合なインスタンスを生成してしまうリスクが生じ ます。 どちらの方法を使用してインスタンスを生成するかはメリットデメリットを考慮して都 度判断します。必ずしもどちらかに統一する必要はありません。
7.2.3 再構成メソッドのテスト 「2.1.5 サンプルコード」で解説した通り、エンティティには DBの値を使ってインスタ ンスを再構成するメソッドが必要になります。Taskクラスの再構成メソッドは次のよう になります。
▼リスト 7.7 Taskクラス再構成メソッド
class Task{ // 略 companion object {
/** エンティティを再構成します */ fun reconstruct(
id: TaskId, name: TaskName, userId: UserId, status: TaskStatus, postponeCount: Int, dueDate: LocalDate
): Task { return Task( // ①
id = id, name = name, userId = userId, status = status, postponeCount = postponeCount, dueDate = dueDate,
)
84
7.2 [解説]エンティティのテスト
} }
}
reconstructメソッドは引数の値でインスタンスを生成して返します。①で呼んでいる コンストラクタ (リスト 7.1①)は可視性が privateなので、Taskクラス外からは直接呼 び出せません。これにより、インスタンスを生成するには createか reconstructのどちら かのメソッドを使用しなければいけないことを強制しています。 このメソッドに対するテストは次のようになります。
▼リスト 7.8 再構成メソッドのテスト
@Test fun `reconstructに値を渡すと、渡した値でインスタンスが作成される`() {
// given: val taskId = TaskId("task1") val name = TaskName("タスク名") val userId = UserId("user1") val status = TaskStatus.DONE val postponeCount = 2 val dueDate = LocalDate.of(2021, 8, 1)
// when: val task = Task.reconstruct(
id = taskId, name = name, userId = userId, status = status, postponeCount = postponeCount, dueDate = dueDate
)
// then: assertEquals(taskId, task.id) assertEquals(name, task.name) assertEquals(userId, task.userId) assertEquals(status, task.status) assertEquals(postponeCount, task.postponeCount) assertEquals(dueDate, task.dueDate)
}
reconstructメソッドは引数の値を同じ名前の項目に詰め替えるだけのシンプルな処理 になるので、テスト要否は都度判断してもよいでしょう。引数に同じ型が複数 (たとえば Stringの項目が複数)あるような場合は、間違える可能性があるので実装しておくと安心 です。
85
第 7章テスト
7.3 [解説]値オブジェクトのテスト 値オブジェクトである TaskNameクラスのプロダクトコードは次の通りになります。
▼リスト 7.9 TaskNameクラス
data class TaskName(val value: String) { init { // ①
if (value.length > TASK_NAME_MAX_LENGTH) { throw DomainException("タスク名は10文字以下で入力してください")
} }
companion object { private const val TASK_NAME_MAX_LENGTH = 10 // ②
} }
① init は Kotlin の文法で、インスタンスが生成されたときに呼び出される処理です。 プライマリコンストラクタを直接外部から使用させる場合はこのようにバリデーションを initブロックに記述します。 このクラスに対するテストは次のようになります。
▼リスト 7.10 TaskNameクラスのテスト
internal class TaskNameTest { @Test fun `10文字以下の値を渡すと、正常にインスタンスが生成される`() {
// when: val taskName = TaskName("1234567890")
// then: assertEquals("1234567890", taskName.value)
}
@Test fun `11文字以上の値を渡すと、例外が発生する`() {
// when: val target: () -> Unit = { TaskName("12345678901") }
// then: val exception = assertThrows<DomainException>(target) assertEquals("タスク名は10文字以下で入力してください", exception.message)
} }
ここでは、TaskNameクラスの文字数チェックロジックの境界値テストとして、10文 字でエラーにならず、11文字でエラーになることをアサーションしています。
86
7.4 [解説]ユースケースのテスト
7.3.1 値オブジェクトが独立することによるテスト容易性の向上 Task クラスには taskName 以外にも postponeCount、dueDate などテスト対象とな
る属性が複数存在するため、それら全てのテストを Taskクラスのテストに実装しようと すると Taskクラスに対するテストコード量がどんどん増大していきます。 そこで、今回の実装では TaskNameクラスを独立させることにより、タスク名の文字 数に関するテストを TaskNameクラスのテストに書けるようになりました。この際、テ スト観点に関係ない他の属性を記述する必要がないため、テストコードの記述を非常に簡 潔にできました。
TaskNameクラスは「タスク名を表すクラス」と責務が明確で高凝集/低結合になって います。今回の事例のように、高凝集/低結合な実装にするとテスト容易性、可読性が高 まります。
7.4 [解説]ユースケースのテスト ユースケースクラスのテストは「まずはユニットテストを検討し、必要であれば結合テ ストを実装する」という基本方針とします。 本書におけるユニットテストとは、データベース、ネットワークアクセスなどを行うク ラスをモックして行うテストです*3。モック対象として代表的なのはリポジトリで、DB 接続を行わず全てオンメモリで完結するテストになります。
7.4.1 更新系ユースケース タスクを作成するユースケースです。プロダクトコードは次の通りです。
▼リスト 7.11 タスク作成ユースケース
class CreateTaskUseCase( private val taskRepository: TaskRepository
) { @Transactional fun execute(taskName: String, dueDate: LocalDate, userId: UserId): TaskId {
val task = Task.create(TaskName(taskName), dueDate, userId) taskRepository.insert(task) return task.id
} }
*3 <https://testing.googleblog.com/2010/12/test-sizes.html> における smallテスト
87
第 7章テスト
受け取った引数をもとにエンティティを作成し、リポジトリのインサートメソッドに渡 すユースケースです。引数のユーザー IDに対してユーザーが存在するかのバリデーショ ンを行う必要がありますが、現時点では未実装としています。 このクラスに対するテストは次のようになります。モッキングライブラリは
MockK*4を使用しています。モッキングの方法はライブラリによって異なるため、他の ライブラリを使用する際には適宜カスタマイズしてください。
▼リスト 7.12 タスク作成ユースケースのテスト
internal class CreateTaskUseCaseTest { // 依存オブジェクトのモック private val taskRepository: TaskRepository = mockk() // ①
// テスト対象 private val createTaskUseCase = CreateTaskUseCase(taskRepository) // ②
@Test fun `タスク名等を渡すと、その値を使用して新規作成されたタスクが保存される`() {
// given: TaskRepositoryのinsertメソッドに渡される値をキャプチャする ③ val taskCapturingSlot: CapturingSlot<Task> = slot() every { taskRepository.insert(capture(taskCapturingSlot)) } just Runs
// when: val taskName = "新しいタスク" val dueDate = LocalDate.of(2021, 8, 1) val userId = UserId("user1") createTaskUseCase.execute(taskName, dueDate, userId) // ④
// then: 新規作成されたタスクがリポジトリに渡されている val capturedTask: Task = taskCapturingSlot.captured // ⑤
// repository.insertに渡された値のアサーション ⑥ // ユースケースの引数からタスクが生成されている assertEquals(TaskName(taskName), capturedTask.name) assertEquals(taskName, capturedTask.dueDate) assertEquals(userId, capturedTask.userId) // 新規作成状態のタスクである assertEquals(TaskStatus.UNDONE, capturedTask.status)
} }
① TaskRepositoryはモックインスタンスとして作成しています。インスタンス作成の 記述はテストメソッド内に実装しても問題ありませんが、このように実装するとテストメ ソッドのテスト観点がわかりやすくなり、可読性を高めることができます。②でモックし た TaskRepositoryを使用してテスト対象インスタンスを作成します。
*4 <https://github.com/mockk/mockk>
88
7.4 [解説]ユースケースのテスト
③ mockk の機能を使用して TaskRepository.insert に渡すメソッドをキャプチャする 設定をしています。キャプチャ結果を格納する CapturingSlotインスタンスを作成し、ど のメソッドが呼び出されたタイミングでキャプチャするかを設定します。just runsとい う記述は戻り値なくモックメソッドが実行完了することを示しています。 ④テスト対象のメソッドを実行し、⑤でキャプチャされた値を取得、⑥のようにアサー ションを行います。 このユースケースクラスの責務は「引数の値をもとに Taskを生成 (Task.createメソッ
ドを呼び出)してリポジトリに渡す」ことなので、ユニットテストではそれが実行されてい ることをアサーションします。Task.createメソッドに対しては Taskエンティティのテ ストで全項目に対してアサーションしているので、このユースケースのテストで再度 Task インスタンスの全項目をアサーションする必要はありません。ここでは postponeCount のアサーションを省略しています。 また、タスク名が 11文字以上の時は例外が投げられますが、それは TaskName単体で テストしているのでユースケースクラスのユニットテストという観点では必要ありませ ん。しかし、ユースケースとタスク、タスク名の結合テストという観点から必要であれば 実装します。
7.4.2 参照系ユースケース タスクを ID指定で参照するユースケースです。プロダクトコードは次の通りです。
▼リスト 7.13 タスク参照ユースケース
class FetchTaskDetailUseCase( private val taskRepository: TaskRepository, private val userRepository: UserRepository
) { fun execute(taskId: TaskId): FetchTaskDetailDto? {
val task = taskRepository.findById(taskId) ?: return null // ① val user = findUser(task.userId) // ② return FetchTaskDetailDto(task, user) // ③
}
// private methods ------------------------
private fun findUser(userId: UserId): User { return userRepository.findById(userId)
?: throw AssertionFailException("ユーザーが見つかりません") }
}
data class FetchTaskDetailDto( val taskId: String, val name: String, val status: TaskStatus, val postponeCount: Int, val userId: String, val userName: String
89
第 7章テスト
) { constructor(task: Task, user: User) : this(
taskId = task.id.value, name = task.name.value, status = task.status, postponeCount = task.postponeCount, userId = task.userId.value, userName = user.name
) }
/*** 事前条件を満たさないことを示す例外 */
class AssertionFailException(message: String) : RuntimeException(message) // ④
①タスク ID でタスクを取得します。「?: return null」は、findById の戻り値が null だった場合、その場で executeメソッドから nullを returnすることを表します。 ② Task が持つユーザー ID を条件に UserRepository で検索し、見つからなければ例
外を投げる処理をプライベートメソッドとして切り出しています。ここでは、Taskテー ブルから Userテーブルには外部キー制約を設定していることを想定した実装となってお り、そのユーザー IDで検索して取得結果がないことは想定外なので事前条件を満たさな いことを示す例外 (④)を投げています。 ③取得した Taskエンティティと Userエンティティを、ユースケースの戻り値用オブ ジェクトに詰め替えて返します。 このクラスに対するテストは次のようになります。まずは正常系のテストです。
▼リスト 7.14 タスク参照ユースケースのテスト正常系
internal class FetchTaskDetailUseCaseTest { // 依存オブジェクトのモック ① private val taskRepository: TaskRepository = mockk() private val userRepository: UserRepository = mockk()
// テスト対象 private val useCase = FetchTaskDetailUseCase(taskRepository, userRepository)
@Test fun `2つのリポジトリから値が取得できる場合、結果がDTOに詰め替えて返される`() {
// given: ユーザーリポジトリ、タスクリポジトリが値を返す val user = TestUserFactory.create() // ② every { userRepository.findById(user.id) }.returns(user) // ③
val task = TestTaskFactory.create(userId = user.id) // ④ every { taskRepository.findById(task.id) }.returns(task) // ⑤
// when: val actualDto = useCase.execute(task.id) // ⑥
// then: val expectDto = FetchTaskDetailDto(
90
7.4 [解説]ユースケースのテスト
taskId = task.id.value, name = task.name.value, status = task.status, postponeCount = task.postponeCount, userId = task.userId.value, userName = user.name
) assertEquals(expectDto, actualDto) // ⑦
} }
①更新系ユースケースのテストと同様に、依存しているリポジトリのモックインスタン スを作成します。このインスタンスへの具体的なモック処理は各テストメソッド内に実装 します。 ③⑤ユースケース内で使用している 2つのメソッドについて、それぞれ ID指定で検索
した場合にエンティティが返されるようにモックの設定をしています。この際に返される インスタンスは、②④のようにテスト用インスタンス作成オブジェクトを使用して作成し ています。詳細は次節「x.x.x テスト用インスタンス生成オブジェクト」で解説します。 ⑥ 2つのリポジトリをモックした状態で、テスト対象のメソッドを実行します。 ⑦返された DTOを、期待する DTOと同値であることをアサーションします。
ここで重要なのは、③⑤のリポジトリから返される値によって挙動が変わるということ です。正常系では 2つのリポジトリから値が返されましたが、そうではない場合はどのよ うな挙動になるのか、それぞれテストを書いていきます。まずは、TaskRepositoryから 返される値が nullの場合です。
▼リスト 7.15 タスク参照ユースケースのテスト異常系 1
internal class FetchTaskDetailUseCaseTest { // 他のテストは省略 @Test fun `タスクリポジトリから返される値がnullの場合、nullが返される`() { // ①
// given: val taskId = TaskId() every { taskRepository.findById(taskId) }.returns(null) // ②
// when: val actualDto = useCase.execute(taskId)
// then: assertNull(actualDto) // ③
} }
リスト 7.14の正常系テストと何が異なるのか、読んだだけでわかるようにテスト観点
91
第 7章テスト
(テストで確認するWhat)を記述します (①)。その観点に合わせて、②のように返される 値のモック記述を変更します。そのようなモックをした場合、executeの戻り値が nullに なることを③で確認します。
次に、ユーザーリポジトリから返される値が nullの場合のテストコードです。
▼リスト 7.16 タスク参照ユースケースのテスト異常系 2
internal class FetchTaskDetailUseCaseTest { // 他のテストは省略 @Test fun `ユーザーリポジトリから返される値がnullの場合、例外が投げられる`() {
// given: ① val userId = UserId() val task = TestTaskFactory.create(userId = userId)
// タスクリポジトリからは値が返される every { taskRepository.findById(task.id) }.returns(task)
// ユーザーリポジトリの戻り値はnull every { userRepository.findById(userId) }.returns(null)
// when: ② val target: () -> Unit = { useCase.execute(task.id) }
// then: ③ val thrownException = assertThrows<AssertionFailException>(target) assertEquals("ユーザーが見つかりません", thrownException.message)
} }
①今度は「タスクリポジトリからは値が返されるが、ユーザーリポジトリの戻り値は null」となるようにモックを設定します。 ②例外が発生することを想定する、テスト対象メソッドを定義します。 ③テスト対象メソッドを実行すると例外が発生すること、そのメッセージを確認します。
このように、依存クラスの挙動によってテスト対象クラスの挙動が変わる場合は、依存 クラスをモックして挙動を指定することにより、それぞれのパターンでのテストを実装で きます。
7.4.3 テスト用インスタンス生成オブジェクト リスト 7.14のテスト解説で言及した、テスト用インスタンスを作成するオブジェクト
について解説します。 テストコードが増えると、テストコード内でエンティティや値オブジェクトのインスタ
92
7.4 [解説]ユースケースのテスト
ンスが必要になることが増えてきます。そのような場合は、テスト用インスタンス生成オ ブジェクトを作成すると便利です。 ▼リスト 7.17 テスト用インスタンス生成オブジェクト
object TestTaskFactory { fun create(
// ① 引数には全てデフォルト値を設定する taskID: TaskId = TaskId(), status: TaskStatus = TaskStatus.UNDONE, taskName: String = "task1", postponeCount: Int = 0, dueDate: LocalDate = LocalDate.now(), userId: UserId = UserId()
): Task { return Task.reconstruct(
id = taskID, name = TaskName(taskName), status = status, postponeCount = postponeCount, dueDate = dueDate, userId = userId
) }
}
このようなオブジェクトを作成すると、複数クラスから再利用できます。また、①でメ ソッドの各引数にデフォルト値を定義していることにより、このオブジェクトの呼び出し 元は次のように実装できます。 ▼リスト 7.18 テスト用インスタンス生成オブジェクトの参照元
@Test fun `タスクを3回延期していた場合、…`() {
// given: val task = TestTaskFactory.create( // ①
status = TaskStatus.UNDONE, postponeCount = 3 // 他の値はデフォルト値が適用される
) // 略
}
①はでテスト観点的に関心があるタスクステータスと延期回数のみ指定しており、関心 がないタスク IDや期日などは createメソッドのデフォルト値が適用されます。このよう に観点に関係のない記述をなくすとテストコードが非常にシンプルになり、可読性が上が ります。 テストコードは意識しないとどんどん記述が増えて可読性と保守性が低下していくの で、このような工夫は非常に重要になります。
93
第 7章テスト
なお、このクラスはメインディレクトリではなく、テストディレクトリに配置してテス トコードからしか参照されないようにします。
7.4.4 ユニットテストのメリット ユースケースのテストを DBを使用した結合テストではなく、ユニットテストとして行 うメリットは次の通りです。
• ①テストの実行速度が速い
• ②データ準備コストが小さい
① DBに接続してデータの入出力するより、全てオンメモリで実行するテストの方が処 理速度が速く、実行時間が短いです。テスト数はプロダクトの成長に伴って増えていくの で、テスト実行時間の短さは徐々に重要になっていきます。 ②に関しては、リスト 7.14～リスト 7.16のテストではリポジトリの戻り値をテストご とに指定していますが、これを実際に DBに接続して実行する場合は一度取得用のデータ を DB にインサートする必要があります。外部キー制約がある場合はテストで直接必要 ないデータもまとめて準備する必要があり、1つのテストケースを実行するための実装コ ストが大きくなりがちです。一方、モックを使用する場合は戻り値の指定がたった数行で 実装できます。テストの実装コストが大きいと、時間が足りない、気が重いなどの理由で テストが実装されなくなってしまうため、実装コストを下げることは非常に重要です。
ただし、前述の通りユースケースクラスのテストの基本方針は「まずはユニットテスト を検討し、必要であれば結合テストを実装する」なので、テスト観点的に必要になったら ユースケースも結合テストを行います。その実装方法は次節のリポジトリの結合テストを 参考にしてください。
7.5 [解説]リポジトリのテスト リポジトリはユニットテストでは意味のあるテストができないので、データベースを使 用した結合テストを行います。 プロダクトコードから紹介します。このサンプルではデータベースは RDBの前提で、
ORマッパーは jOOQ*5を使用しています。SQLを組み立てる形の ORマッパーなので、 ライブラリ知識がなくても比較的読みやすいです。
*5 <https://www.jooq.org/> 「ジューク」と読みます。
94
7.5 [解説]リポジトリのテスト
7.5.1 インサートと ID検索メソッドのテスト まず、テスト対象のインサートメソッドは次の通りです。
▼リスト 7.19 タスクリポジトリの実装クラス insert メソッド
class TaskJooqRepository(private val jooq: DSLContext) : TaskRepository { override fun insert(task: Task) { // ①
jooq.newRecord(TASKS) .setTaskId(task.id.value) .setName(task.name.value) .setPostponeCount(task.postponeCount) .setDueDate(task.dueDate) .setStatus(task.status.name) .setUserId(task.userId.value) .insert() // ②
} }
①引数で受け取ったオブジェクトを、TASKSテーブルの各カラムに値をセットして② でインサートを実行しています。 次に、ID指定して検索するメソッドです。
▼リスト 7.20 タスクリポジトリの実装クラス ID 検索メソッド
class TaskJooqRepository(private val jooq: DSLContext) : TaskRepository { // 他メソッドは省略 override fun findById(taskId: TaskId): Task? { // ①
val taskRecord: TasksRecord = jooq.selectFrom(TASKS) .where(TASKS.TASK_ID.eq(taskId.value)) // ② .fetchOne() ?: return null // ③
return mapRecordToEntity(taskRecord) // ④ }
/**TaskRecordをTaskエンティティに詰め替えます ⑤*/ private fun mapRecordToEntity(taskRecord: TasksRecord): Task {
return Task.reconstruct( id = TaskId(taskRecord.taskId), name = TaskName(taskRecord.name), status = TaskStatus.valueOf(taskRecord.status), postponeCount = taskRecord.postponeCount, dueDate = taskRecord.dueDate, userId = UserId(taskRecord.userId)
) }
①引数で識別子である TaskIdを指定しています。それをもとに②WHERE句を組み 立て、検索結果が 0 件であればその場で null を return します (③)。結果があった場合 は、テーブルに対応する jOOQの Recordクラスを Taskエンティティの再構成メソッド
95
第 7章テスト
を使用して詰め替えます (④)。この際、⑤のように詰め替えメソッドを独立させておく と、他の検索系メソッドからも再利用できます。
このコードに対するテストは次の通りです。ここでは、インサートメソッドと ID検索 メソッドを 1つのテストでまとめて実施しています。インサートと検索は別のテストで行 う方針も考えられますが、インサートされた結果の確認、検索対象データの準備にお互い の処理が必要になるため、同じテストにまとめる方針を取っています。
▼リスト 7.21 insert と ID 指定検索のテスト
@SpringBootTest // ① @Transactional // ② internal class TaskJooqRepositoryTest(
@Autowired private val taskRepository: TaskJooqRepository, @Autowired private val userTestDataCreator: UserTestDataCreator,
) { @Test fun `insertしたものがfindByIdで取得できる`() {
// given: // ユーザーが既に作成されている val user: User = userTestDataCreator.create() // ③
// インサートするタスクを作成 ④ val createdTask = Task.create(
name = TaskName("新しいタスク"), dueDate = LocalDate.now(), userId = user.id
)
// when: インサートし、結果をID指定で取得する ⑤ taskRepository.insert(createdTask) val foundTask = taskRepository.findById(createdTask.id)!!
// then: インサートしたインスタンスが、リポジトリ経由で取得できる ⑥ assertEquals(createdTask.id, foundTask.id) assertEquals(createdTask.name, foundTask.name) assertEquals(createdTask.userId, foundTask.userId) assertEquals(createdTask.status, foundTask.status) assertEquals(createdTask.postponeCount, foundTask.postponeCount) assertEquals(createdTask.dueDate, foundTask.dueDate)
} }
①はテストで DIを有効にする設定用アノテーションです (詳細の説明は省略します)。 ②はトランザクションを設定するアノテーションで、これにより各テスト実行ごとに ロールバックされ、テスト同士の独立性が保たれます。 ③インサート対象のテーブルに外部キー制約がある場合には、参照先のデータが事前 に入っている必要があります。その場合、テストデータ作成の仕組みを作成してテスト の given節で実行します。ここでは、全てデフォルトの値で新規ユーザーを作成してイン
96
7.5 [解説]リポジトリのテスト
サートしています。テストデータ作成の仕組みについては次節で詳しく解説します。 ④インサート対象のエンティティインスタンスを作成し、⑤リポジトリのインサートと
ID指定での検索を続けて実行します。 ⑥全ての項目をアサーションします。テスト観点的に、ここは面倒でも全ての項目のア サーションが必要です。エンティティからのインサート、DBからのセレクト、その結果 の再構成、と複数のメソッドが組み合わされており、ケアレスミスで項目の入れ違いが発 生しやすい処理であるためです。ここでテストしておくと、安心感を持ってリポジトリを 使用できます。
別のテストケースで、ヒットしなかった場合にはエラーにならず null が返されること をテストします。 ▼リスト 7.22 ID 検索テスト異常系
@Test fun `findById_ヒットしなければnullが返される`() {
// when: val result = taskRepository.findById(TaskId("NotExistsId"))
// then: assertNull(result)
}
7.5.2 テストデータ作成用オブジェクト 結合テストを実行するにあたり、テストデータ作成は複数のテストで必要になるため、 専用のオブジェクトを作成しておくと便利です。リスト 7.21 テストの③で使用した、 UserTestDataCreatorは次のような実装になります。 ▼リスト 7.23 テストデータ作成オブジェクト
class UserTestDataCreator(private val userRepository: UserRepository) { fun create(userName: String = "user1"): User { // ①
val user = TestUserFactory.create(userName) // ② userRepository.insert(user) // ③ return user
} }
リスト 7.17の TestTaskFactoryと同様に、①のように引数にデフォルト値を定義して おくとテスト観点に必要な項目のみテスト側で指定できるようになります。リスト 7.21 ③ではユーザー名はテスト観点にはないので引数を省略しており、その場合はユーザー名
97
第 7章テスト
はデフォルト値の「user1」になります。 続いて、②テストインスタンス作成オブジェクトを利用してエンティティを作成し、③ リポジトリを使用してインサートします。
ここで重要なポイントは、データのインサートにエンティティとリポジトリを使用して いることです。これには 2つメリットがあります。
• 1. テーブル構造を隠蔽できること
• 2. 不整合データの作成をある程度抑制できること
1. CSVや SQLでテストデータを準備すると、テーブル変更のたびにそれらのデータ を直接修正する必要があります。テストデータが増えるとこのメンテナンスコストはかな り大きくなります。また、親子階層を持つデータをテキストで記述するのは保守性が低い です。そこで、リポジトリを使用するとテーブル変更やテーブル構造の影響はリポジトリ の実装クラスが全て吸収してくれるので、テストデータへの影響を一切なくすことができ ます。
2. プロダクトコードとして使用され、テストもされているコードを再利用することで、 データの整合性がある程度保証できます。ある程度というのは、エンティティの再構成メ ソッドを使用して任意の値を指定するため、そこで不整合な値を指定することは可能だか らです。それでもカラムの入れ違いや、子テーブルのインサート忘れなどのミスは抑制で きるため、直接 CSVや SQLを記述するよりは不整合データが発生する可能性を下げる ことができます。
このテストデータ作成用オブジェクトは初期に作成コストがかかりますが、それ以降は 再利用性が高くテスト実装コストを大幅に下げられるため、非常にリターンが大きいもの になります。
7.5.3 その他の条件で取得するメソッドのテスト 次に、ID以外の条件で検索し、複数の件数が返されるメソッドです。たとえば、タス クステータスとユーザー ID で検索するメソッドのプロダクトコードは次のようになり ます。
98
7.5 [解説]リポジトリのテスト
▼リスト 7.24 ステータスとユーザー名検索メソッド
class TaskJooqRepository{ // 他メソッドは省略 override fun findByStatusAndUserId(
taskStatus: TaskStatus, userId: UserId // ① ): Set<Task> {
return jooq.selectFrom(TASKS) .where(TASKS.STATUS.eq(taskStatus.name)) .and(TASKS.USER_ID.eq(userId.value)) // ② .fetch() .map { taskRecord -> mapRecordToEntity(taskRecord) } // ③ .toSet()
} }
①の引数のタスクステータスとユーザー IDを使用して、②でWHERE句を組み立て ています。③取得結果をエンティティに詰め替える際には、リスト 7.20⑤の詰め替えメ ソッドを再利用しています。 このメソッドに対するテストは次の通りです。
▼リスト 7.25 ステータスとユーザー名検索メソッドのテスト
internal class TaskJooqRepositoryTest( @Autowired private val taskRepository: TaskJooqRepository, @Autowired private val userTestDataCreator: UserTestDataCreator, @Autowired private val taskTestDataCreator: TaskTestDataCreator
) { @Test fun `findByStatusAndUserId_指定したステータスとユーザーIDで絞り込みができる`() {
// given: ① // タスクから参照されるユーザーを作成 ② val user = userTestDataCreator.create(userName = "user1") val anotherUser = userTestDataCreator.create(userName = "user2")
// 未完了タスク2件、完了タスク1件、異なるユーザータスク1件が作成されている ③ // 検索対象 val 検索対象タスク1: Task = createTask(TaskStatus.UNDONE, user.id) val 検索対象タスク2: Task = createTask(TaskStatus.UNDONE, user.id)
// 検索対象外 createTask(TaskStatus.DONE, user.id) // ステータス違い createTask(TaskStatus.UNDONE, anotherUser.id) // ユーザー違い
// when: ④ val foundTasks: Set<Task> =
taskRepository.findByStatusAndUserId(TaskStatus.UNDONE, userId)
// then: 未完了の2件のみ取得される ⑤ val expectTaskIds: Set<TaskId> =
setOf(検索対象タスク1.id, 検索対象タスク2.id) val actualTaskIds: Set<TaskId> = foundTasks.map { it.id }.toSet() assertEquals(expectTaskIds, actualTaskIds)
99
第 7章テスト
}
private fun createTask(taskStatus: TaskStatus, userId: UserId): Task { // ⑥ return taskTestDataCreator.create(status = taskStatus, userId = userId)
} }
①事前条件として、絞り込みの検証を行うためのデータ準備を行います。 ②でタスクから参照するユーザーを作成し、③で検索条件に合致するタスク、合致しな いタスクを作成します。ここで、実行環境的に日本語が使用できる場合は、変数名などで データの意図を日本語で記述すると可読性が高まります。また、TaskDataCreator をパ ラメーターを変えて 4 回呼ぶため、記述を簡潔にするために⑥のようにプライベートメ ソッドを切り出しています。 そして、④検索処理を実行し、⑤で想定通りに絞り込みが行われていることを確認し ます。 ここで、アサーション内容は IDのみとなっています。Recordから Taskインスタンス へのマッピング処理はリスト 7.20⑤の詰め替えメソッドで共通化してあり、リスト 7.21 でテストされているため、このテストではWHERE句の絞り込みだけすれば十分だから です。(そう判断するためには select文を作成する部分なども共通化する方がよいですが、 ここでは省略しています。)
以上で代表的なクラスのテストについての解説は終了です。
7.6 テスト実装時に迷うこと 7.6.1 モックを使ったテストに意味はある？
  ユースケース内で呼ばれるメソッドをモックにしたら、モックライブラリのテストを しているようで意味がないように思いますが、いかがでしょうか。  そのような違和感を感じる際、ユースケースの責務が非常にシンプルな場合 (1つのリ
ポジトリを呼んで値をそのまま返すなど)は、テストの価値が小さく、省略してよいこと
100
7.6 テスト実装時に迷うこと
があります。しかし、そうでない場合は設計に問題がある可能性があります。
ユニットテストでは、「テスト対象クラスが行うこと (責務)」に対してテストします。 ユースケースクラスの責務は、ドメイン層で公開されている (publicな)メソッドなどを 組み合わせてユースケースを実現することです。ここで依存クラスをモックして意味がな いように感じられる場合は、責務の分割が良くない可能性があります。 たとえば、タスク延期を延期するユースケースクラスについて、良い例と悪い例を考え てみましょう。まずは良い例です。
▼リスト 7.26 タスク更新ユースケース良い例
class UpdateTaskStatusUseCase( private val taskRepository: TaskRepository
) { @Transactional fun execute(taskId: TaskId) {
val task = taskRepository.findById(taskId) ?: throw UseCaseException("タスクが見つかりません") // ①
task.postpone() // ② taskRepository.update(task) // ③
} }
このクラスでは、「①更新対象のタスクを取得し (なければ例外)、②タスクを延期し、 ③タスクを保存する」という形でユースケースを組み立てています。TaskRepositoryは 「取得する」「更新する」というWhatだけが記述され、Howはインフラ層の実装クラスに 隠蔽されています。その Howは RDBか NoSQLかオンメモリか、ということを意識せ ずに呼び出せるようになっています。このクラスのユニットテストでは TaskRepository をモックしますが、「取得する」「更新する」の Howをモックしても、このクラスがユー スケースを組み立てることのテストとしては十分に意味があります。
一方、悪い例をみてみましょう。
▼リスト 7.27 タスク更新ユースケース悪い例
class BadUpdateTaskStatusUseCase( private val taskRepository: TaskRepository
) { @Transactional fun execute(taskId: TaskId) {
taskRepository.postPoneTask(taskId) // ① }
}
101
第 7章テスト
責務の分割を間違えて、TaskRepositoryが「タスクを延期する」というメソッドを持っ てしまっています。これでは、TaskRepositoryをモックした際に、「取得する」「更新す る」という永続化機構の処理以外に、「延期する」というドメイン層の実装も一緒にモッ クされてしまいます。これでは確かにユースケースクラスをテストする意味が無いように 感じてしまいますが、これはリポジトリの責務が過剰になっており、設計として問題があ ることが原因です。 この場合は、違和感をきっかけにリポジトリの責務を見直し、リファクタリングするの がよいでしょう。モックを使用するテストは、設計の問題に違和感を感じて修正するきっ かけを作ることができます。
7.6.2 外部サービス呼び出しはテストを書く？
  データ変更を伴う外部サービス API の呼び出し（たとえば、TwitterAPI を使って ツイートするなど）のテストはどのように書けばよいですか？  外部 APIにリクエストを送るクライアントクラスは、単体で実行できるテストコード を書いてコミットはしますが、通常のテスト実行対象からは除外される設定にします。そ の際はアサーションのないただのランナー (起動用スクリプト)のような位置付けにする こともあります。理由は後述しますが、まずはコードを見てみましょう。 次のようなクライアントクラスがあったとします。
▼リスト 7.28 Twitterクライアントインターフェイス
package dddfaq.domain.twitter
data class Tweet(val text: String)
interface TwitterClient { fun postTweet(tweet: Tweet)
}
102
7.6 テスト実装時に迷うこと
▼リスト 7.29 Twitterクライアント実装クラス
package dddfaq.infra.twitter
class TwitterSdkClient : TwitterClient { override fun postTweet(tweet: Tweet) {
// ライブラリの機能を使用してツイートを送信する }
}
これに対するテストコードは次のようになります。 ▼リスト 7.30 Twitterクライアントクラスのテストコード
/***ローカルでTwitterSdkClientの動作確認をするためのランナー */
internal class TwitterSdkClientTest { @Test @EnabledIfEnvironmentVariable(named = "CALL_TWITTER", matches = "true") // ① fun `ツイートを送信する`() {
// when: val client = TwitterSdkClient() client.postTweet(Tweet("hello")) // ②
// then: // 送信動作確認用のためアサーションなし // ③
} }
① JUnitの機能でこのアノテーションを付与すると環境変数「CALL_TWITTER」に 「true」が設定されている時のみテストが実行されるようになります。これにより普段の テスト実行対象からは除外され、不用意に外部 APIにリクエストが飛ぶことがなくなり ます。ローカルで実行したい時のみ、環境変数を設定して動かします。 ②動作確認対象であるクライアントクラスの処理を呼び出します。 ③外部サービスへのリクエストは結果のアサーションが簡単にかけない場合もあるの で、アサーションはなくてもよいでしょう。もちろん、書けるのであれば書いても構いま せん。このクラスは、TwitterSdkClientTestRunnerという名前にしてもよいでしょう。
このようなテストコードを書く理由は、テスト対象のクライアントクラスを小さく実行 できると開発速度が上がるためです。アプリケーション全体を起動してコントローラー経 由でクライアントクラスを呼び出すのではなく、クライアントクラスだけをユニットテス トの仕組みから直接起動するのです。コードを修正してからの実行までが速くなり、動作 確認が非常に楽になります。 一方、全体のテスト実行対象から除外する理由は、ローカルや CI環境において普段の
103
第 7章テスト
テスト実行のたびに外部 APIをリクエストを送らせたくないからです。外部サービスの データが想定外の状態になる、リクエスト回数制限が発生する、外部サービスが停止した 時にテストが通らなくなる、といった問題が生じます。 除外してでもコミットする理由は、時間が空いてからクライアントクラスを機能拡張す る時に再度使えるからです。その場合は前述の通り環境変数を設定して実行します。 以上の理由から、テストコードを作成し、実行対象からは除外する設定でコミットして おくのがおすすめです。
104
第 8章
アーキテクチャ
本章では、アーキテクチャ全般にまたがる内容の質問に対して解説します。
8.1 例外処理 8.1.1 ユーザー表示するエラーメッセージを直接返してよい？
  APIサーバーでエラーが発生した場合のメッセージについて、サーバーからエンド ユーザーに表示するメッセージを直接返してよいでしょうか。それとも、エラーコー ドのみ返してメッセージはフロントで定義するべきでしょうか。  どちらでも可能です。メリットデメリットがあるのでそれを考慮して決定します。 サーバーサイドから表示用メッセージを直接返す方針のメリットは、実装がシンプルに なり、工数が全体的に低くなる点です。デメリットは、メッセージ変更の際にサーバーサ イドのコードを変更する必要があるため、フロントエンド*1の実装だけでメッセージを含 めた見た目の開発を完結させられなくなる点です。 これをどう評価するかは、チームの体制によって変わります。サーバーとフロントの開 発チームがきっちり分かれて極力個別で開発を進めたい場合はエラーコードのみを返す方 針にし、ある程度両方修正できるメンバーが存在し柔軟に対応できる場合はメッセージを 直接返す方針にする、と判断してもよいでしょう。
*1 ここでいうフロントエンドは、ブラウザ表示用のフロント、スマートフォンのネイティブアプリケーショ ン両方が対象です
105
第 8章アーキテクチャ
8.1.2 投げられた例外はどう処理する？
  各レイヤーで例外を投げた後はどのように処理をするのがよいでしょうか。  プレゼンテーション層に共通の例外ハンドラーを定義し、そこで例外をキャッチしてエ ラーレスポンス用のオブジェクトに詰め替えるのがよいでしょう。
ドメイン層の例外は次のようなものを定義します。ここではエラーメッセージとコード を両方保持していますが、必要な情報は適宜検討してください。
▼リスト 8.1 ドメイン層の例外クラス
package dddfaq.domain.shared.exception
class DomainException( val errorMessage: String, val errorCode: ErrorCode,
) : RuntimeException(errorMsg)
この例外を、次のような例外ハンドラーでキャッチします。この実装方法はフレーム ワークに依存します。ここでは Springを使用した事例を解説します。
▼リスト 8.2 共通の例外ハンドラードメイン層の例外をキャッチするメソッド
package dddfaq.presentation.shared.exception
@ControllerAdvice // ① class ExceptionHandler {
@ExceptionHandler(DomainException::class) // ② fun handleDomainException(
e: DomainException // ③ ): ResponseEntity<ErrorResponse> {
return ResponseEntity( ErrorResponse(e.message, e.errorCode) // ④, HttpStatus.BAD_REQUEST // ⑤
) }
}
クラスに① ControllerAdviceアノテーションをつけると、このクラスが全てのコント ローラーで共通の設定として動くようになります。
106
8.1 例外処理
メソッドに② ExceptionHandler アノテーションをつけ、アノテーションの引数に DomainExceptionを指定します。すると、引数の例外が投げられたときにこのメソッド が呼び出され、投げられた例外インスタンスが引数で渡されるようになります (③)。 ④で、引数に渡された例外インスタンスをもとに、エラーレスポンスを表すクラスに 詰め替えます。ResponseEntity の第 1 引数の値は、Spring の仕組みにより JSON 形式 にシリアライズされてクライアントに返されます。⑤でレスポンスの HTTPステータス コードに BAD_REQUEST(400)を指定しています。 このように実装すると、DomainExceptionがドメイン層やユースケース層で投げられ た場合は自動的にクライアントにその内容を伝えられます。
キャッチしたい例外の種類が増えた場合は次のようにします。
▼リスト 8.3 共通の例外ハンドラー他の例外をキャッチするメソッド
@ControllerAdvice class ExceptionHandler {
// 略: その他の例外パターンの定義
@ExceptionHandler(UseCaseException::class) // ① fun handleUseCaseException(e: UseCaseException): ResponseEntity<ErrorResponse> {
// 略: 例外からレスポンスクラスへの詰め替え処理 }
@ExceptionHandler(Exception::class) // ② fun handleOtherException(e: Exception): ResponseEntity<ErrorResponse> {
logger.error(e) // ③ return ResponseEntity(
ErrorResponse(e.message,e.errorCode), HttpStatus.INTERNAL_SERVER_ERROR // ④
) }
①ではユースケース層で投げられる例外である UseCaseException をキャッチしてい ます。このようにキャッチする例外のパターンを複数定義し、それ以外の例外は②のよう に例外の親クラスでキャッチします。この場合は想定外の例外なのでエラーログを出力し (③)、レスポンスのステータスコードは内部エラーを示すものにします (④)。
107
第 8章アーキテクチャ
8.2 外部システムへのアクセス 8.2.1 外部システムのクライアントクラスはどの層に書くべき？
  外部システムと連携する場合、その処理はどの層に実装すればよいでしょうか。  外部システムのクライアントオブジェクトのインターフェイスはドメイン層、実装クラ スはインフラ層に定義します。リクエスト/レスポンスの型はドメイン層です。 たとえば、Slack通知をする実装を考えてみます。ドメイン層には、次のオブジェクト
を定義します。
▼リスト 8.4 通知クラスとそのクライアントインターフェイス
data class Notification( val targetUserId: UserId, val message: String
)
interface NotificationClient { fun notify(notification: Notification)
}
この際、ドメイン層の知識として「通知をどう実現するか」に関心がない場合は、その 方法 (Slack)の知識はぼかして、「通知」という抽象的なクラスとして表現します。 そして、インフラ層に次のクラスを実装します。
▼リスト 8.5 通知クライアントの実装クラス
class SlackNotificationClient : NotificationClient { override fun notify(notification: Notification) {
// Slackで実際に通知を送信する実装 }
}
このクラス内で Slackの APIにリクエストを送信しますが、その実装の詳細 (どのよう なクライアントライブラリを使用するのか、など)はインフラ層に閉じ込めます。それに よりドメイン層は純粋に「通知を送信する」ということだけを意識すればよく、詳細な実
108
8.3 認証情報
装方法の影響をうけなくなります。
なお、通知方法が Slackであることがドメインの知識として重要な場合、ドメイン層の オブジェクトに Slack という名称を出しても問題ありません。たとえば、通知の種類が Slackとメールの 2つあり、それぞれのパターンを意識的に使い分けたい場合などです。 その場合も、通知を実行するための詳細はインフラ層に閉じ込めることは同様です。
8.3 認証情報 8.3.1 認証情報はどう扱えばよい？
  オニオンアーキテクチャで、ログインしているユーザーの情報はどのように取得、使 用すればよいでしょうか。  ユースケース層に認証情報を表すインターフェイスを定義し、その実装クラスをプレゼ ンテーション層に定義します。 ▼リスト 8.6 認証情報を表すインターフェイス
package dddfaq.usecase.shared.usersession
interface UserSession { val userId: UserId val userRole: UserRole
}
ユースケースクラスでは、次のように引数に渡します。 ▼リスト 8.7 認証情報を使用するユースケース
class SomeRequireSessionUseCase { fun execute(
userSession: UserSession // ① ) {
// userSessionを利用した何らかの処理 }
}
①のように、引数で渡すのがポイントです。これにより、次のようにユニットテストで 認証ユーザー情報をモックしやすくなります。
109
第 8章アーキテクチャ
▼リスト 8.8 認証情報をモックするテスト
/** テストで使用するUserSessionのモッククラス */ class MockUserSession( // ①
override val userId: UserId = UserId("1"), // ② override val userRole: UserRole = UserRole.NORMAL
) : UserSession
@Test fun `Adminロールでログインしている場合、xxxになる`() {
// given: Adminロールでログインしている時 val userSession = MockUserSession(userRole = UserRole.ADMIN) // ③
// when: val useCase = SomeRequireSessionUseCase() useCase.execute(userSession)
// then: // 何らかのアサーションを行う
}
①は、テスト用に UserSessionを実装したクラスです。このクラスは複数のテストで共 有します。 このクラスを使用するテストでは③のように実装します。②でデフォルト値が定義さ れているのため、テストに必要な値だけ指定すればよく、テスト観点が明示しやすくな ります。ここでは Admin ロールでログインしているユーザーのテストなので、引数で UserRole.ADMINを指定しています。 ユースケース層は、UserSessionという欲しい情報だけ定義し、認証の方法や使用する ライブラリの知識は一切持っていません。その知識はプレゼンテーション層に委譲して次 のように実装します。 ▼リスト 8.9 認証情報を提供するオブジェクトのインターフェイス
package dddfaq.presentation.shared.usersession
interface UserSessionProvider { // ① fun getUserSession(): UserSession
}
▼リスト 8.10 認証情報を提供するオブジェクトの参照元ユースケース
@RestController @RequestMapping("api/something") class SomeRequireSessionController(
private val someRequireSessionUseCase: SomeRequireSessionUseCase, private val userSessionProvider: UserSessionProvider
110
8.3 認証情報
) { @GetMapping fun doSomething() {
val userSession = userSessionProvider.getUserSession() // ② someRequireSessionUseCase.execute(userSession)
} }
① UserSession を提供するオブジェクトのインターフェイスを定義し、②コントロー ラーで userSessionを取得してユースケースクラスに引数で渡します。
UserSessionProviderをユースケースで直接使用せず、取得した値を引数で渡す理由は、 リスト 8.8のようにユースケースのユニットテストが書きやすくなるからです。
UserSessionProviderの実装クラスは次の通りです。
▼リスト 8.11 SpringSecurity を使用して認証情報を提供するクラス
package dddfaq.presentation.shared.usersession
class SpringSecuritySessionProvider : UserSessionProvider {
private data class SpringSecurityUserSession( // ① override val userId: UserId, override val userRole: UserRole
) : UserSession
override fun getUserSession(): UserSession { // ② SpringSecurityの仕組みから認証されている情報を取得し、 // SpringSecurityUserSessionに詰め替えて返す
} }
① UserSession を実装するクラス SpringSecurityUserSession は private インナーク ラスにして SpringSecuritySessionProvider 外で使用できなくしています。②では、詳 細は省略しますが、使用する認証ライブラリに応じた実装を行い認証情報を取得し、 SpringSecurityUserSessionに詰め替えて返します。 なお、UserSessionProviderにインターフェイスを定義する目的は、コントローラーの ユニットテストを書くときモックしやすくするためです。
111
第 8章アーキテクチャ
8.3.2 ユーザークラスを認証用クラスとして使用してよい？
  Userクラスの情報を使って認証するので、認証結果を扱うクラスとして使いまわし てよいでしょうか？  ドメイン層の Userクラスと、認証結果の情報を保持するクラスは分けて考えましょう。
前節のリスト 8.11 の SpringSecurityUserSession のような形です。プレゼンテーション 層で SpringSecurityUserSessionを組み立てる際にドメイン層の Userクラスを使用する 可能性がありますが、これは層の依存の向きとしては問題ありません。一方、Userクラ スは認証結果をどう扱うかという知識を持ってはいけません。
「ユーザー」クラスは認証に使う情報、その他のプロファイル情報などで肥大化しがち です。そのような場合はユーザーエンティティを分割し、別集約のオブジェクトとして切 り出すことを検討しましょう。集約の分割はコストが高いリファクタリングになるので、 モデリング段階から分離の要否を検討できるとよいでしょう。
▲図 8.1 ユーザーから情報を分離したオブジェクト
112
8.4 クエリモデル (軽量 CQRS)
8.4 クエリモデル (軽量 CQRS)
この説では、ドメインモデルとは別に、クエリ (参照)用のモデルを導入することにつ いて説明します。 モデリング/実装ガイドではこれを「CQRS」と表現しましたが、厳密な CQRSはデー タソース分離や永続化の形をイベント型にするなどを含むものであるため、それと区別す るために本書ではクエリモデル、もしくは軽量 CQRSと表現します。
8.4.1 ユーザー一覧をどう返す？
  ユーザーと他の集約の情報をまとめて出す一覧 API の実装方法について質問です。 ①ユーザーリポジトリに一覧を取得するメソッドを実装する②一覧用の集約を作る という方法では、どちらがよいでしょうか。  どちらでもありません。②の一覧用のモデルを「集約」ではなく「クエリモデル (参照
用モデル)」という位置付けにし、ドメインモデル (更新用モデル) とは分けて定義しま しょう。 集約は「必ずまとめて更新するオブジェクトのまとまり」なので、表示用の集約、とい うのは定義に反します。また、リポジトリは必ず集約単位で出し入れするので、他の集約 の情報を直接保持してはいけません。 複数集約をまたいで情報を効率的に取得したい場合は、クエリモデルの導入が適してい ます。クエリモデルのデータを取得するオブジェクトは、リポジトリとは別に「クエリ サービス」といった名称で定義します。
クエリモデルの具体例 具体例として、次のような集約があった場合を考えます。
113
第 8章アーキテクチャ
▲図 8.2 ユーザーと部署のドメインモデル図
ここで、ユーザーと所属する部署名をまとめて取得したい場合、次のようなクエリモデ ルを定義します。
▼リスト 8.12 ユーザーと部署名をまとめて返すクエリモデル
package dddfaq.usecase.user
/**ユーザーと部署名をまとめて返すクエリモデル */ data class UserAndDepartmentDto(
val userId: UserId, val userName: String, val departmentName: String // 他集約の情報
)
/** クエリモデルのクライアント */ interface UserAndDepartmentDtoQueryService {
fun fetchList(): List<UserAndDepartmentDto> }
クエリモデルは、ユースケースごとに最適な形が異なるため、ユースケース層に定義し ます。クエリサービスの実装クラスは、インフラ層で次のように実装します。
▼リスト 8.13 クエリサービスの実装クラス
package dddfaq.infra.queryservice
class UserAndDepartmentDtoJooqQueryService( private val jooq: DSLContext
) : UserAndDepartmentDtoQueryService { override fun fetchList(): List<UserAndDepartmentDto> {
jooq.select() // : ユーザーと部署のテーブルをjoinして1クエリで取得し、 // 結果をUserAndDepartmentDto型に詰め替えて返す
} }
クエリサービスは、ユースケースクラス内で呼び出すか、コントローラーから直接呼び 出します。クエリサービスの戻り値に対して何らかの加工が必要な場合や、規約としてコ
114
8.4 クエリモデル (軽量 CQRS)
ントローラーから呼び出すのはユースケースクラスで統一したい場合はユースケース内で 呼び出しましょう。
クエリモデルの使い所 複数集約の情報をまとめて返すために、常にクエリサービスが必要なわけではありませ ん。ユースケースクラス内で複数リポジトリを呼び、戻り値の型に詰め替える方法も検討 する必要があります。 クエリモデルの導入には次のメリットデメリットがあります。
• メリット – 複数集約にまたがるデータを取得する際のコードがシンプルになり、保守性が 高まる
– クエリパフォーマンスが上がる、チューニングしやすくなる – 複数集約の条件で絞り込んでのページングができるようになる
• デメリット – ドメインオブジェクトのデータが参照されている場所が追いにくくなる – アーキテクチャが複雑になり、理解にコストがかかる
このメリットデメリットを考慮して、クエリモデルの導入は必要最低限のところのみに するのがよいでしょう。 なお、クエリモデルについてはモデリング/実装ガイドの「8章 CQRS」でも詳しく解 説しているので、そちらもご参照ください。
8.4.2 参照系処理を全てクエリモデルにする必要がある？
  クエリモデルを導入したら、参照系は全てクエリモデルを使用しないといけないので しょうか？  厳密な CQRSではそのような方針をとることがありますが、一般的なWebアプリケー
ションではかかるコストに対してあまり大きなメリットを得られないことがあります。そ のような場合は、参照系の処理でも通常ではリポジトリを使用し、必要なところだけクエ リモデルを使用しましょう。 前節で解説したメリットデメリットを考慮し、更新系と参照系を全て分けることにこだ わらず、柔軟に判断するのがよいでしょう。
115
第 8章アーキテクチャ
8.4.3 クエリサービスにどこまでドメイン知識を持たせてよい？
  クエリサービスを使って複雑な条件で検索をする場合、ドメイン層/ユースケース層 のロジックがインフラ層に漏れ出てしまいます。何か対策はあるでしょうか。  クエリサービスでの条件指定方法を工夫することで、ある程度知識の漏出を防ぐことが できます。 まず、ドメイン層/ユースケース層のロジックがインフラ層に漏れ出ている具体例につ いて考えます。たとえば、次のようなクエリサービスがあったとします。ドメイン層の Taskクラスはユーザー ID、ステータス、期日を持っているものとします。
▼リスト 8.14 クエリサービスのインターフェイスとそれを使用するユースケース
// ユースケース層 interface TaskQueryService {
/**リマインド対象タスクの情報を取得します */ fun findRemindTarget(userId: UserId): List<TaskDto> // ①
}
class FetchRemindTargetUseCase(private val taskQueryService: TaskQueryService) { fun execute(userSession: UserSession): List<TaskDto> {
return taskQueryService.findRemindTarget(userSession.userId) }
}
▼リスト 8.15 クエリサービスの実装クラス
// インフラ層 class TaskRdbQueryService : TaskQueryService {
override fun findRemindTarget(userId: UserId): List<TaskDto> { // SQLで「タスクステータス = 未完了」と「期日 ＝ 過去日」で絞り込みを行う // ②
} }
①でクエリサービスのメソッドが「リマインド対象のタスク」を取得することを示して いますが、「リマインド対象とはどのような条件か」という知識がユースケース層からは 読み取れません。そして、インフラ層の②のコードに「リマインド対象とは、ステータス が未完了で期日が過去日のものである」という知識が実装されています。これがユース ケースの知識がインフラ層に漏れ出てしまっている状態です。
116
8.4 クエリモデル (軽量 CQRS)
これを避けるために、次のようにクエリサービスのメソッドを引数で条件を明確に指定 する実装にします。
▼リスト 8.16 タスククエリサービスのインターフェイスと参照元ユースケース
interface TaskQueryService { /** ステータスと期日を指定してタスク情報を取得します */ fun findByStatusAndDueDate( // ①
userId: UserId, taskStatus: TaskStatus dueDateBefore: LocalDate // この日付より前のものを取得
): List<TaskDto> }
class TaskRemindUseCase(private val taskQueryService: TaskQueryService) { fun execute(userSession: UserSession): List<TaskDto> {
return taskQueryService.findByStatusAndDueDate( // ② userId = userSession.userId, taskStatus = TaskStatus.UNDONE, dueDateBefore = LocalDate.now()
) }
}
①が、「リマインド対象」というドメイン知識の解釈が必要なものから、「ステータスと 期日の指定」という解釈が不要なものに変わりました。この条件を②のようにユースケー スで組み立てることにより、インフラ層にユースケースの知識が漏れ出るのを防ぐことが できました。
別の手段として、条件をメソッド名で表現する方法もあります。
▼リスト 8.17 タスククエリサービス条件をメソッド名で表現する場合
interface TaskQueryService { /**ステータスが未完了で期日が過去日のタスク情報を取得します */ fun findUndoneAndOverdue(userId: UserId): List<TaskDto>
}
これも名前で判断する形にはなりますが、エンティティが保持している属性の状態で指 定しているため、インフラ層に知識が漏れていません。 デメリットとして条件が増えるとクラス名が長くなりすぎてしまう点がありますが、メ リットとしてリスト 8.16の方法よりもクエリサービス内の分岐が減って実装がシンプル になる点があります。リスト 8.17では、TaskStatusが「DONE」の場合の検索を考慮し なくてよくなっています。 この 2つの方法はどちらでも実現可能なので、メリットデメリットを考慮して判断しま
117
第 8章アーキテクチャ
しょう。
8.5 それぞれの層の責務 8.5.1 ユースケースの戻り値クラスはどこに定義すればよい？
  ユースケースの戻り値を DTO というクラスで定義しました。そのクラスの置き場 所はどこにすべきでしょうか？  ユースケースクラスと同じパッケージや同じファイルに定義しましょう。DTOクラス
は、「ユースケースの戻り値」を表すのが責務なので、そのユースケースの近くに定義す るべきです。
▲図 8.3 よいパッケージ構成
非推奨なのは「dto」といったパッケージをくくり出してしまうことです。
▲図 8.4 悪いパッケージ構成
このような配置にすると、DTO とユースケースの関連が追いにくくなるというデメ リットが生まれるのに対して、あまり大きなメリットがありません。
118
8.5 それぞれの層の責務
8.5.2 ユースケースの戻り値クラスに書式変換メソッドを実装してよい？
  ユースケースの戻り値用のクラス (DTO)に表示に関するメソッド（数値の書式変換 など）を実装するのはありでしょうか？  いいえ、責務違反のため、非推奨です。ユースケースの戻り値用クラスはユースケース 層のクラスで、表示に関する処理はプレゼンテーションの責務です。表示用の変換処理 は、プレゼンテーション層のクラスで受け取った DTOに対して変換処理をする形で実装 します。ユースケースのクラスは、プレゼンテーション層が何であろうと影響がない実装 にした方が保守性が高まります。 クラスの責務 (何をするクラスなのか)をしっかり考え、その責務から外れた処理を書 かないように意識して実装することが大切です。
8.5.3 ユースケースからドメイン層のオブジェクトを返してもよい？
  ユースケースからの戻り値に、ドメイン層のクラスをそのまま使用してもよいでしょ うか。  よいですが、層の責務に違反した実装をしないように注意しましょう。 代表的な責務違反の例を紹介します。次のようなコントローラークラスがあったとし ます。
▼リスト 8.18 Taskエンティティを直接詰め替えるコントローラー
package dddfaq.presentation.task
/** コントローラーからの戻り値用クラス */ data class TaskView(val id: String, val dueDate: String)
/**コントローラークラス */ class TaskController(private val usecase: FetchTaskDetailUseCase) {
fun fetchTask(): TaskView { val task: Task = usecase.execute() // ① return TaskView( // ②
119
第 8章アーキテクチャ
id = task.id, dueDate = task.displayDate() // ③
) }
}
①ユースケースクラスが Taskエンティティをそのまま返し、② TaskViewクラスに詰 め替えています。その際、dueDateは③ドメイン層のメソッドを使用して書式を変換して います。これは次のような実装だとします。
▼リスト 8.19 書式変換メソッドを持つエンティティ
package dddfaq.domain.task
class Task(val id: String, val dueDate: LocalDate) {
/** dueDateをyyyy年MM月dd日フォーマットで返す */ fun displayDate(): String { // ①
val dtf = DateTimeFormatter.ofPattern("yyyy年MM月dd日") return dueDate.format(dtf)
} }
① Taskエンティティの displayDateメソッド内で書式を指定していますが、書式の変 換はプレゼンテーション層の責務であり、ドメイン層に実装するべきではありません。書 式のパターンが増える度に Taskエンティティのメソッドが膨らんでしまいます。
ドメイン層のオブジェクトがプレゼンテーション層で使用できてしまうと、このような メソッドを生やす誘惑に駆られることがあります。自分はこのような実装をしないと思っ ていても、別の実装者がしてしまう可能性もあります。 そのようなリスクを考慮した上で、ドメイン層のオブジェクトを返す可否、返してよい 条件などをチームのコーディング標準として言語化するとよいでしょう。
8.5.4 エンティティ/値オブジェクトはどの層で組み立てるべき？
  エンティティ、値オブジェクトのインスタンスをプレゼンテーション層で生成して ユースケース層に渡してもよいでしょうか。  原則的には、エンティティ/値オブジェクトの生成はユースケース層で行いましょう。
120
8.5 それぞれの層の責務
理由は、「渡された値をもとにドメインオブジェクトを生成し、リポジトリを使用して保 存する」という形でユースケースを実現するのがユースケースクラスの責務だからです。 その一部をプレゼンテーション層で行うと、プレゼンテーション層の凝集度が下がり、プ レゼンテーション層とユースケース層の結合度が上がるため、保守性が下がります。 ただし、値オブジェクトの組み立てに関しては、プレゼンテーション層が受け取った値 を変換しているだけであるという解釈は可能で、ユースケースへの引数がタイプセーフ になるというメリットがあるため、プレゼンテーション層での生成を許容してもよいで しょう。
8.5.5 cronからの呼び出しはどの層に書くべき？
  cronで定期的に処理を呼び出すような実装はどの層で行うのがよいでしょうか。  プレゼンテーション層で行いましょう。スケジュール実行の仕組みはユースケースの呼 び出し元の一つと解釈できます。 ユースケースクラスの引数と戻り値の型を特定のライブラリに依存しない抽象的な型 にしておくことで、呼び元が HTTPリクエストを受けるコントローラーだろうが、スケ ジュール実行する何らかの仕組みだろうが、ユースケースクラスには影響を及ぼさなくな ります。
8.5.6 ライブラリに依存してよいのはどの層まで？
  オニオンアーキテクチャにおいて、特定のライブラリやフレームワークに依存してよ いのはどの層まででしょうか？  ドメイン層とユースケース層では、極力特定のライブラリ、フレームワークに依存しな いようにしましょう。何かライブラリを使った処理を行いたい場合は、ドメイン層とユー スケース層ではインターフェイスのみ定義し、インフラ層に定義する実装クラスの中でラ イブラリを使用します。 ただし、一般的なWebアプリケーションの場合、DI(Dependency Injection)とトラン
121
第 8章アーキテクチャ
ザクション管理はWeb フレームワークの仕組みをそのまま使った方がシンプルになり、 保守性が上がることがあります。 たとえば Javaの Springフレームワークを使用する場合、DIはクラスにアノテーショ
ンを使って設定しますが、このアノテーションはドメイン層とユースケース層ともに DI 対象のクラスに直接付与します。また、トランザクションも専用のアノテーションをユー スケースクラスに付与します。これらは非常にシンプルで、アノテーションのみの実装で 動作してクラスのコード自体がライブラリの影響を受けにくいため、ドメイン層/ユース ケース層で依存を許容するメリットが大きいです。 一方、プレゼンテーション層は、Webアプリケーションの場合エンドポイントの定義 やリクエストのパース方法などは完全にWebフレームワーク依存の実装になります。こ れは問題ないことで、むしろフレームワーク依存の実装をユースケース層などに波及させ ずにプレゼンテーション層に閉じ込めることが重要です。
8.5.7 トランザクションはどう扱えばよい？
  オニオンアーキテクチャでトランザクション処理はどのように管理すればよいでしょ うか？  ユースケースクラスのメソッド入り口でトランザクションを開始し、メソッドが正常終 了したらコミット、例外が発生したらロールバック、とします。 前節で解説した通り、トランザクション管理の実装はある程度ユースケースクラスが
Webフレームワークに依存した記述になる場合があります。
8.6 アーキテクチャその他 8.6.1 ユースケースからユースケースを呼んでよい？
  ユースケースクラスから別のユースケースクラスを呼んでもよいでしょうか。  推奨しません。ユースケース同士の参照を許してしまうと、複雑な処理では 1つのユー
スケースから別のユースケースを呼び出していく階層が深まり、コードを読む際に全体像
122
8.6 アーキテクチャその他
を追うのが難しくなるためです。 そのため、
• コントローラーから呼ばれるユースケースクラスは必ず 1つのみ
• 複数ユースケースクラスから呼ばれる処理はユースケース層に独立クラスを定義し て、ユースケースクラスから参照させる
という方針をおすすめします。独立クラスの例は、何らかのデータを取得する処理を持 つクラスであれば XxxFetcher、変換する処理を持つクラスであれば XxxConverterなど です。参照関係は次の図のようになります。
▲図 8.5 レイヤーと独立クラス
この設計は再利用性が高まるだけでなく、独立クラスとユースケースクラスそれぞれの 凝集度が高くなり、可読性やテスト容易性が向上するというメリットがあります。
123
第 8章アーキテクチャ
8.6.2 複数集約で使用されるオブジェクトはどこに定義する？
  ドメイン層で複数の集約にまたがって参照されるオブジェクトは、どのようなパッ ケージに配置すればよいでしょうか。  2つの方法があります。
• ① そのオブジェクトを定義するパッケージに配置する
• ② 共有パッケージに配置する
①の例として、UserStatusというオブジェクトを Userエンティティがプロパティとし て保持し、Taskエンティティではある処理の分岐で使用しているとします。これは User 集約の中で UserStatusを定義し、Task集約からはそれを参照しているという関係性にな ります。その場合は、Userと UserStatusを userパッケージに配置し、どこで定義され ているかをパッケージで示します。 ②は、特定の集約で定義されているわけではない抽象的なもの、たとえば日付を表すク ラスや IDの基底クラスなどは、「shared」といった共有パッケージを定義しそこに配置し ます。 複数集約から参照するからと言ってなんでも共有パッケージに配置してしまうと、「定 義する側」「参照する側」という関係が見えなくなってしまいます。きちんとどこで定義 されているかを意識してパッケージ配置することが重要です。
8.6.3 「業務ロジック」とは？
  業務ロジックをドメイン層に書こうと思いますが、どこまでが業務ロジックなのかが よくわからず、何をどの層に実装すればよいか判断に迷ってしまいます。どう判断す ればよいでしょうか。  「業務ロジック」という言葉が示す意味合いが広すぎるので、より詳細化した次のよう な言葉で使い分けると判断しやすくなります。
124
8.6 アーキテクチャその他
• ドメイン知識：ソフトウェアを適用して問題解決しようとする領域 (ドメイン) に 存在するルール/制約。ソフトウェアがなくても存在し、ユースケースによって変 わることがない。ドメインモデル図に表される。
• ユースケース：ユーザーが「ソフトウェアで」行えるアクション。ソフトウェアが なくなったら存在しなくなるもの。ユースケース図に表される。
• 表示に関する知識：書式や見た目など、表示時のルール
このように分けると、上からドメイン層、ユースケース層、プレゼンテーション層がそ れぞれの実現の責務を持っている、と切り分けられます。あとは、「処理内容が上記のど れにあたるかを考え、該当するレイヤーに書く」という方針を持つと、どのレイヤーに実 装するべきかが判断できます。
8.6.4 1つのアプリケーションで DDDのアーキテクチャとそうでないも のを混在させてよい？
  一つの開発プロジェクトに DDD の実装パターンとトランザクションスクリプトで 実装した処理を混在させてもよいでしょうか。  新規プロジェクトであれば、混乱のもとになるのでどちらかに統一した方がよいで しょう。 一方、DDD思想に則っていない既存のプロジェクトに導入する場合、部分的に DDD
の実装を適用することはあります。その際、DDDの実装を適用する基準、実装時のルー ルを言語化しておきましょう。基準やルールがないと、複数の書き方が混在してより大き な混乱を招いてしまう可能性があります。
8.6.5 クリーンアーキテクチャの「エンティティ」との違いは？
  クリーンアーキテクチャにおけるエンティティと DDD におけるエンティティは同 じものでしょうか？  いいえ、別のものを指します。
125
第 8章アーキテクチャ
DDDではドメイン層の中に「エンティティ」、値オブジェクト、リポジトリなどを定義 します。クリーンアーキテクチャにおける「エンティティ」層は、「企業全体で使用する (Enterprise Wide)ビジネスルールをカプセル化する層」とあり、異なる定義です。 また、DDDの境界づけられたコンテキストという概念では、「同じ企業の中でもコンテ キストが違えばモデルを明確に分ける」としているので、「企業全体で使用するビジネス ルール」という概念とは相反する部分があります。 そのように思想の違いが多少ありますが、クリーンアーキテクチャで DDDを実装する
にあたっては多少解釈を柔軟にし、「エンティティ層」は「ドメイン層」と読み替えるな どで対応は可能です。
8.6.6 インターフェイスを定義するメリットは？
  インターフェイスに対して複数実装クラスが定義されることがない場合、インター フェイスを定義するメリットはありますか？  インターフェイスにより依存関係の方向を制御することで、レイヤーの責務を遵守する のに利用できます。 例として、オニオンアーキテクチャにおけるリポジトリのインターフェイスと実装クラ ス、ユースケースクラスの関係を考えます。
126
8.6 アーキテクチャその他
▲図 8.6 インターフェイスによる依存方向の制御
リポジトリのインターフェイスはドメイン層に、その実装クラスはインフラ層に定義し ます。こうすることにより、ドメイン層やユースケース層のクラスが特定のインフラ知識 (データソースやライブラリなど)に依存しない実装になり、レイヤーの責務を遵守できま す。レイヤーの責務を遵守することにより、一般に可読性やテスト容易性を向上させるこ とができます。
8.6.7 ファーストクラスコレクションはどこに定義すべき？
  エンティティの Listを内包するファーストクラスコレクションは、ドメイン層に定 義してもよいでしょうか？ たとえばユーザー一覧を表示するための UserListといっ たクラスを定義する形です。  エンティティの集合に対してファーストクラスコレクションを作成し、ドメイン層に定 義するのは問題ありません。 ただし、そのクラスは特定のユースケースに依存したものになってはいけません。つま り、ユーザー一覧画面用のコレクション、別のユーザー操作画面用のコレクション、とい うようなクラスをドメイン層に定義してはいけません。ユースケースの知識は、ユース ケース層に留めるべきなので、それらのクラスはユースケース層に定義しましょう。
127
第 8章アーキテクチャ
ドメイン層では特定のユースケースに依存しない、抽象的な意味での「ユーザーの集 合」として定義するべきです。
▼リスト 8.20 ユーザーのファーストクラスコレクション
package dddfaq.domain.user
data class Users(val value: List<User>) { fun extractUserIds(): List<UserId> {
return value.map { it.id } // 全てのUserに対して、IDだけ抽出して返す }
}
このように、内部のオブジェクトの集合に対する抽象的な操作であれば、ユースケース 層に依存しないのでドメイン層のオブジェクトの振る舞いとしてよいでしょう。
128
第 9章
その他
本章では、プログラミング一般の質問に対して解説します。
9.1 プログラミング一般 9.1.1 オブジェクト指向である必要はある？
  DDDの実装をするのにオブジェクト指向である必要はありますか、関数型ではでき ないでしょうか。  DDD の実装パターンの主要な目的は「高凝集/低結合な実装にし、保守性を高めるこ と」と「ドメインモデルと実装を乖離させず、ドメインモデルの更新に実装を追従しやす くすること」です。 このうち後者の目的を達成するのにオブジェクト指向は相性がよいため、DDDではオ
ブジェクト指向を用いた実装パターンが紹介されています。しかし、目的が達成できるの であれば、関数型でも手続き型でも問題はありません。
9.1.2 1ファイルに複数クラスを定義してもよい？
  DDDで、1つのファイルの中に複数クラスを定義してもよいでしょうか？ 
129
第 9章その他
DDDではクラスとファイルの切り方に関する言及はありません。メリットデメリット を比較して判断できればよいでしょう。
1ファイルに複数クラスを定義するメリットは、意味的に関連があるものをまとめると 関連がわかりやすくなることです。集約が同じクラスや、ユースケースクラスとそのパラ メーターを表すクラスなどです。 一方、意味的に関係のないクラス同士は、同じファイルにして行数が増えると可読性が 下がるので、別のファイルに定義した方がよいでしょう。
9.1.3 エンティティをイミュータブルな実装にしてもよい？
  エンティティをイミュータブルな実装にしてもよいでしょうか？  はい、問題ありません。 オブジェクトをイミュータブル、つまり内部状態を変えない実装にすることで可読性や マルチスレッド対応性が向上することがあります。エンティティはモデリング上の定義は ミュータブルなものですが、実装方法をイミュータブルにすることは可能です。 その場合は、エンティティは次のような実装になります。
▼リスト 9.1 イミュータブルなエンティティ
class Task private constructor( val id: TaskId, val name: TaskName, val status: TaskStatus
) { /**タスクを完了させます */ fun done(): Task { // ①
return Task( id = this.id, name = this.name, status = TaskStatus.DONE
) }
}
①タスクを完了させるメソッドは、内部状態を変更するのではなく新しい状態のインス タンスを返します。 このエンティティを使用するユースケースは次のようになります。あわせて、イミュー タブルな実装にするメリットも解説します。
130
9.1 プログラミング一般
▼リスト 9.2 イミュータブルなエンティティを使用するユースケース
class DoneTaskUseCase( private val taskRepository: TaskRepository, private val someProcess: SomeProcess
) { fun execute(taskId: TaskId) {
val foundTask: Task = taskRepository.findById(taskId) // ① val doneTask: Task = foundTask.done() // ② someProcess.doSomething(doneTask) // ③ taskRepository.update(doneTask) // ④
} }
①リポジトリからタスクインスタンスを取得します*1。そこから② doneメソッドで完 了状態のタスクインスタンスを新しく生成し、④で保存しています。 この時のメリットとして、③でタスクに関して何らかの処理が行われていますが、②の タスクの内部状態には影響を及ぼさないことが確実に読み取れるという点です。 このようなメリットを重視する場合は、エンティティをイミュータブルな実装にしても よいでしょう。
9.1.4 オブジェクトで値の詰め替えをするのがつらい
  オブジェクト同士で値の詰め替えをするのがつらいのですが、どうしたらよいで すか？  マルチカーソル機能があるエディタであれば、比較的簡単に実装できます。動画を交え た解説があるので、次のブログ記事をご参照ください。 「オブジェクト詰め替えが面倒くさい？ マルチカーソルを使えば 10 秒でできます」
<https://little-hands.hatenablog.com/entry/2021/09/27/multicursor>
オニオンアーキテクチャなどの階層化されたアーキテクチャでは、レイヤーの境界でオ ブジェクトの値を詰め替える必要性が発生します。詰め替えにより属性の依存関係を整理 し、保守性を高めることに大きく貢献するのですが、単調作業に感じるせいか嫌われるこ とがあります。
*1 戻り値が nullだった時の処理は省略しています
131
第 9章その他
面倒だからと言って詰め替えを妥協し、やめてしまうことがありますが、長期的に考え るとそれは良い判断ではありません。なぜなら、初期実装の数分の重要性より、その後の 保守性の重要性の方が圧倒的に高いからです。 上記記事の手法を用いると手間をかなり軽減できるので、初期の面倒くささに負けて妥 協しないようにしましょう。
132
著者紹介
著者紹介 文章: 松岡幸一郎 (@little_hand_s) 株式会社ログラス所属。 DDDやアジャイルプラクティスに関して書籍、質問箱、ブログ、YouTubeなどで発信
しています。 ドメイン駆動設計モデリング/実装ガイド: <https://little-hands.booth.pm/items/1835632> ブログ: <https://little-hands.hatenablog.com/> twitter: <https://twitter.com/little_hand_s> (プロフィールに質問箱、YouTubeなど へのリンクがあります)
表紙・挿絵: 岡本ちひろ (@haco_kiwi) 絵を描いています。とりが好きです。
133
付録著者紹介
謝辞 本書の執筆にあたっては、多くの方のお世話になりました。 飯田意己 (@ysk_118)さん、勝丸真さん (@shin1988)、佐藤有斗 (@Yuiiitoto)さん、成
瀬允宣 (@nrslib)さん、ミノ駆動 (@MinoDriven)さん、和田卓人 (@t_wada)さん（五 十音順）には、本書のレビュアーとしてご協力いただきました。皆様からの的確なフィー ドバックのおかげで、本書の内容を大きく改善することができました。どうもありがとう ございました。
134
135
ドメイン駆動設計サンプルコード&FAQ
2021年 10月 30日　初版第 1刷　発行
著　者 松岡 幸一郎 発行所 little_hand_s 印刷所 有限会社 ねこのしっぽ

(C) 2021 @little_hand_s
136
137
