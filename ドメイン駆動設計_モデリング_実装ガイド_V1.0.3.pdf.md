ドメイン駆動設計モデリング/実装 ガイド
松岡幸一郎　著
2020-03-01版 little_hand_s 発行
1
はじめに
本書は、初めて DDDを学ぶ方、もしくは実際に着手して「難しい！！」と感じている エンジニアの方を対象とした、ドメイン駆動設計 (以下、DDD)についての解説書です。
近年、ソフトウェアのレガシー化が社会的に問題になっていると言われています。DDD はレガシー化への対策として非常に有用なものですが、日本語で出ている書籍「エリッ ク・エヴァンスのドメイン駆動設計*1」(以下、エヴァンス本) や「実践ドメイン駆動設 計*2」(以下、実践 DDD)は非常に重厚かつ難解で、初学者が実用に到達するまでには長 い時間と試行錯誤が必要なのが実情です。
そこで本書では、迷子になりがちな「DDDの目的」や「モデル」の解説からはじめ、具 体的なモデリングを行い実装まで落とす事例を元に、DDDの魅力や効果を体感すること を目指します。また、その後にはレイヤーごとの個別のトピックについて、1章ずつ詳し く解説します。
*1 <https://www.amazon.co.jp/dp/4798121967/> *2 <https://www.amazon.co.jp/dp/479813161X/>
2
本書の構成 本書は以下の構成になっています。 「第 1章 DDD概要」では、DDDの目的、アプローチの全体像を解説します。 「第 2章 モデリングから実装まで」では、モデルを作成し、実装に落とし込むまでを具 体的な事例で解説することにより、DDDの全体像や効果を体感することを目指します。 「第 3章 DDD固有のモデリング手法」では、モデリングをする上で必要となる、DDD 固有の概念について解説します。 「第 4章 設計の基本原則」では、設計/実装時に常に意識すべき原則を解説します。 「第 5章 アーキテクチャ」から「第 10章 アーキテクチャ全般・ライブラリなど」では、 アーキテクチャの各レイヤー、トピックごとに実装時の具体的な解説をしていきます。 「第 11章 困った時には」では、本書を読んだ後、実践する上でさらなる調査をする際 に参考になる情報をお伝えします。 各章の末尾には、これまで実際に寄せられた質問を元に、Q＆ Aを作成しました。手 を動かして実際に突き当たったリアルな質問は、読者の方の疑問を先回りしてくれるかも しれません。
免責事項 本書に記載された内容は、情報の提供のみを目的としています。したがって、本書を用 いた開発、運用は、必ずご自身の責任と判断によって行ってください。これらの情報によ る開発、運用の結果について、著者はいかなる責任も負いません。
3
目次
はじめに 2 本書の構成 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 免責事項 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
第 1章 DDD概要 10 1.1 言葉の定義 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 1.2 DDDとは . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 1.3 モデルとは . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
1.3.1 定義 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 1.3.2 モデルの例 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
1.4 良いモデル、良くないモデル . . . . . . . . . . . . . . . . . . . . . . . 12 1.4.1 良いモデルとは . . . . . . . . . . . . . . . . . . . . . . . . . . 12 1.4.2 良くないモデルの例 . . . . . . . . . . . . . . . . . . . . . . . . 13
1.5 良いモデルを作るには . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 1.5.1 ドメインエキスパートと会話する . . . . . . . . . . . . . . . . . 14 1.5.2 運用して得られた発見をモデルに還元する . . . . . . . . . . . . 15
1.6 DDDの問題解決のアプローチ . . . . . . . . . . . . . . . . . . . . . . . 15 1.6.1 モデルの継続的な改善 . . . . . . . . . . . . . . . . . . . . . . . 16 1.6.2 モデルからソフトウェアへの継続的な反映 . . . . . . . . . . . . 18
1.7 取り組む上で重要な考え方 . . . . . . . . . . . . . . . . . . . . . . . . . 19 1.7.1 課題ドリブン . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 1.7.2 小さく初めて、小さく失敗する . . . . . . . . . . . . . . . . . . 19
1.8 Q&A . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 1.8.1 DDDの向き・不向き . . . . . . . . . . . . . . . . . . . . . . . 20
第 2章 モデリングから実装まで 21
4
2.1 ドメインモデリング . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 2.1.1 ユースケース図 . . . . . . . . . . . . . . . . . . . . . . . . . . 21 2.1.2 ドメインモデル図 . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.2 ドメインモデルの実装 . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 2.2.1 アーキテクチャ . . . . . . . . . . . . . . . . . . . . . . . . . . 25 2.2.2 ドメインモデル貧血症のコード . . . . . . . . . . . . . . . . . . 26 2.2.3 ドメインモデル貧血症のコードの問題点 . . . . . . . . . . . . . 27 2.2.4 ドメインモデルの知識を表現した実装 . . . . . . . . . . . . . . . 29
2.3 ドメイン層オブジェクト設計の基本方針 . . . . . . . . . . . . . . . . . . 32 2.3.1 ドメインモデルの知識を対応するオブジェクトに書く . . . . . . 32 2.3.2 常に正しいインスタンスしか存在させない . . . . . . . . . . . . 32
2.4 実際の開発の進め方 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 2.5 Q&A . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
2.5.1 ユビキタス言語の管理方法 . . . . . . . . . . . . . . . . . . . . . 34 2.5.2 モデリングにかける時間 . . . . . . . . . . . . . . . . . . . . . . 35 2.5.3 ドメインモデル図の更新頻度 . . . . . . . . . . . . . . . . . . . 35 2.5.4 モデリング時に作成するその他の成果物 . . . . . . . . . . . . . 36 2.5.5 ユースケース図を使う理由 . . . . . . . . . . . . . . . . . . . . . 36 2.5.6 他のモデリング手法との違い . . . . . . . . . . . . . . . . . . . 37
第 3章 DDD固有のモデリング手法 38 3.1 集約 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
3.1.1 集約とは . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 3.1.2 設計/実装時のルール . . . . . . . . . . . . . . . . . . . . . . . 38 3.1.3 集約の境界の決め方 . . . . . . . . . . . . . . . . . . . . . . . . 40
3.2 境界づけられたコンテキスト . . . . . . . . . . . . . . . . . . . . . . . 41 3.2.1 境界づけられたコンテキストの概念 . . . . . . . . . . . . . . . . 41 3.2.2 境界づけられたコンテキストの実装 . . . . . . . . . . . . . . . . 45
3.3 Q&A . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 3.3.1 DBへの意識 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 3.3.2 集約とトランザクション . . . . . . . . . . . . . . . . . . . . . . 46
第 4章 設計の基本原則 47 4.1 凝集度・結合度について . . . . . . . . . . . . . . . . . . . . . . . . . . 47 4.2 凝集度 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
5
目次
4.2.1 定義 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48 4.2.2 低凝集な実装 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48 4.2.3 高凝集な実装 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
4.3 結合度 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 4.3.1 定義 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 4.3.2 高結合な実装 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 4.3.3 低結合な実装 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
4.4 今後の章との関連 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
第 5章 アーキテクチャ 52 5.1 3層アーキテクチャ . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
5.1.1 タスク管理アプリケーションの例 . . . . . . . . . . . . . . . . . 53 5.2 レイヤードアーキテクチャ . . . . . . . . . . . . . . . . . . . . . . . . . 55 5.3 オニオンアーキテクチャ . . . . . . . . . . . . . . . . . . . . . . . . . . 56
5.3.1 レイヤーごとの責務 . . . . . . . . . . . . . . . . . . . . . . . . 56 5.3.2 丸型の表記 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
5.4 ヘキサゴナルアーキテクチャ . . . . . . . . . . . . . . . . . . . . . . . 60 5.5 クリーンアーキテクチャ . . . . . . . . . . . . . . . . . . . . . . . . . . 61 5.6 オニオンアーキテクチャ、クリーンアーキテクチャの比較 . . . . . . . . 61
5.6.1 シンプルさ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62 5.6.2 レイヤーの責務の思想の違い . . . . . . . . . . . . . . . . . . . 62
5.7 境界づけられたコンテキストの実装 . . . . . . . . . . . . . . . . . . . . 62 5.7.1 1コンテキスト 1アプリケーションの場合 . . . . . . . . . . . . 63 5.7.2 1コンテキスト 1アプリケーション以外の場合 . . . . . . . . . . 64
第 6章 ドメイン層の実装 66 6.1 エンティティ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67 6.2 値オブジェクト . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67 6.3 ドメインサービス . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 6.4 リポジトリ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 6.5 ファクトリー . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 6.6 ドメイン層のそれ以外のオブジェクト . . . . . . . . . . . . . . . . . . . 69 6.7 複数集約間の整合性確保 . . . . . . . . . . . . . . . . . . . . . . . . . . 70 6.8 Q&A(ドメインオブジェクト) . . . . . . . . . . . . . . . . . . . . . . . 70
6.8.1 ドメイン層にロジックを寄せる目的 . . . . . . . . . . . . . . . . 70
6
6.8.2 プリミティブ型の使用可否 . . . . . . . . . . . . . . . . . . . . . 71 6.8.3 DBの値からインスタンスを再構成する方法 . . . . . . . . . . . 71 6.8.4 再構成メソッドを書くべきレイヤー . . . . . . . . . . . . . . . . 72
6.9 Q&A(リポジトリ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72 6.9.1 ドメインオブジェクトと DBの対応 . . . . . . . . . . . . . . . . 72 6.9.2 ソートの実装方法 . . . . . . . . . . . . . . . . . . . . . . . . . 73 6.9.3 キャッシュの実装方法 . . . . . . . . . . . . . . . . . . . . . . . 73 6.9.4 外部 APIとリポジトリの関係 . . . . . . . . . . . . . . . . . . . 73 6.9.5 外部 APIから取得した値の詰め替え方法 . . . . . . . . . . . . . 74 6.9.6 エンティティ同士の紐付け . . . . . . . . . . . . . . . . . . . . . 74 6.9.7 リポジトリのインターフェイスを定義するレイヤー . . . . . . . 74 6.9.8 一部カラムを更新するときの扱い . . . . . . . . . . . . . . . . . 75 6.9.9 ドメインオブジェクトからリポジトリ操作の可否 . . . . . . . . . 75
6.10 Q&A(その他) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75 6.10.1 ドメインサービスの命名 . . . . . . . . . . . . . . . . . . . . . . 75 6.10.2 リポジトリを通じた削除方法 . . . . . . . . . . . . . . . . . . . 76
第 7章 ユースケース (アプリケーション)層の実装 77 7.1 ユースケース . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 7.2 ユースケースからの戻り値クラス . . . . . . . . . . . . . . . . . . . . . 78 7.3 Q&A . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
7.3.1 クラスの分割単位 . . . . . . . . . . . . . . . . . . . . . . . . . 79 7.3.2 命名規則 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
第 8章 CQRS 81 8.1 DDDの参照系処理で発生する問題 . . . . . . . . . . . . . . . . . . . . 81 8.2 解決策 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
8.2.1 参照用モデルの型を定義するレイヤー . . . . . . . . . . . . . . . 84 8.3 メリット、デメリット . . . . . . . . . . . . . . . . . . . . . . . . . . . 85 8.4 実装時の注意事項 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
8.4.1 部分的導入の可否 . . . . . . . . . . . . . . . . . . . . . . . . . 85 8.4.2 型を定義するレイヤーがユースケース層である理由 . . . . . . . 86 8.4.3 更新系との整合性を確保する方法 . . . . . . . . . . . . . . . . . 87
8.5 よくある誤解 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87 8.5.1 データソース分離の必要性 . . . . . . . . . . . . . . . . . . . . . 87
7
目次
8.5.2 イベントソーシングとの関係 . . . . . . . . . . . . . . . . . . . 88 8.6 Q&A . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
8.6.1 クエリサービスの分割判断 . . . . . . . . . . . . . . . . . . . . . 88 8.6.2 DTOとして返した値の扱い . . . . . . . . . . . . . . . . . . . . 88 8.6.3 参照用モデルの使い所 . . . . . . . . . . . . . . . . . . . . . . . 89 8.6.4 実装の都合にドメイン層が影響を受ける場合 . . . . . . . . . . . 89 8.6.5 集約内の一部の値だけ取得したい場合の対応方法 . . . . . . . . . 89
第 9章 プレゼンテーション層の実装 91 9.1 プレゼンテーション層の処理概要 . . . . . . . . . . . . . . . . . . . . . 91 9.2 プレゼンテーション層のクラス、ファイル . . . . . . . . . . . . . . . . 92 9.3 リクエスト仕様の定義 . . . . . . . . . . . . . . . . . . . . . . . . . . . 92 9.4 レスポンス仕様の定義 . . . . . . . . . . . . . . . . . . . . . . . . . . . 92 9.5 Q&A . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
9.5.1 コントローラーの処理内容 . . . . . . . . . . . . . . . . . . . . . 95 9.5.2 プレゼンテーション層における値オブジェクト生成 . . . . . . . 95
第 10章 アーキテクチャ全般・ライブラリなど 96 10.1 例外処理 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
10.1.1 例外の種類 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96 10.1.2 バリデーション内容の重複 . . . . . . . . . . . . . . . . . . . . . 98 10.1.3 処理結果を例外で表現しない場合 . . . . . . . . . . . . . . . . . 99
10.2 パッケージ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99 10.3 Webフレームワークへの依存 . . . . . . . . . . . . . . . . . . . . . . . 101 10.4 ORマッパー . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102 10.5 言語 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104 10.6 Q&A . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
10.6.1 アーキテクチャの部分適用 . . . . . . . . . . . . . . . . . . . . . 104
第 11章 困った時には 105 11.1 ドメイン駆動設計入門 . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 11.2 実践ドメイン駆動設計 . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 11.3 英語で検索 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106 11.4 DDD Community Jp . . . . . . . . . . . . . . . . . . . . . . . . . . . 106 11.5 筆者に質問 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
8
著者紹介 107
9
第 1章
DDD概要
本章では、DDDの目的、アプローチの全体像を解説します。その中で、重要な概念「モ デル」について解説し、モデルがコードとどう繋がるかを示します。
1.1 言葉の定義 DDD に取り組むにあたって、最初に陥りやすいのが言葉の定義による混乱です。「ド メイン」という単語一つとっても、人によって捉えている意味が全く異なっていることが あります。 本書では、言葉の定義については著者一覧に Eric Evansも名前を連ねている Domain-
Language.com*1というサイトにある、DDD Reference*2というドキュメントの定義を正 とします。
DDD Reference は、DDD に関する単語の定義や重要なエッセンスをまとめた PDF ファイルになっており、エヴァンス本にかなり比べてコンパクトにまとまっているので、 ぜひ参考にしてみてください。(全部英語ですが、苦手な人は Google 翻訳の力を借りま しょう)
1.2 DDDとは DDDとは、そもそも何なのでしょうか。その定義を確認しましょう。 まず、抽象的な定義としては、DDDはソフトウェア開発手法の一つです。何らかのア プローチをもって、ソフトウェアを効果的、効率的に開発することを目指すものです。 それでは、人々はなぜ、ソフトウェアを開発するのでしょうか？ それは、ソフトウェ
*1 <https://domainlanguage.com/>*2 <https://domainlanguage.com/ddd/reference/>
10
1.3 モデルとは
アによって、ある領域に存在する特定の問題を解決するためと言えるでしょう。この「ソ フトウェアで問題解決しようとする対象領域」を「ドメイン」と呼びます。 問題解決のために、DDDでは次のようなアプローチをします。
Many projects do modeling work without getting much real benefit in the end. The patterns of DDD distill successful practices from projects where dramatic benefits have come from modeling. 多くのプロジェクトは、モデリングを行っても最終的に大きな利益を得られないま ま終わります。DDDは、モデリングから劇的な利益を得られたプロジェクトから、 成功するパターンを抽出します。(DDD Referenceより)
つまり、DDDはモデリングによってソフトウェアの価値を高めることを目指す開発手 法ということです。モデリングとはモデルを作成する活動のことですが、「モデルとは何 か」については次の節で解説します。 ここで、「あれ、アーキテクチャや、コードの話が出てこない？」と疑問に思う方もい らっしゃるでしょう。「コード品質を上げること」を目的として DDDを導入検討される ことがありますが、本来の目的はそれだけではありません。コード品質を上げたその先ま でが、DDDの目指すところなのです。 もちろん、コードの話もスコープには入っています。本章では、モデルの解説に続い て、モデルとコードとのつながりについても解説します。
1.3 モデルとは 1.3.1 定義 モデルとはなんでしょうか。この言葉も文脈によって大きく異なる意味で使われる言葉 です。ここでも DDD Referenceの定義を引用しましょう。
model:A system of abstractions that describes selected aspects of a domain and can be used to solve problems related to that domain 問題解決のために、物事の特定の側面を抽象化したもの (意訳)
本書では、この定義を採用します。
なお、モデルにはさまざまな種類があり、目的によって使い分けられます。DDDの文 脈で頻出し、混乱しやすいのは次の 2種類のモデルです。
• ドメインモデル： ドメインの問題を解決するためのモデル
11
第 1章 DDD概要
• データモデル： データの永続化方法を決める (永続化方法の効率化という問題解決 を行う)ためのモデル
本書では「モデル」という記述が頻出しますが、記述の簡略化のために単に「モデル」 と記載した場合はいずれも「ドメインモデル」を指すものとします。
1.3.2 モデルの例 定義を確認しましたが、抽象的でイメージが湧きにくいので、具体例を用いて解説し ます。 ソフトウェアを構築するために、「履歴書」のモデルを作成するものとします。実際に 履歴書を書いた時のことを思い出してみてください。履歴書から要素を抽出すると、どう いったものが考えられるでしょうか。
• 名前
• 経歴
• 志望理由
• 顔写真
と言った要素はすぐに思いつくでしょう。しかし、現実の履歴書には、次のような要素 も含まれます。
• 筆跡、筆圧
• 履歴書のメーカー
• 履歴書を書いた時の気持ち
しかし、このような要素すべてをソフトウェアに落とし込むことは不可能ですね。問題 を解決するために、必要な要素はモデルに取り込みたいですし、不要な要素は取り込みた くありません。 ここで、「どの要素を取り込むか」という選択をすることになります。この取捨選択の プロセスが抽象化であり、その成果物がモデルということになります。
1.4 良いモデル、良くないモデル 1.4.1 良いモデルとは 良いモデルとは、どのようなモデルでしょうか。 このような質問をすると、わかりやすいモデル、粒度が適切なモデル、拡張性のあるモ
12
1.4 良いモデル、良くないモデル
デル…と言ったことが挙げられることがあります。 しかし、「問題解決のために、物事の特定の側面を抽象化したもの」という定義から考 えると、「良いモデルとは、問題を解決できるモデルである」と言えるでしょう。いかに 理解しやすく、美しく見えても、問題が解決できなければ、それは目的を達成できない、 良くないモデルということになります。
1.4.2 良くないモデルの例 例として、人事担当者の採用管理 (会社の採用選考に応募して来た人の管理)のアプリ
ケーションを考えます。 人事担当者は採用管理業務をスプレッドシートを使用した手入力による運用で行なって いましたが、ミスの発生や作業効率の悪さが問題になっていました。そこで、アプリケー ションを開発して運用をシステム化することにより、この問題を解決することを目指し ます。 実装を行うために、図 1.1のようなモデルを考えました。(なお、記法に関しては「第 2 章 2.1.2 ドメインモデル図」で詳しく解説します。ここでは「モデル図に採用選考に関す るルール/制約が記載されており、それに基づいて実装を行う」ぐらいの理解で読み進め てください。)
▲図 1.1 採用選考モデル図
あらかじめ求人が登録されており、それに対して応募者、採用選考というものが登録さ れます。採用選考のステータスは「書類選考→ 1次面接→ 2次面接→最終面接→内定」と いうステップを辿ります。 このモデルを元に実装し、アプリケーションを現場で運用したところ、次のような問題
13
第 1章 DDD概要
が発生しました。
• 書類選考の前に面談があるのに、設定できない
• 面接は 3次、4次もあるのに、追加できない
• 求人関係ない応募も許可したいのに、設定できない
これでは、現場の運用に適用できません。つまり、もともと目指していた問題解決がで きないということです。
もし、このアプリケーションの実装が、可読性や拡張性が高く、自動テストも完璧でバ グが全く出ないようなものだったとしましょう。そのアプリケーションは高い価値を生み 出せるでしょうか？ いいえ、そうはなりませんね。モデルが良くないと、実装がどんなに素晴らしくても良
い (問題解決ができる)ソフトウェアにはならないのです。
1.5 良いモデルを作るには 良いモデルを作るにはどうすれば良いのでしょうか？ 重要な 2つのアプローチがあります。
• ドメインエキスパートと会話する
• 運用して得られた発見をモデルに還元する
というものです。それぞれ解説していきましょう。
1.5.1 ドメインエキスパートと会話する 採用管理アプリケーションを有用なものにするには、まずドメイン (アプリケーション
で問題解決しようとする、採用管理領域)に詳しい人、つまり人事担当者に話を聞くこと が必要でしょう。 ソフトウェア開発においてよくあるのは、十分にモデリングやヒアリングを行わず、開 発者の部分的な理解のみで実装を進めてしまうパターンです。 そのような場合、求められているものとのすれ違いに気付くには時間がかかります。そ して、気付いた時点ではすでにコードやデータが目指したい形とは大きく異なっており、 大きな修正コストが必要になってしまいます。(多くの場合、このコストを払うことがで きず、徐々に理想と現実が乖離していきます…！ ) このような事態を避けるには、早い段階でモデリングをドメインに詳しい人と一緒に行
14
1.6 DDDの問題解決のアプローチ
い、モデルに知識を反映することが必要です。DDDでは、そのようなドメインに詳しい 人のことを「ドメインエキスパート」と呼び、ドメインエキスパートとの会話を通じて一 緒にモデルを改善していくことを重要視します。
1.5.2 運用して得られた発見をモデルに還元する ドメインエキスパートと会話することは重要ですが、彼らはソフトウェア開発のエキス パートという訳ではありません。リリースして運用してみたら意外な改善点があった、と いうことは必ず発生します。この発見をモデルに反映することが、モデルを改善するため のもう一つの重要な点です。 「最初からモデルは完成せず、徐々に改善して行くもの」という考えは DDDにおいて 非常に重要です。このサイクルは短ければ短いほど良いでしょう。リリース頻度が半年に 1 回の場合と毎週の場合では、得られる発見の数は大きく異なります。発見が多いほど、 モデルは改善されていきます。
モデルを頻繁に更新したら、コードも頻繁に変更する必要があります。コードは、その ような変更に耐えられる実装でなければなりません。これは、ソフトウェアにとっては、 実はとても高い要求です。 そして、それを達成するためのベストプラクティスが、エンティティやリポジトリと いった戦術的設計パターンなのです。
1.6 DDDの問題解決のアプローチ DDDの問題解決のためのアプローチをまとめると、次のようになります。
15
第 1章 DDD概要
▲図 1.2 DDD のアプローチ全体像
前述の通り、モデルが良くなければ、実装が素晴らしくても問題は解決できません。ま た、モデルが良くても、それをソフトウェアで実現できなければ、やはり問題は解決でき ません。

1. ドメインについての理解を深め、モデルを継続的に改善する 2. モデルを継続的にソフトウェアに反映する
この 2つのアプローチが達成されてこそ、最終的に問題解決力が高いソフトウェアを実 現できるのです。 ここから、DDDで定義される手法を、この 2つのアプローチのどこに該当するかを分 けて解説します。「ユビキタス言語」や「境界づけられたコンテキスト」といった用語は 最初は非常にわかりにくいですが、図 1.2のアプローチの一環として捉えると理解しやす くなります。
1.6.1 モデルの継続的な改善 ドメインエキスパートと共にモデルを探求する これは前述の通りです。「探求 (explore)」という言葉に、作って終わりではなく、一緒
に考え続ける、というニュアンスが含まれています。
ユビキタス言語 発見したモデルの言葉を、すべての場所で使うという指針です。
16
1.6 DDDの問題解決のアプローチ
ユビキタスの意味は「In Everywhere」です。開発者だけでなく、ビジネス側の人とも 同じ言葉を使うことはもちろん、「会話でも、ドキュメントでも、コードでも」というこ とを意味します。 場所によって違う言葉が使われると、言い換えや変換が行われます。言葉が変換される 際、意味の損失や認識ずれがどうしても発生します。どこでも同じ言葉を使うことで、言 葉の変換を極力なくすことを目指します。
ユビキタス言語における英語の有利さ
「会話でも、ドキュメントでも、コードでも」を実現するのに、英語はとても有 利です。モデリングした言葉をそのままコードに落とせるからです。 残念ながら日本語でモデリングした言葉はそのままコードに落とすことはでき ないため、工夫が必要になります。代表的なものはだいたい次の 3 つに絞られ ます。
1. 日本語と英語の対応を決めて変換する 2. ローマ字表記でコーディングする 3. 日本語でコーディングする
3 つ目はなかなか大胆ですが、言語のサポートがあれば実現は可能です。どれ もメリットデメリットがあるため、有利なものを一意に決めることはできません。 筆者はプロダクションコードでは 1しか試みたことがありませんが、興味があれ ばぜひ他の選択肢も試してみてください。
境界づけられたコンテキスト あるモデルを、同じ意味で使い続ける範囲を定義するものです。そうすることにより、 モデルを適切な粒度に分解し、精度を上げることを目指します。 詳しくは「第 3章 3.2 境界づけられたコンテキスト」で解説しますので、そちらを参照 してください。
17
第 1章 DDD概要
1.6.2 モデルからソフトウェアへの継続的な反映 モデルを直接表現するコード 前述の通り、モデルは頻繁に改善し、コードに反映していくことを目指します。そこ で、作成したモデルと、実装したコードの形が乖離するとどうなるでしょうか。 乖離が大きくなればなるほど、モデルの正確なマッピングは難しく、正しく反映されな くなってしまいます。反映されなければ、モデルが本来目指す問題解決は達成されにくく なります。また、コードからモデルを読み解いて理解することも難しくなります。 これを避けるため、極力モデルとコードの表現を近づけることを目指します。DDDで
は、そのためにオブジェクト指向の手法を用いて実装します。 「第 2章 モデリングから実装まで」にて、具体的なコードを用いて解説します。
モデル表現を隔離するアーキテクチャ 一般的なソフトウェアでは、モデルの表現以外にも、UIやデータベースとのやりとり
といった処理が実装されます。これらの処理とモデルの表現を同じコードの中に混在させ ると、煩雑で記述量の多いコードになり、可読性、保守性が下がります。 そこで、モデル表現とその他の処理をレイヤーという単位で大きく分離し、モデル表現 を行う層を「ドメイン層」として隔離します。これを実現するための代表的なものに、レ イヤードアーキテクチャ、オニオンアーキテクチャ、クリーンアーキテクチャがあります。 「第 5章 アーキテクチャ」にて、詳しく解説します。
戦術的設計パターン 前述の通り、頻繁な変更に耐えうる拡張性の高い設計のベストプラクティスが、エン ティティやリポジトリといった戦術的設計パターンです。 このパターンだけを取り入れることを「軽量 DDD」と呼ぶことがありますが、高い要 求を満たせるベストプラクティスを適用することになるため、設計/実装の改善には十分 効果があります。 しかし、ここまでに解説した通り、モデルが良くなければ実装が素晴らしくても問題は 解決できません。併せてモデリングにも取り組むことで、ソフトウェア自体の問題解決力 や価値を高められるのです。
DDDに関して良く目にする話題として、「モデリングしない軽量 DDDはダメなのか」 というものがありますが、決してそんなことはありません。軽量 DDDで設計を改善して ようやく、モデルを改善する余裕ができる、と考えることもできます。
18
1.7 取り組む上で重要な考え方
そして、戦術的設計パターンの適用とモデリングは両方同時に着手できます。設計の改 善にも、モデリングにも終わりがありません。片方を終えてからではなく、両方少しずつ 実施していくというアプローチが現実的でしょう。
戦術的設計パターンの詳細については、「第 6章 ドメイン層の実装」で解説します。
1.7 取り組む上で重要な考え方 この節は、筆者の私見として、DDDに取り組む上で重要な考え方について説明します。
1.7.1 課題ドリブン 何かの意思決定をする際に重要なのは、解決したい課題を明確にすることです。これは つまり「ルールで決められているからこう」という判断をしない、ということになります。 例えば、「DDD ではユビキタス言語が大事らしいから用語集を作ろう」と言って目的 を明確にせずに作り、そのままメンテナンスされない、と言った話を耳にすることがあり ます。 そうではなく、そもそもなぜユビキタス言語が必要なのか、何を目的として導入するの か、ということを言語化し、認識を合わせることが重要です。目的が明確であれば、納得 感を持って取り組めますし、何が必要なのかを自分で判断し、工夫できるようになります。
本書で DDDの目的から解説したのはそこに狙いがあります。自分のプロジェクトで解 決したい課題が、DDDで解消できる課題と合わなければ、DDDを採用する必要はあり ません。また、各アプローチそれぞれの目的を理解できれば、必要なものだけ取捨選択す ることができます。 各章の解説も「決まりごと」だけでなく、目的や狙いを解説するようにしています。そ れを意識して読み解き、実践に役立ててください。
1.7.2 小さく初めて、小さく失敗する 何事も、最初から正解に到達することはできません。実験して、そこから望む結果に近 づいていくということが、現実的に必要なアクションです。
1回のモデリング作業だけで完全に目的を達成できるモデルは作れません。実装して初 めて気付くことは多いです。だとすると、モデリングに 1週間もかけて完成を目指すこと は得策ではありません。モデリングし、実装し、気付きを反映し…と、試行錯誤のサイク ルを小さくすることが重要です。
19
第 1章 DDD概要
また、いきなり複数アプリケーションにまたがる大きな設計をしようとすると、難易度 が上がり挫折してしまう可能性があります。まずは一つのアプリケーション内の小さい部 分から始め、少しずつ成功体験を積む方が良いでしょう。
1.8 Q&A
1.8.1 DDDの向き・不向き
DDDを導入するのに向いていいるプロジェクト、向いていないプロジェクトはありますか？
DDDが向いているのは、問題解決しようとするドメインが複雑な場合です。複雑なド メインに対して、モデリングを中心としたアプローチによって問題解決力を高めたい、と いう場合には効果を発揮します。 一方、非常にシンプルな場合 (単純な CRUDしかない場合など)や、コアコンピタンス が技術的な関心ごとである場合 (超高速処理が重要な場合など) は、DDD のアーキテク チャの実装上のオーバーヘッドに対して、得られるものが見合わないことがあります。そ のような場合は、DDDではない別のアプローチを考える方が良いでしょう。
20
第 2章
モデリングから実装まで
本章では、ドメインモデリングを行い、実装に落とすところまでを一通り解説します。 DDDを用いた開発プロセス全体と、その効果を理解することを目指します。
2.1 ドメインモデリング DDDに着手して迷うのは、モデリングの方法やアウトプットの形式です。エヴァンス 本や実践 DDD ではそれが具体的に指定されておらず、初学者がつまずく要因の一つに なっています。
DDDと相性が良いとされているモデリングの手法としては RDRA(リレーションシッ プ駆動要件分析)*1や ICONIX*2と言ったものがあります。これらは有効な手法ですが、 作成する図の種類が多く、着手するには少しハードルがあります。 本書では、比較的シンプルで、小さく初めて効果を出しやすい方法として、ユースケー ス図とドメインモデル図を作成する方法を紹介します。
2.1.1 ユースケース図 ユースケース図は、UMLで定義されているもので、「ユーザの要求に対するシステムの
振る舞いを定義する図」です。アクターとしてユーザーの種類を定義 (棒人間のアイコン で記載)し、ユースケースとして「〇〇を××する」という形式でシステムの振る舞いを 定義 (丸い吹き出しで記載)します。 例として、タスク管理アプリケーションを考えます。図 2.1のようなユースケース図を
作成しました。
*1 <http://k-method.jp/> *2 ユースケース駆動開発実践ガイド <https://amzn.to/2QsfEoa>
21
第 2章モデリングから実装まで
▲図 2.1 ユースケース図
このタイミングで、次ステップのドメインモデル図作成のスコープを決めます。今回 は、タスクの登録や完了をスコープに入れ、カレンダー登録はスコープ外としました。
ユースケース図を作成する目的 なぜ、ドメインモデル図の前にユースケース図を作成するのでしょうか。それは、ユー スケースを具体化しないと、どのようなモデルを作れば良いか判断できないからです。 「作業者として、自分のタスクを管理したい」のか、「管理者として、複数作業者のタス ク状況を管理したい」のか。それによって「タスク」のドメインモデルは違うものになり ます。 言い換えると、ユースケースが具体化されないと、モデルが解決するべき問題が明確に ならないため、モデルの良し悪しも判断できないということになります。
ドメインモデル図作成のスコープを決める目的 なぜ、一度定義したユースケース図の中で、ドメインモデル図作成のスコープを定義す るのでしょうか。 それは、ドメインモデル図を作成していると自然と色々な要素が思い浮かんでくるの で、議論の範囲を狭めて限られた時間で成果を出せるようにするためです。議論が広がり 過ぎてしまった時に「今回はここはスコープ外だから別の機会にしよう」と保留すること
22
2.1 ドメインモデリング
ができます。 ドメインモデル図作成中にスコープを狭め過ぎてしまったことに気付いたら、後から広 げても構いません。その場合は、ユースケース図上のスコープも広げて同期させると良い でしょう。
2.1.2 ドメインモデル図 ドメインモデル図は、簡易化したクラス図のようなものです。
• オブジェクトの代表的な属性を書くが、メソッドまで書かなくてよい
• 「ルール/成約 (ドメイン知識)」を吹き出しに書き出す
• オブジェクト同士の関連を示す
• 多重度を定義する
• 集約の範囲を定義する
• 理解を促進するために、具体例などを書いても良い
以上のルール基づき、ドメインモデルを作成していきます。ルール/制約というのは、 オブジェクトの生成や更新時に守らなければいけないルールを指します。 集約に関しては「第 3章 3.1 集約」で解説するので、最初は「このタイミングで集約ま で設計する」ということだけ覚えておいてもらえれば大丈夫です。この段階で集約まで定 義すると、リポジトリを作成する単位など、実装が具体的に決定できます。
なお、ユースケース図もドメインモデル図も、最初に作成するときはホワイトボードで 殴り書きで構いません。複数人で議論しながら進めるには、ホワイドボードで書いたり消 したりしながら進める方が意見を反映しやすいでしょう。
図 2.1のユースケース図を元に、ドメインモデル図を作成しました。(図 2.2)
23
第 2章モデリングから実装まで
▲図 2.2 タスクドメインモデル
オブジェクトとしてはタスクとユーザーがあり、1ユーザーに対して 0～n個のタスク を持ちうることがわかります。また、ユーザー、タスクの作成や更新時のルールが吹き出 しで書かれています。
ルール/制約の記述方法 ルール/制約は、基本的には吹き出しで箇条書きで書いていきます。ただし、他により
良い書き方があれば、別の方法で記述しても構いません。 代表的なものが状態遷移図です。状態遷移もルール/制約の一つと捉えることができま すが、文章で書くよりも図で表現した方がわかりやすいことがあります。そのような場 合、ドメインモデル図と合わせて状態遷移図を書くことも可能です。 ルール/制約について関係者の認識を合わせ、新しい発見ができるのであれば、記述方 法は自由に工夫していただいて構いません。
集約の表現方法 集約を考慮する際、オブジェクト同士の関連は集約の内外で 2種類に分かれます。その 際、ドメインモデル図の記法としても次のように書き分けると良いでしょう。
• 集約内の参照はインスタンス参照となり、「◆－」で表す
• 集約外の参照は ID参照となり、「→」で表す
図 2.2 では、ユーザーからプロファイルへの参照は集約内の参照であり、タスクから
24
2.2 ドメインモデルの実装
ユーザーへの参照は集約外の参照となり、この記法に従っています。
2.2 ドメインモデルの実装 この節では、前節で作成したモデルをコードに落としていきます。 改善効果を実感しやすいように、改善余地が大きくあるドメインモデル貧血症のコード から始め、それを DDDの戦術的設計パターンを使ってリファクタリングしていく様子を 解説します。ドメインモデル貧血症とは、ドメインモデルを実装するためのオブジェクト でありながら、ドメイン知識をほぼ持たないオブジェクトのことです。 サンプルコードは Javaを使います。また、ゲッター、セッターの生成にライブラリと して Lombok*3を用います。@Getter アノテーションをクラスに対して記述すると、そ のクラスのすべての属性にゲッターメソッドが生成されます。@Setterも同様です。 　Webアプリケーションを想定しており、フレームワークとして Springを使用してい ます。@Autowired を付けた属性は、DI(Dependency Injection) コンテナにより必要な インスタンスがインジェクションされます*4。また、@Transactionalを付けたメソッド でトランザクション管理が行われます*5。
2.2.1 アーキテクチャ 実装を始めるにあたり、全体のアーキテクチャを決定します。レイヤーを定義して「こ のレイヤーにはこういうクラスを実装する」という方針を定義します。ここではオニオン アーキテクチャというアーキテクチャを採用します (図 2.3)。詳細は「第 5章 アーキテク チャ」にて解説します。
*3 <https://projectlombok.org/features/all> *4 <https://docs.spring.io/spring-boot/docs/2.1.x/reference/html/using-boot-spring-beans-and->
dependency-injection.html) *5 <https://docs.spring.io/spring/docs/4.3.x/spring-framework-reference/html/transaction.html>
25
第 2章モデリングから実装まで
▲図 2.3 オニオンアーキテクチャ
この節では、ユースケース層とドメイン層のオブジェクトを実装します。
2.2.2 ドメインモデル貧血症のコード リファクタリング前の改善余地があるコードの事例として、Task クラスを見てみま
しょう。このクラスはドメイン層のオブジェクトです。 ▼リスト 2.1 Task.javaバージョン 1
@Setter @Getter public class Task {
private Long id; private TaskStatus taskStatus; private String name; private LocalDate dueDate; private int postponeCount;
}
この段階では属性の定義のみで、ドメイン知識 (ルール/制約)を持っていません。故に ドメインモデル貧血症と呼ばれます。 このクラスを用いて、ユースケース層のクラスでタスク登録時の処理を書きます。
▼リスト 2.2 TaskCreateUseCase.javaバージョン 1
public class TaskCreateUseCase { @Autowired private TaskRepository taskRepository;
public void createTask(String name, LocalDate dueDate) { if (name == null || dueDate == null) {
26
2.2 ドメインモデルの実装
throw new IllegalArgumentException("必須項目が設定されていません"); } Task task = new Task(); task.setTaskStatus(TaskStatus.UNDONE); // ① task.setName(name); task.setDueDate(dueDate); task.setPostponeCount(0); // ② taskRepository.save(task);
} }
①で「タスクは未完了状態から始まる」というドメイン知識を実装しています。また、 「3回まで延期できる」というドメイン知識を表現するために、②で延期回数の初期状態を 0に設定しています。
延期時の処理も同様に実装します。
▼リスト 2.3 TaskPostponeUseCase.javaバージョン 1
public class TaskPostponeUseCase { @Autowired private TaskRepository taskRepository;
private static int POSTPONE_MAX_COUNT = 3; // ③
public void postponeTask(Long taskId) { Task task = taskRepository.findById(taskId); if (task.getPostponeCount() >= POSTPONE_MAX_COUNT) { // ④
throw new IllegalArgumentException("最大延期回数を超過しています"); } task.setDueDate(task.getDueDate().plusDays(1L)); // ⑥ task.setPostponeCount(task.getPostponeCount() + 1); // ⑤ taskRepository.save(task);
} }
「タスク延期は 3回まで」というドメイン知識を③④⑤のの実装で、「タスク延期は 1日 ずつ」というドメイン知識を⑥の実装で表現しています。
2.2.3 ドメインモデル貧血症のコードの問題点 この実装は、Active Record型*6の ORマッパーを使った際によく見られる、一般的な ものです。これで何が問題になるでしょうか？
*6 <https://ja.wikipedia.org/wiki/Active_Record>
27
第 2章モデリングから実装まで
問題点 1: 不整合なデータをいくらでも作れる すべての属性のセッターが publicになっているため、他の UseCaseクラスで自由に不
整合なデータを作ることができてしまいます。
▼リスト 2.4 不整合なデータを作成するクラス
public class EvilTaskUseCase { @Autowired private TaskRepository taskRepository;
public void createDoneTask(String name, LocalDate dueDate) { Task task = new Task(); task.setTaskStatus(TaskStatus.DONE); // × 完了状態でタスク生成 task.setPostponeCount(-1); // × カウントがまさかのマイナス taskRepository.save(task);
}
public void changeTask(Long taskId, LocalDate dueDate, TaskStatus taskStatus) {
Task task = taskRepository.findById(taskId); task.setDueDate(dueDate); // × 勝手に期日を入力値で設定、延期回数も無視 task.setTaskStatus(taskStatus); // × タスクを未完了に戻せてしまう taskRepository.save(task);
} }
厄介なことに、リスト 2.2、リスト 2.3の正しい処理を行っているクラスをみていても、 不整合な処理が追加されたことに気付けません。最悪の場合、不整合なデータが本番の DBに登録されて初めて発覚し、「このデータはどこで作られた？」となります。 不用意にすべての属性に publicなセッターを作ることは、このような問題を引き起こ すのです。
問題点 2: 仕様を追いかけるのに、多くのクラスをコード参照から追う必要がある リスト 2.1の Taskクラスのステータスや期日を変更する操作は、どのようなパターン があるでしょうか。存在するパターンに、不整合なデータを生み出すパターンはないで しょうか。このようなことを調査したければ、Taskクラスのセッターメソッドの参照元 を一つ一つ追っていく必要があります。このサンプルではシンプルですが、参照元が 10 個、20個もあったらどうでしょうか。すべての参照元を辿るのには時間がかかりますし、 漏れも発生します。 コードの参照元が増えれば増えるほど、コードを辿っていくコストが高くなり、コード からモデルを理解することは難しくなっていきます。理解が難しいものは、バグを埋め込 んでしまうリスクも高くなります。
28
2.2 ドメインモデルの実装
2.2.4 ドメインモデルの知識を表現した実装 では、ドメインモデル貧血症の問題を、どのように解決していけば良いのでしょうか。 それは、ドメインモデル図に示したドメイン知識を、吹き出しが書かれているオブジェク トに寄せていくのです。
ドメイン知識はどの層のオブジェクトに書かれているか 図 2.2 で吹き出しに書かれているドメイン知識は、どこのクラスに実装されているで しょうか？ アーキテクチャの図にマッピングして見ましょう。
▲図 2.4 ドメイン知識がユースケース図に記述されている
図 2.4の通り、ユースケース層のクラスである、リスト 2.2、リスト 2.3の UseCaseク ラスに実装されていることがわかります。 ここから、ドメイン知識をドメイン層のクラスに委譲する形でリファクタリングしてい きます。(図 2.5)
29
第 2章モデリングから実装まで
▲図 2.5 ドメイン知識をドメイン層のクラスに委譲
ドメイン知識をドメイン層に委譲した実装 ドメイン知識をドメイン層のクラスに寄せると、どのような実装になるでしょうか。違 いをわかりやすくするために、まずはユースケース層のクラスからみてみます。(リスト 2.5、リスト 2.6)
▼リスト 2.5 TaskCreateUseCase.javaバージョン 2
public class TaskCreateUseCase { @Autowired private TaskRepository taskRepository;
@Transactional public void createTask(String name, LocalDate dueDate) {
// 生成時のルール/制約に関する実装がなくなっている Task task = new Task(name, dueDate); taskRepository.save(task);
} }
▼リスト 2.6 TaskPostponeUseCase.javaバージョン 2
public class TaskPostponeUseCase { @Autowired private TaskRepository taskRepository;
@Transactional
30
2.2 ドメインモデルの実装
public void postpone(Long taskId) { // 更新時のルール/制約に関する実装がなくなっている Task task = taskRepository.findById(taskId); task.postpone();　 taskRepository.save(task);
} }
ドメイン知識を表現する実装を全く持たなくなりました。 結果として、修正前に比べて比べてコード量が大幅に減り、ユースケース記述のよう な抽象度の高い記述になりました。「実装上どのように実現するか (How)」は隠蔽され、 「何をしたいか (What)」だけを示すようになったのです。
では、Taskクラスはどのようになっているでしょうか。 ▼リスト 2.7 Task.javaバージョン 2
@Getter // @Setter // ←Setterは無くす ④ public class Task {
private Long id; private TaskStatus taskStatus; private String name; private LocalDate dueDate; private int postponeCount;
// コンストラクタ: 新規登録時の処理 public Task(String name, LocalDate dueDate) {
if (name == null || dueDate == null) { throw new IllegalArgumentException("必須項目が設定されていません");
} this.name = name; this.dueDate = dueDate; this.taskStatus = TaskStatus.UNDONE; // ① this.postponeCount = 0;
}
private static final int POSTPONE_MAX_COUNT = 3; // ②
// 延期時の処理 public void postpone() { // ③
if (postponeCount >= POSTPONE_MAX_COUNT) { throw new IllegalArgumentException("最大延期回数を超過しています");
} dueDate.plusDays(1L); postponeCount++;
} }
リスト 2.7のコードでは、①で「タスクは未完了状態から始まる」というドメイン知識 を、②③で「3回まで延期できる」というドメイン知識を実装しています。また、④の通
31
第 2章モデリングから実装まで
りすべて publicなセッターがなくなっているので、クラス外部から想定外の値を設定す ることができなくなりました。 結果として、この 1クラスを見るだけですべてのオブジェクト生成、状態遷移のパター ンがわかるようになりました。コードの可読性が高まったので、コードからドメインモデ ルを理解することも、ドメインモデルに更新があった時に修正することも簡単です。 これにより、第 1章で DDDのアプローチの一つとして解説した「モデルを継続的にソ フトウェアに反映する」が実現しやすくなりました。
2.3 ドメイン層オブジェクト設計の基本方針 ドメイン層のオブジェクトを設計する際に、重要な基本方針があります。
• ドメインモデルの知識を対応するオブジェクトに書く
• 常に正しいインスタンスしか存在させない
この 2 つを守ると、非常に保守性の高いコードにすることができます。この方針は Taskクラスのリファクタリングでも適用されていました。以下、詳細に解説します。
2.3.1 ドメインモデルの知識を対応するオブジェクトに書く ドメイン知識 (ルール/制約)を表現する実装を、ドメイン層のオブジェクトに寄せてい きます。この判断は、「ドメインモデル図に書かれた吹き出しの内容が、どの層で実装さ れているか」という基準に基づき行います。 この基準はコード設計の指針として非常に役立ちます。設計の良し悪しというのはさま ざまな基準があるため、レビューをしていてもいわゆる「俺の考えた最強の設計」同士が 戦ってしまうことがあります。しかし、「ドメイン知識はドメイン層に書く」というルー ルをコード規約のように定めれば、それに従っているかどうかは機械的に判断できます。 設計時にも、レビュー時も、同じ規約に基づいて判断できるので、アプリケーション全 体に規律を作ることができます。
2.3.2 常に正しいインスタンスしか存在させない もし、ドメインオブジェクト (ドメインモデルを表現するオブジェクト)が、整合性の
保証されたインスタンスしか存在できなくなったらどうなるでしょうか。インスタンスを どのタイミングで永続化しても、確実にデータの整合性が保証されることになります。こ れは実装上非常に強い安心感に繋がります。 これを実現するためには、次の 2つを行います。
32
2.3 ドメイン層オブジェクト設計の基本方針
• 生成条件の強制
• ミューテーション条件の強制
以下、それぞれ解説します。
生成条件の強制 すべてのインスタンスはコンストラクタ、もしくはファクトリーメソッド（以下、2つ 合わせて生成メソッドとする）を経由して生成されます。そのため、存在する生成メソッ ドがすべて正しい条件を強制できれば、新規作成されたインスタンスはすべて整合性が保 証されていることになります。 これに反しているのが、何もロジックのないデフォルトコンストラクタです。すべての 項目に値が入っていないインスタンスは、整合性を保証されたものではありません。習慣 的にデフォルトコンストラクタを放置してしまいがちですが、デフォルトコンストラクタ を無くし、意味のある生成メソッドだけ存在するようにします。 リスト 2.7の Taskクラスでは、コンストラクタが 1つだけあり、デフォルトコンスト ラクタはありません。そのため、生成されるインスタンスはすべてこのコンストラクタを 確実に通ることがわかります。
ミューテーション条件の強制 生成メソッドの制御により、インスタンスが正しい状態で生成されることが保証できま した。あとは、すべての内部状態の変更、つまりミューテーションが正しければ「常に正 しいインスタンスしか存在させない」ことが可能になります。そのために、正しいミュー テーションを起こすメソッド (以下、ミューテーションメソッド)のみ外部に公開するよ うにします。 これに反しているのが、すべての項目に対するセッターです。詳細は「2.2.3 ドメイン モデル貧血症のコードの問題点」で述べた通りです。 リスト 2.7の Taskクラスにはセッターがなく、ミューテーションメソッドは postpon
e メソッドしかありません。コンストラクタを合わせて判断すると、Taskクラスは正し いインスタンスしか存在できないことがわかります。このことが複数クラスを追いかける ことなく、たった 1クラスで判断できるということは、可読性、保守性向上のために大き な効果があります。
33
第 2章モデリングから実装まで
2.4 実際の開発の進め方 ここまで段階を踏んで実装をしてきたのは、解説のために特別にやっているわけではあ りません。第 1章で「最初からモデルは完成せず、徐々に改善して行くもの」と書きまし たが、これはコードも同じことです。実際の開発においても、まずはとにかく動くコード を実装してから、今回の事例のように徐々に改善していけば良いのです。 ただし、この方針をとるためには、テストコードの存在が重要になります。本章では趣
旨から外れるために省略しましたが、実際はユースケースやドメインオブジェクト単位で テストを書き、継続的インテグレーションができることが望ましいです。テストがあれ ば、リファクタリングしてもバグが埋め込まれていないことを確実に保証できます。 逆に、テストがなければその保証ができないため、コード修正はリスクを追うことにな り、修正されないという判断になりがちです。そうするとコードは改善されることをや め、少しずつ理想のコードから離れていってしまうのです。
2.5 Q&A
2.5.1 ユビキタス言語の管理方法
ユビキタス言語はどのように残すのが良いでしょうか？
色々な方法が考えられますが、ドメインモデル図を電子化し、そこをマスターとするの は効果的な方法です。 ユビキタス言語はドメインモデリング、特にドメインモデル図作成の過程で発見され、 定義されます。また、より適した概念を発見して言葉を更新する時も、ドメインモデル図 を起点に行うと認識を揃えやすいです。 そのため、別途テキストの用語集を管理するよりも、ドメインモデル図自体がユビキタ ス言語を定義するものとした方が、自然にメンテナンスをしていきやすいです。
電子化の方法としては、PlantUML*7というツールが便利です。PlantUML は、クラ ス図やその他 UML などの図をテキストで記述することのできるツールで、IntelliJ や VSCode用のプラグインもあります。
*7 <https://plantuml.com/>
34
2.5 Q&A
この成果物ファイルは、アプリケーションの Gitリポジトリにコミットして管理できま す。テキスト記述のファイルになるので、プルリクエストで差分をレビューしたり、断面 ごとの履歴を保存したりできるという利点があります。
また、ビジネスサイドの人や、その他ステークホールダーまで言葉を浸透させたい時の プラクティスがあります。ユビキタス言語をアプリケーションの画面で使われる言葉 (画 面名や、項目に表示される名称など)に反映することです。 言葉が統一されていない状態でも、画面の言葉になってしまえば使用者は自然とその言 葉に従います。リリースする前のフェーズでも、画面のモックに意識的にユビキタス言語 を反映し、フィードバックをもらう機会などで見せていけば、自然にユビキタス言語を浸 透させるきっかけを作ることができます。
2.5.2 モデリングにかける時間
モデリングにはどれくらい時間をかけていますか？
対象のスコープの広さや複雑度によるので一概には言えませんが、例えば 1、2時間ぐ らいと制限時間を決めて取り組みます。 終了する基準として、議論に出たドメイン知識を図にマッピングし終わり、その場にお ける疑問がある程度解消されることを目指します。決まりきらなかった点も、「この詳細 は××の実装が終わってから考える」「ここは△△さんが必要な調査してから決める」と いうように対応方針が決められれば良いでしょう。 第 1章でも書きましたが、モデルもコードもインクリメンタルに改善していくものなの で、最初から完全なものはできません。時間をかけてモデリングしても、実装に着手して すぐ漏れに気付く、ということはよくあります。ある程度時間を区切り、時間内でできる 範囲のことをやるというスタンスが良いでしょう。
2.5.3 ドメインモデル図の更新頻度
アジャイル開発の場合、要件の変化により、ドメインモデル図の更新が頻発しませんか？ その場合、 モデル図を作成するタイミングはどのようなフェーズが良いでしょうか？
頻発します。むしろ、第 1章でも述べた通り、得られた発見を頻繁に反映していくこと を理想としています。
35
第 2章モデリングから実装まで
更新のタイミングは、実装を開始する前が良いでしょう。モデル図を更新せずに実装を 変えてしまうと、モデル図と実装が乖離してしまうので避けるべきです。 更新はエンジニアだけではなくドメインエキスパートと共に行い、変更要件がドメイン モデル図にどう影響するのか話しながら進められると、新しい発見の誘発や、手戻りの防 止ができる可能性が高まります。
2.5.4 モデリング時に作成するその他の成果物
ドメインモデリングで、ドメインモデル図以外に何を使いますか? 特に動的側面はどのくらい分析し、 どういう図を作成しますか?
「第 2章 2.1.2 ドメインモデル図」で書いた通り、状態遷移図はよく使います。 動的側面としてはシーケンス図のようなものが考えられますが、シーケンス図は「ルー ル/制約」ではなく処理順序に関わるものなので、ドメインモデリングというよりはユー スケースの処理設計にあたると捉えられます。 そのため、ドメインモデリング時にはあまり考慮せず、別のタイミングで検討します。 ドメインモデルを作成する上で整理されていなければ考えづらい場合はドメインモデリン グより前に、そうでなければ後回しにと、柔軟に判断します。
2.5.5 ユースケース図を使う理由
色々なモデルの中からユースケース図を選んだ理由があれば教えてください
ユースケース図を選んだきっかけから説明します。ドメインモデリングの例題を探して いた時に、とある書籍で「アイスクリームをモデリングしてみよう」という題材があった のです。 そのような漠然とした問いかけだと、切り口がいくつも考えられました。アイスクリー ムの在庫を管理したいのか、自分の食べたアイスクリームを記録したいのか、友人に美味 しかったアイスクリームを紹介したいのか…。これを定めずに「モデリングしよう」と議 論を始めても、全くまとまらなかったのです。 結局、アプリケーション開発という前提であれば、「アプリケーションとして何を行う のか」というのを定義するのが一番開発につなぎやすく、そこでちょうど用途に合致した のがユースケースだったのです。
36
2.5 Q&A
2.5.6 他のモデリング手法との違い
RDRA、ICONIXといった手法と、ドメインモデル図作成から入る手法の違いを教えてください
モデリング対象のスコープが違います。本章で紹介したユースケース図/ドメインモデ ル図を作成する手法は、RDRA、ICONIXに比べてスコープが小さいです。
RDRA、ICONIXは、ソフトウェア全体的の要求分析から入ります。一方、ユースケー ス図/ドメインモデル図は、直近で開発を着手する機能を対象に、関連がある領域を対象 にモデリングするものです。 本書でこの手法をおすすめしている理由は、必要となる知識が少なく着手しやいため と、コードに落とすための意思決定を十分に表現できるためです。 一方、モデル同士の全体感を把握するには個別のドメインモデル図だけでは表現しきれ ません。必要であれば、もう少し粒度の荒いドメインモデル同士の関連を図示するなど、 用途にあった別の方法を検討してください。
37
第 3章
DDD固有のモデリング手法
本章では、集約、境界づけられたコンテキストという DDD固有のモデリング手法につ いて解説します。これらは独特の概念でなかなか理解しにくいですが、DDDを実践する 上では非常に重要なものです。
3.1 集約 3.1.1 集約とは 集約とは、「必ず守りたい強い整合性を持ったオブジェクトのまとまり」を表します。 集約は抽象的な概念のため、そのまま捉えようとするとなかなか理解しにくいです。そ のため、まずはシンプルな事例を使って「設計/実装時のルール」を解説し、その影響と メリットという順番で説明します。
3.1.2 設計/実装時のルール ルールは以下の 2つがあります。
• 強い整合性確保が必要なものを 1つの集約にする
• トランザクションを必ず 1つにする
それぞれについて解説します。
強い整合性確保が必要なものを 1つの集約にする 例として、高校の部活動における「部」と「部員」のモデルを考えます。部の承認状態 は、最初は「未承認」であり、部員が 5人以上所属し、学校の承認が通ると「承認済」と なります。そして部員が 4人以下になると承認状態は「未承認」に戻ります（図 3.1）。
38
3.1 集約
▲図 3.1 部と部員のドメインモデル図
この場合、部の承認状態と部員の数は、強い整合性確保が必要になります。このような 場合に、部と部員を 1つの集約として定義します。生徒は部とは別に、生徒集約として定 義します。ドメインモデリングにおいて、すべてのオブジェクトはいずれかの集約に所属 するようにします。（図 3.2） 　集約のオブジェクトを扱うときの親となるオブジェクトを集約ごとに 1つ決め、その オブジェクトを「集約ルート」と呼びます。この事例では部が集約ルートとなり、子オブ ジェクトとして部員を持つという形になります。
▲図 3.2 集約の境界を明示したドメインモデル図
39
第 3章 DDD固有のモデリング手法
トランザクションを必ず 1つにする 1つの集約のオブジェクトは、必ず集約単位でリポジトリから取得し、集約単位でリポ ジトリに渡します。そして、1トランザクションで集約内のすべてのオブジェクトを更新 します。集約の中の一部オブジェクトのみの取得/更新は許可しません。
目的は、集約内のオブジェクトの整合性が崩れるのを防ぐことです。図 3.2の事例で、 部員が 5 人以上そろい、部が承認された状態から、部オブジェクトを考慮せずに部員の オブジェクトだけ削除したらどうなるでしょうか。「部員が 4人以下になると承認状態は 『未承認』に戻る」という制約が簡単に破られてしまいます。 このような操作を防ぐために、部と部員を同時に取得し、部員に対する操作は必ず部オ ブジェクトを経由させるようにします。部オブジェクトに部と部員を合わせた状態管理の 責務を持たせ、部員を外部から直接操作できないようにすれば、これらのオブジェクトの 整合性を間違いなく確保できるようになります。
3.1.3 集約の境界の決め方 DDDの設計で非常に難しいのが、集約の境界の決め方です。なぜかというと、「必ずこ うすればよい」という機械的な決め方は存在せず、複数の観点から総合的なバランスを踏 まえて判断しなければいけないからです。 具体的には、主に次の 2つの観点を考慮して決定します。
整合性を確保する必要性の強さ 前述のとおり、整合性を「強く」確保したいものを 1つの集約にしますが、複数集約間
では整合性を確保しないわけではありません。しかし、複数集約間の整合性を確保するに は、実装上のコストや難易度が上がります (詳細は「第 6章 6.7 複数集約間の整合性確保」 で解説します)。そのため、整合性確保が必要なら必ず 1つの集約にするというわけでは なく、その必要性の強さに基づいて判断することになります。
トランザクションの範囲の適切さ 先ほど説明したように、集約内のオブジェクトは必ずまとめて取得して 1つのトランザ
クションで更新します。そのため、集約の範囲を大きくしすぎるとデータベースに対して 不必要に大きなロックを取り、問題が発生します。 例えば部の親オブジェクトとして学校があり、学校という集約として定義したらどうで しょうか（図 3.3）。そうすると、1つの部を更新するためには学校とそれ以下のすべての
40
3.2 境界づけられたコンテキスト
部をまとめて取得し、まとめて更新することになります。これでは、1つの部を更新する 間は、他のすべての部の更新ができません。極端な例ではありますが、大きすぎる集約は このような問題を生みます。
▲図 3.3 大きすぎる集約
3.2 境界づけられたコンテキスト 3.2.1 境界づけられたコンテキストの概念 境界づけられたコンテキストについて、DDD Referenceの定義は以下の通りです。
A description of a boundary (typically a subsystem, or the work of a particular team) within which a particular model is defined and applicable. 特定のモデルを定義・適用する境界を明示的に示したもの。代表的な境界の例は、 サブシステムやチームなど。
これも抽象的で理解しにくいので、具体例で解説していきます。
41
第 3章 DDD固有のモデリング手法
モデルの共有 第 1章でユビキタス言語ついて解説した通り、DDDではすべての人 (ソフトウェア開 発者、ドメインエキスパート)が同じ意味で言葉を使うことを目指します。 例えば、ECサイトで商品を販売するシステムを考えてみましょう。ここでは、エンジ
ニアと販売部の人たちの中で、「商品」に関しては同じモデルを共有します。(図 3.4)
▲図 3.4 エンジニアと販売部がイメージする「商品」
エンジニアと販売部のコミュニケーションがうまくいき、「商品」について同じモデル、 言葉を共有できました。 その後、販売から配送までをシステムで管理したくなったとします。(図 3.5)
▲図 3.5 配送部がイメージする「商品」
ここで、配送部の人は「商品」と言った時に全く別のものをイメージすることがわかり
42
3.2 境界づけられたコンテキスト
ました。DDDではすべての人が同じ意味で言葉を使うことを目指すのではなかったので しょうか？ それでは強引に、「商品」の概念を統一しましょう。(図 3.6)
▲図 3.6 概念を統合した「商品」
「商品」は売値、在庫数、配送先、配送状況を持ちます…？ 一つのモデルが持つ概念が増え、複雑になってきました。そして、このモデルをコード に落とし込もうとすると、「商品」のすべての振る舞いを商品クラスに詰め込むことにな り、非常に大きなクラスになってしまうことが想像できます。
さらに、請求の管理までをシステム化することになり、カウンターパートとして経理部 の人も増えました。当然、経理部の人は「商品」に関して違うイメージを持っています。 (図 3.7)
43
第 3章 DDD固有のモデリング手法
▲図 3.7 経理部のイメージも統合した「商品」
さらに「商品」は請求に関する知識も持つことになりました。さて、すべての人が同じ 意味で言葉を使うことを目指すことは可能でしょうか…？ そう、システムが大規模になると、関係者すべてで統一したモデルを作ることは難しく なるのです。
エヴァンス本で、以下のようなことが語られています。
In those younger days we were advised to build a unified model of the entire business, but DDD recognizes that we’ve learned that "total unification of the domain model for a large system will not be feasible or cost-effective" 昔はビジネス全体の統一モデルを構築するようにアドバイスされていましたが、 DDDは「大規模システムのドメインモデルの完全な統合は実現不可能で、費用対 効果が悪い」と認識しています。
そこで、DDDではモデルが適用される範囲を明示的に定義し、それぞれの中でモデル、 言語の統一を目指すのです。この明示的に定義された範囲を「境界づけられたコンテキス ト」と呼びます。 「商品」に関して、販売と配送でコンテキストを分けたのが、図 3.8になります。
44
3.3 Q&A
▲図 3.8 販売コンテキストと配送コンテキスト
「販売コンテキスト」「配送コンテキスト」それぞれが一つの境界づけられたコンテキス トになります。それぞれのコンテキスト内では、関係者の中で「商品」は必ず同じモデル、 用語で統一します。この範囲でなら、モデル、用語を統一することは現実的になりそうで すね。
3.2.2 境界づけられたコンテキストの実装 実装については、アーキテクチャの話をしてからの方が理解しやすいので、「第 5 章 アーキテクチャ」の後半「5.7 境界づけられたコンテキストの実装」で解説します。そち らをご覧ください。
3.3 Q&A
3.3.1 DBへの意識
ドメインモデル図を考えるときにどうしても無意識にDB構成を意識してしまうですが、どのようにす ればこの呪縛から逃れられますか？
一つの案としては、永続化層を NoSQLのデータストアと想定して考えてみるのはどう でしょうか。RDBではなく、純粋な「オブジェクト」としてどのような持ち方をするの
45
第 3章 DDD固有のモデリング手法
が自然か、ということを考えやすくなるかもしれません。
3.3.2 集約とトランザクション
集約を考える際にDBトランザクションのことを考えてしまうのですが、この時点では意識すべきでは ないでしょうか？
「3.1.3 集約の境界の決め方」で書いた通り、集約を考える際にはトランザクションの観 点からの検討が必要です。ドメインモデル図作成時にはなるべく技術的な観点にとらわれ ずに抽象的なモデリングを行う方が好ましいのですが、集約に関してはどうしてもトラン ザクションに関する検討が切り離せません。 集約に関しては特に、モデリング時に決めきろうと考えず、実装してからまたモデルに 戻って試行錯誤するぐらいのスタンスで望むと良いでしょう。
46
第 4章
設計の基本原則
設計する上で、非常に重要な基本原則があります。それは、「高凝集・低結合」です。 これはアーキテクチャ設計でも、各レイヤーのクラス設計でも常に意識するべき原則で す。後続の章の解説における前提知識として必要なため、DDD固有の話ではありません が本章で解説します。
4.1 凝集度・結合度について 凝集度・結合度とは、ソフトウェアの品質を表す指標 (メトリクス)で、1970年代に提 唱され、以後ソフトウェア工学の標準用語となりました。 高凝集・低結合にすると、一般に以下のようにソフトウェア特性が改善します。
• Understandability(理解容易性): コードを読んで理解しやすくなる
• Flexibility(拡張性): コードを修正、拡張しやすくなる
• Reliability(信頼性): 修正時にバグを埋め込みにくくなる
• Reusability(再利用性): 同じコードを別の場所で再利用しやすくなる
• Testability(テスト容易性): テストを実施しやすくなる
そのため、基本的に設計時には高凝集・低結合を目指します。
凝集度・結合度は「モジュール」ごとに考えます。モジュールとは、機能をひとまとま りで捉えた単位で、クラス、アーキテクチャのレイヤー、アプリケーションなどのさまざ まな粒度があります。本章ではイメージしやすいように、モジュールを「クラス」という 記述で解説します。レイヤー、アプリケーションといった粒度の設計時には、都度読み替 えてください。
47
第 4章設計の基本原則
4.2 凝集度 4.2.1 定義 凝集度とは、1つのクラスについて「責務、データ、振る舞いの関連の強さ」の尺度で す。高い方が良いものであり、基本的に高凝集な実装を目指します。 責務とは、「このクラスは何をするクラスか？」という問いに対する答えです。この問
いかけは非常に重要です。設計する際には常に考える必要があります。 この問いに答えられない場合は、責務が曖昧なので悪い設計になりがちです。責務を明 確に定義したあと、その責務とクラスが持つデータ、メソッドがきちんと関連しているか を考えます。
4.2.2 低凝集な実装 低凝集な実装とはどのような実装でしょうか。極端な例ですが、リスト 4.1を見て見ま
しょう。
▼リスト 4.1 低凝集な実装
public class OperationUtil { // 責務が曖昧なクラス名 private int count = 0;
public void increment() { // 何からの数値をインクリメント count ++;
}
public static void greet() { // 保持している数値関係ない挨拶 System.out.println("hello.");
} }
まず、「何をするクラスなのか？」という問いに対して、答えられるクラス名ではあり ません。この事例は極端ですが、実際に身近な問題があるコードを振り返ってみてくださ い。何をするクラスなのか、という問いに答えられないケースは多いはずです。 そして、責務が曖昧なクラスに対して、保持するデータとメソッドの関連性もありませ ん。このようなクラスは、不用意に関連性のないメソッドが追加され、徐々にメンテナン スしにくいクラスになっていきます。
48
4.3 結合度
4.2.3 高凝集な実装 高凝集な実装の例を見てみましょう。
▼リスト 4.2 高凝集な実装
public class Counter { // 責務が明確なクラス名
private int count = 0; // クラス名と関連が明確なデータ
public void increment() { // クラス名、データと関連が明確なメソッド count ++;
}
public int getCurrentCount() { // クラス名、データと関連が明確なメソッド return count;
} }
このクラスは、「このクラスは何をするクラスなのか？」という問いに関して、「カウン トする数値を管理するクラス」と回答できます。(サンプルなので、何のカウントかとい うことは問題にしません) クラスの責務に対して、保持するデータは管理対象のカウント、メソッドもカウントを 増加させるメソッドと現在の値を取得するメソッド、ときちんと関連性が強いものになっ ています。このようなクラスは、可読性や保守性が高くなります。
4.3 結合度 4.3.1 定義 結合度とは、複数のクラス同士が依存している度合いの尺度です。凝集度は 1クラス内
の尺度、結合度は複数クラス間における尺度になります。 こちらは凝集度とは反対に低い方が良いものです。結合度が高いと、依存先クラスの振 る舞いや修正の影響を受けやすくなります。 また、特定の実現したい処理を、多くのクラスを組み合わせないと実現できない場合 も、結合度が高いと考えることができます。
4.3.2 高結合な実装 高結合な実装の例を見てみましょう。(リスト 4.3)
49
第 4章設計の基本原則
▼リスト 4.3 高結合なクラス
public class Printer { public static void print() {
System.out.println(Counter.number); // 処理結果がCounterの内部の値に依存している }
} public class Counter {
public static int number = 0; public static void increment(){
number ++; }
}
▼リスト 4.6 高結合なクラスを呼び出す記述
Printer.print(); // 0 が出力される Counter.increment(); Printer.print(); // 1 が出力される → この振る舞いは外側から想像が難しい
Printerの printメソッドの出力結果が、Counterの内部状態に依存しています。この 結合は内容結合*1と呼ばれ、最も結合度が高い状態です。 このような状況では、Printer、Counterどちらの実装を変更する場合も、注意深く関係
するクラスを辿っていかないとバグを生んでしまう可能性があります。
4.3.3 低結合な実装 低結合な実装はどのようなものでしょうか。
▼リスト 4.5 低結合なクラス
public class Printer{ public static void print(int number){
System.out.println(number); }
}
public class Counter { private static int number = 0; public static int getNumber(){
return number; }
}
*1 結合度の種類については、あまり重要ではないので本書ではすべてを紹介はしません。 参考: <https://en.wikipedia.org/wiki/Coupling_(computer_programming)>
50
4.4 今後の章との関連
▼リスト 4.6 低結合なクラスを呼び出す記述
Printer.print(Counter.getNumber())
リスト 4.5では、Printerと Counterは受け渡す引数でのみ関係があり、それぞれの実 装が変更になっても大きく影響を受けない、結合度が低い状態になっています。 リスト 4.3と比較すると、低結合の方が可読性、保守性が高いことがわかります。
4.4 今後の章との関連 本章の冒頭でも記述した通り、アーキテクチャもクラスも、「高凝集・低結合」は設計 時に必ず意識するべき原則です。そのためには責務を明確に定義することが必要です。 今後の章で、「責務」について数多く言及がありますが、それはこの原則に基づいたも のです。そこを意識すると、設計意図が読み解きやくなりますので、ぜひ意識しながら読 み進めてください。
51
第 5章
アーキテクチャ
アプリケーション全体にまたがる設計を (アプリケーション)アーキテクチャと呼びま すが、DDDで使用されるアーキテクチャは複数のものが提唱されています。 本章では従来の 3層アーキテクチャの問題点について述べ、その問題を解消する DDD
のアーキテクチャについて解説します。
5.1 3層アーキテクチャ 一般的なWebアプリケーションで使用されるアーキテクチャです。
▲図 5.1 3 層アーキテクチャ
よく使用されるアーキテクチャですが、何が問題でしょうか。大きな問題点は、「ビジネ スロジック層が低凝集になり、可読性や保守性が低下する」ということです。「XxxService」 「XxxLogic」といったクラスが数百行、数千行まで膨らんでしまい、とてもメンテナンス できない…といった経験がある方もいらっしゃるのではないでしょうか。ではなぜ低凝集 になってしまうのでしょうか？ 事例をもとに考えて見ましょう。
52
5.1 3層アーキテクチャ
5.1.1 タスク管理アプリケーションの例 タスク管理アプリケーションの事例で考えます。第 2章で扱ったのと同じ題材ですが、
別角度から見てみましょう。 アプリケーションを開発する際、「仕様」というものを以下のように列挙して決めるこ とがあると思います。
• ユーザー登録、非活性化ができる
• メールアドレスは重複登録できない
• タスク登録、更新、完了、未完了に戻す、延期、ユーザーへのアサインができる
• タスクは 3回までしか延期ができない
• 非活性化されていないユーザーにアサインができる
• タスク期日をカレンダーに登録することができる
これはいわゆる「ビジネスロジック」としてビジネスロジック層に書かれることになり ます。 しかし、これはすべて同じ性質のものでしょうか？ 第 2章のドメインモデリングを振 り返りながら、ユースケースとドメイン知識 (ルール/制約)を切り分けてみると、次のよ うになります。
ユースケース図 ユースケース図は、「ユーザの要求に対するシステムの振る舞いを定義する図」です。 図 5.2では、タスク、カレンダーに対してどのような操作ができるかを定義しています。
53
第 5章アーキテクチャ
▲図 5.2 ユースケース図
ドメイン知識 (ルール/制約) ドメイン知識は、「ドメインに存在するルール/制約」です。今回のものを整理すると以 下のようになります。
• ユーザー – メールアドレスは重複登録できない – 最初は活性状態で作成され、非活性化できる – ユーザーは姓名、メールアドレスを持つ
• タスク – 期日は 1日ずつ、3回まで延期できる –「活性」ステータスのユーザーのみ担当に設定できる – タスクステータスは「未完了/完了」の 2種類で、「未完了」からはじまる
もともと「仕様」として列挙されていたものを、ユースケースとドメイン知識という、 全く性質の異なるものに分けることができました。このように整理すると、2種類の異な る性質のものをすべて「仕様、ビジネスロジック」として、区別なくビジネスロジック層 に実装してしまっていたと言うことがわかります。このことが原因で、ビジネスロジック 層が責務過剰になり、凝集度が低い状態になっていたのです。
54
5.2 レイヤードアーキテクチャ
また、ドメイン知識はテーブルと対応する「モデル」と言われるオブジェクトに書かれ ることもあり、ドメイン知識がビジネスロジック層とデータアクセス層に分散します。結 果として、2つの層の結合度も高まってしまうのです。
3 層アーキテクチャでは、自然と「高凝集・低結合」とは逆の、「低凝集・高結合」に なってしまうことがわかりました。では、これをどのように改善すればよいでしょうか。
5.2 レイヤードアーキテクチャ ビジネスロジック層の責務が過剰なため、この層を「ユースケースを実現する層」と
「ドメイン知識を表現する層」の 2つに分割する、というのが最初の大きなステップです。 これを実現したのが、エヴァンス本で紹介されているレイヤードアーキテクチャです。*1
▲図 5.3 レイヤードアーキテクチャ
図 5.3のように、アプリケーション層でユースケースの実現を、ドメイン層でドメイン 知識の表現を行います。このようにすると、レイヤーごとの凝集度が高まり、可読性や保 守性を高めることができます。 しかし、このアーキテクチャにも課題があります。ドメイン層がインフラ層に依存して しまうということです。特に、一番実装に困る機会が多いのがリポジトリです。ドメイン 層にリポジトリを置く場合、そのリポジトリが特定の DB や OR マッパーに依存した実 装になります。インターフェイスを挟めばある程度影響を抑えられますが、ドメイン層自 体が特定のインフラ技術に依存することは避けられなくなります。
*1 この後に紹介するオニオンアーキテクチャ、クリーンアーキテクチャも「階層化された」という意味では レイヤードという名称が当てはまりますが、レイヤードアーキテクチャはこの名称でエヴァンス本で紹介 され、他の名称がないのでこの呼称を用います。
55
第 5章アーキテクチャ
第 1章で述べた、「モデルを継続的に改善する」「モデルを継続的にソフトウェアに反映 する」ということを行うために、ドメイン層は特定のインフラ技術に依存せず、独立した 実装にすることを目指したいです。 そこで、解決策として提唱されたものの一つが、次に紹介するオニオンアーキテクチャ です。
5.3 オニオンアーキテクチャ 5.3.1 レイヤーごとの責務 レイヤードアーキテクチャから、依存関係逆転の原則*2を用いてドメイン層とインフラ
層の依存関係を逆転させたのがオニオンアーキテクチャ*3です。第 2章の実装例で使用し たのは、こちらのアーキテクチャです。黒矢印は使用、白矢印はインターフェイスの実装 を表します。
▲図 5.4 オニオンアーキテクチャ
リポジトリはインターフェイスをドメイン層に、実装クラスをインフラ層に定義しま す。すると、依存の方向性は実装クラスからインターフェイスになるので、レイヤーの依 存も同様にインフラ層からドメイン層になります。 このような依存関係にすれば、ドメイン層を特定の技術に依存させず、独立した層とし て実装できるようになります。結果として、レイヤー単位で見たときに、「高凝集・低結 合」が実現できます。
*2 <https://ja.wikipedia.org/wiki/依存性逆転の原則>*3 Jeffrey Palermoにより 2008年に提唱
<https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/>
56
5.3 オニオンアーキテクチャ
層ごとの概要は次の通りになります。
ドメイン層 ドメイン知識（ルール/制約）を表現します。この層を独立させ、他の層への依存を持 たせないようにします。また、「第 2章 2.3 ドメイン層オブジェクト設計の基本方針」で 解説した通り、整合性が保証できるメソッドのみ他の層に公開するようにします。 主なクラスは、ドメインオブジェクト (エンティティ、値オブジェクト、ドメインイベ ント) と、それを利用するクラス (リポジトリのインターフェイス、ドメインサービス、 ファクトリー)があります。 上記のクラスの種類に合わせて、層自体を「ドメインモデル層」「ドメインサービス層」 とする方法もありますが、本書では 1つとして紹介します。 「第 6章 ドメイン層の実装」で詳細に解説します。
ユースケース層 ドメイン層が公開している操作を組み合わせて、ユースケースを実現させます。特定の クライアントには依存しない実装にします。 主なクラスは、ユースケースクラス、プレゼンテーション層との入出力を定義するクラ スがあります。 「第 7章ユースケース (アプリケーション)層の実装」で詳細に解説します。
プレゼンテーション層 アプリケーション外部との入出力を実現します。JSON でレスポンスを返したり、
HTMLをレンダリングして返したりといった選択はこの層の責務です。 主なクラスは、コントローラー、アプリケーション外部との入出力を定義するクラスが あります。 「第 9章プレゼンテーション層の実装」で詳細に解説します。
インフラストラクチャ層 (以下、インフラ層) 下位のレイヤーで定義されているインターフェイスを実装し、アプリケーションを支え る技術的な機能を提供します。 主なクラスは、リポジトリの実装クラスがあります。
57
第 5章アーキテクチャ
アプリケーション層をユースケース層と呼び替える理由
オリジナルのオニオンアーキテクチャでは「ユースケース層」ではなく「アプリ ケーション層」という名前ですが、本書ではあえて「ユースケース層」という名前 を使っています。 なぜわざわざ名前を呼び変えるのでしょうか。それは、「この層は何をする層 か？」と責務を考えた時に、「アプリケーション層」という名称からは考えにくい からです。「アプリケーション層がすることは…そもそも作っているものがアプリ ケーションだから、全部では？」と混乱を呼んでしまいます。 一方、「ユースケース層」という名称であれば、「この層はユースケースを実現す るんだな」ということが明確になるので、本書ではこちらを採用しています。 もちろん、オリジナルに忠実にアプリケーション層としても問題はありません。 適用するプロジェクトで検討し、しっくり来る方を適用してください。
5.3.2 丸型の表記 なぜこのアーキテクチャが「オニオン」と呼ばれるのでしょうか？ そのヒントをたど るために、丸型に表記してみましょう。(図 5.5)
▲図 5.5 オニオンアーキテクチャ丸型表記
58
5.3 オニオンアーキテクチャ
この丸型は何を意味しているのでしょうか？ これは、「アプリケーション (ユースケース)とその外側に境界があり、その間はアダプ
ターを通じて通信する」という構造を表現しています。矢印はリクエストの向きを表現し ています。それぞれが逆向きにレスポンスを返します。*4
図 5.5を 1段階具体的にしたのが、次の図です。
▲図 5.6 オニオンアーキテクチャ丸型表記詳細
例えば、ブラウザからのリクエストの場合はまず専用のアダプター (コントローラー) で受け、アプリケーションの処理を呼び出します。必要な場合は、アプリケーションから DB接続のアダプター (リポジトリの実装クラス)を使ってデータを取得し、その処理結果 をブラウザに返します。 表記の問題なので当然実装は同じですが、この表記では「ドメイン層が (外界からも)独 立している」ことを強調できます。
*4 フラット表記の場合は省略していましたが、結合テストも外部から実行する際のアダプターの一種として 捉えることができます。
59
第 5章アーキテクチャ
5.4 ヘキサゴナルアーキテクチャ 実践 DDDで紹介されているのはこのアーキテクチャです。別名をポートアンドアダプ ターアーキテクチャと言います。*5
▲図 5.7 ヘキサゴナルアーキテクチャ (*5 から引用)
アプリケーションと外の世界がコミュニケーションをする際は、専用のポートとアダプ ターを作成して通信させるという思想です。 さて、図 5.6と比較してみるとどうでしょう。アプリケーションの中のレイヤの分け方 が違うだけで、基本的に同じ思想であることがわかりますね。つまり、オニオンアーキテ クチャは、ヘキサゴナルアーキテクチャの思想を元にレイヤーを詳細化したもの、と考え ることができるのです。また、このことは後述のクリーンアーキテクチャでも同じことが 言えます。
ちなみに、「ヘキサゴナル (六角形)」は、六角形のコンポーネントが規則的に並ぶグラ フィカルなイメージに由来しており、ポートの数とは全く無関係です。そのため、名称と しては「ポートアンドアダプターアーキテクチャ」の方が実態をよく表していると言える でしょう。
*5 Alistair Cockburnにより 2005年に提唱 <https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)>
60
5.5 クリーンアーキテクチャ
5.5 クリーンアーキテクチャ ヘキサゴナル、オニオンやその他のアーキテクチャを受けて、概念を統合しようとした のがクリーンアーキテクチャです。*6 2018年に日本語版書籍*7が出版され、日本での普及 が進みました。
▲図 5.8 クリーンアーキテクチャ (*6 から引用)
ヘキサゴナルアーキテクチャの Application 層が UseCases 層と Entities 層であり、 Adapters層が Interface Adapters層という対応だと捉えることができます。 層の分け方、名称や責務に細かい違いはありますが、基本的にはヘキサゴナルアーキテ クチャの思想を引き継いでいることがわかります。
5.6 オニオンアーキテクチャ、クリーンアーキテクチャの 比較
基本的にはヘキサゴナルアーキテクチャの思想を引き継いでいるオニオンアーキテク チャ、クリーンアーキテクチャですが、DDDに適用するにはどちらがよいでしょうか。 両方とも適用することは可能ですが、筆者の私見として、複数の点からオニオンアーキ テクチャをおすすめしています。以下、理由を述べます。
*6 <https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html>*7 <https://www.amazon.co.jp/dp/B07FSBHS2V/>
61
第 5章アーキテクチャ
5.6.1 シンプルさ クリーンアーキテクチャに比べて、オニオンアーキテクチャはシンプルです。クリーン アーキテクチャは図の中に登場する要素が多いですが、一般的なWebアプリケーション では考慮不要なものも含まれており、適用する要素の選別に時間と労力がかかります。
5.6.2 レイヤーの責務の思想の違い エンティティ層の責務は「Enterprise wide business rules」とあります。文字通り受け 取ると、「企業一般で適用できるビジネスルール」ということです。 これは、「第 3章 3.2 境界づけられたコンテキスト」で解説した境界づけられたコンテ キストの思想、つまり、「1つの企業の中でも、複数のコンテキストがあり、それぞれのコ ンテキスト内でユビキタス言語を定義する」という思想と合致しません。 レイヤーの名称も「エンティティ層」とありますが、DDDでは「ドメインオブジェク
ト」の一種がエンティティなので、層としては「ドメイン層」としたいところです。ク リーンアーキテクチャを使用する場合は、そこを読み替えないといけません。
以上の理由から、オニオンアーキテクチャは DDD を実装する上で適したアーキテク チャだと考えています。もちろん、違うアーキテクチャを採用してもメリットデメリット をしっかり考慮した上での選択であれば、何も問題はありません。
5.7 境界づけられたコンテキストの実装 さて、第 3章で解説した境界づけられたコンテキストですが、アーキテクチャの解説を 踏まえ、どのように実装されるのでしょうか？ 考え方が一番シンプルになるのが「1コンテキスト 1アプリケーション」です。つまり、 マイクロサービスになるイメージです。 ただし、実装上はコストも大きく、ここまで踏み切れないことも多いでしょう。そうい う場合は少しアレンジを加えることになるのですが、その場合実装コストは下がる一方、 考え方は若干複雑になります。実際はそこのバランスを考えながら最適解を探っていくこ とになります。
62
5.7 境界づけられたコンテキストの実装
5.7.1 1コンテキスト 1アプリケーションの場合 第 3 章で紹介した 2 つの境界づけられたコンテキストに登場するモデルをマッピング
しました。(図 5.9)
▲図 5.9 コンテキスト同士の概念図
これを実装する際は、図 5.10のようにアプリケーションを 2セット作ります。
▲図 5.10 コンテキストのアプリケーション同士の関連図
コンテキスト同士の通信 これらのコンテキストは、どのように通信するのでしょうか。方法としては、同期通信 か、非同期通信かの 2択になります。
63
第 5章アーキテクチャ
• 同期通信：ネットワーク経由のダイレクトコール (REST APIなど)
• 非同期通信：メッセージキューを利用したイベント通信 (AWS SQSなど)
▲図 5.11 コンテキスト同士の通信
この 2択でどちらを選ぶかについては、「リクエスト結果を同期的に取得したい」「非同 期にして先方のサービスがダウンしていても大丈夫なようにしたい」といった、マイクロ サービスを実装する上での技術的要件を考慮して決定します。
5.7.2 1コンテキスト 1アプリケーション以外の場合 1アプリケーションで複数コンテキストを扱いたい場合は、パッケージなどで表現でき ます。(図 5.12)
64
5.7 境界づけられたコンテキストの実装
▲図 5.12 コンテキストをパッケージで表現する場合
まずはここから始めるのもシンプルで良いでしょう。しかし、異なるコンテキスト間 で依存を制御したい場合など、細かいことをやろうとすると逆に複雑になることがあり ます。 まずはパッケージで切っておけば、後からアプリケーション分割はしやすくなります。 複数コンテキスト 1アプリケーションから始める場合も、あとからアプリケーション分割 する可能性を考慮して分割しやすい設計にしておくと良いでしょう。
65
第 6章
ドメイン層の実装
本章では、ドメイン層に実装するクラスの詳細を解説します。 ドメイン層では、DDDで定義されている戦術的設計パターンを使用して、ドメインモ
デルを表現します。戦術的設計パターンは、以下の 2種類に分けられます。
• ドメインモデルを表現するもの (ドメインオブジェクト) – エンティティ – 値オブジェクト – ドメインイベント *1
• ドメインオブジェクトを使用するもの – リポジトリ – ファクトリー – ドメインサービス
エンティティと値オブジェクトは、ドメインモデルを「モノ」として表現するオブジェ クト、ドメインイベントは「コト」として表現するオブジェクトです。
「モノ」として表現するオブジェクトが 2種類ありますが、この違いは何でしょうか？ それは、同一判定の方法です。エンティティは同一判定を識別子で行い、値オブジェクト は同一判定を保持する値で行います。この説明だけでは理解しにくいので、具体的な事例 で解説します。
*1 ドメインイベントは応用編になるので、本書では解説を省略します。詳しくは実践 DDD「ドメインイベ ント」の章が参考になります。
66
6.1 エンティティ
6.1 エンティティ エンティティの例として、「社員」というモデルについて考えます。 山田さんという社員は、ある会社においては社員番号という識別子 123で同一判定され
ます。山田さんは部署が変わろうが、所持金、体重が変わろうが同じ「山田さん」であり、 別人にはなりません。 一方、新しく社員番号が 456 で、名前が同じ山田さんという社員が入ってきたとしま
す。この人は部署、所持金、体重が仮に全部同じだったとしても、123の山田さんとは別 の人物です。 二人を識別する際に使うものは、それぞれが持つ属性値ではなく、社員番号という識別 子です。これがエンティティの同一性の考え方です。また、部署、所持金、体重などの属 性値が変わるということは、本質的に可変なものであるということです。
6.2 値オブジェクト 値オブジェクトの例として、「お金」というモデルについて考えます。 2つの 10円玉が並んでいて、これを「同じ」と判断したいでしょうか？ それは文脈、 モデリングの目的によります。 例えば、山田さんが令和 1年の 10円玉 1つを持っている状況と令和 2年の 10円玉 1
つを持っている状況では、等しく山田さんの所持金は 10円と考えたいのではないでしょ うか。この場合、2つの 10円玉を区別する必要はありません。このような場合、10円玉 は値オブジェクトとしてモデリングするほうが適切です。 しかし、これがコインコレクターの場合は、それぞれの 10円玉を区別して扱いたいか もしれません。これが先ほどの「文脈、モデリングの目的による」という意味です。その 場合はお金をエンティティとしてモデリングすることも検討することになります。
次に値オブジェクトが示す値の変更方法です。例えば、山田さんが所持金が 10円から 100円に増えたとします。このときに 10円玉の数字に取り消し線を書いて、100と書き なおすでしょうか？ そんなことはせず、10円玉を 100円玉と交換するでしょう。10円玉 は製造されたときに保持する金銭的価値は確定しており、あとからいかなることがあって も変わることはありません。これが値オブジェクトの使用方法であり、値オブジェクト自 体が不変であるということです。
値オブジェクトは必ず不変なものとしてモデリングしますが、エンティティは可変にな
67
第 6章ドメイン層の実装
り得ます。しかし、モデリング結果として可変にする必要がなければ、不変なものとして モデリングしても構いません。 一方、同一性の判断は必ず「識別子か、属性値か」というルールに則ります。
6.3 ドメインサービス ドメインサービスは、「モデルをオブジェクトとして表現すると無理があるもの」の表 現に使います。例えば、集合に対する操作などです。 よく使われるのはユーザーのメールアドレスを更新する際の重複チェックです。「指定 されたメールアドレスはすでに使われているか？」と尋ねたいとき、その知識を 1 つの ユーザーオブジェクト自身が答えられる、とするのは無理があります。自分自身のメール アドレスを知っていても、他のオブジェクトの状況については情報を持っていないからで す。こういう場合に、ドメインサービスを使用します。
ただし、極力エンティティと値オブジェクトで実装するようにして、どうしても避けら れない時にのみドメインサービスを使うようにしてください。ドメインサービスは手続き 的になるので、従来の「ビジネスロジック層」の感覚で書いてしまいがちです。そうする と、結局従来のようなファットなクラスが異なるレイヤーに現れただけ、という結果に なってしまいます。 人は意識しないとつい慣れ親しんだやり方に戻ってしまうので、始めたばかりの頃は特 に意識的にエンティティ、値オブジェクトを使用するようにすることが必要です。
6.4 リポジトリ リポジトリは「集約単位で永続化層へのアクセスを提供するもの」です。集約単位で、 という制約を付けている理由は、「第 3章 3.1 集約」で述べたとおり強い整合性が求めら れるオブジェクトについて、ひとまとまりで整合性を確実に保証するためです。 集約のオブジェクトの親となるオブジェクトを集約ごとに 1つ決め、そのオブジェクト を「集約ルート」と呼びます。リポジトリは集約ごとに 1つだけであり、リポジトリに渡 すもの、リポジトリから返されるものは必ず集約ルートのエンティティになり、その他の 子オブジェクトは集約ルートがインスタンス参照した状態で常に扱います。リポジトリか ら子オブジェクトを直接返したり、子オブジェクト用のリポジトリを別途定義したりはし てはいけません。 なお、「第 5章 アーキテクチャ」のオニオンアーキテクチャの節で説明した通り、リポ ジトリはインターフェイスがドメイン層、その実装クラスがインフラ層になります。これ
68
6.5 ファクトリー
により、ドメイン層は永続化手段（DBの種類やテーブル構造、ORマッパーなど）に関 して一切知識を持たなくなり、純粋にドメイン知識だけに集中できるようになります。
設計上のポイントは「リポジトリは Listのように扱う」ということです。ユーザーク ラスの Listがあった時、その Listは「ユーザー登録する」「ユーザーを退会状態にする」 というメソッドは持たないはずです。新規登録状態のユーザー、退会状態のユーザーを addするという使い方をするでしょう。リポジトリも同じです。Listに持たせないような メソッド、つまりドメイン知識 (ルール/制約)を持っていたとしたら、それは責務過剰な のでリポジトリから別のクラスに委譲しましょう。 この方針は、テスト時にも役立ちます。リポジトリが永続化層へのアクセスのみを提供 していれば、テスト時にはリポジトリの実装クラスをオンメモリのモック実装に差し替え ることが容易になります。この際、リポジトリがドメイン知識を実装していると、その部 分のロジックをモック内で再度実装することになり、テスト内容が正しく保証されなくな るリスクが生まれます。
6.5 ファクトリー オブジェクトの生成ロジックが複雑な場合や、他の集約を参照する必要がある場合、生 成の責務を持ったオブジェクトを独立させます。これはドメインサービスの一種と捉える ことができます。 ファクトリーはドメイン知識の表現のために、リポジトリを参照し、使用できます。
6.6 ドメイン層のそれ以外のオブジェクト 重要なことは、ドメイン層にはここで紹介されたパターン以外を使っても問題ないとい
うことです。 デザインパターンや、オブジェクト指向での手法を使うことにより「高凝集・低結合」 にできるなら、積極的に使っていくべきです。実際によく使われるものとして、ファース トクラスコレクション、enumによるドメイン知識の表現といった実装があります。 ドメイン層は「ドメイン知識を表現する」「モデルを直接表現するオブジェクトを書く」 ということが重要です。極論を言うと、それさえ実現できれば、どのような書き方をして も問題はありません。エンティティなどの戦術的設計パターンは、決まりではなく、あく までもベストプラクティスなのです。
69
第 6章ドメイン層の実装
6.7 複数集約間の整合性確保 「第 3章 3.1.3 集約の境界の決め方」で、「複数集約間の整合性確保は、実装コストや難 易度が上がる」と書きました。複数集約間の整合性を確保する方法は次の 2つです。
1. ユースケース層のメソッドで確保する 2. ドメインイベントを用いて結果整合性で確保する
1の方法は、ユースケースクラスの 1メソッドの中で複数集約のオブジェクトをそれぞ れのリポジトリを使って永続化する方法です。実装は簡単ですが、別のユースケースクラ スのメソッドでは整合性を破る処理を書くことが可能になってしまいます。
2の方法は、ドメイン層のオブジェクトの操作に対してイベントを発火させ、別集約の 操作を呼び出す方法です。確実に整合性確保ができますが、技術的に実装が複雑になって しまいます。本書では詳細は割愛します、実践 DDDのドメインイベントの章に解説があ るので、興味がある方は参照してください。
1の方法でも十分に実用可能です。最初はシンプルな 1の方法を取り、慣れてきてから 必要に応じて 2の方法を検討してみるのが良いでしょう。
6.8 Q&A(ドメインオブジェクト)
6.8.1 ドメイン層にロジックを寄せる目的
ドメイン層にロジックを寄せすぎると、修正時に影響範囲が大きくなり、逆に修正しにくくなるのでは ないでしょうか？
この質問は、安定依存の原則 (SDP:Stable Dependencies Principle)を意識したものだ と思います。SDPは、「多数のコンポーネントから依存されたコンポーネントは修正しづ らくなるので、モジュールはより安定した (修正が少ない)モジュールに依存するべきだ」 と言う原則です。 ドメイン層を独立させるという設計は、SDPに則ったものではありません。第 1章で 述べた通り、ドメインモデルは頻繁に更新し、実装にも反映していくものなので、ドメイ ン層に他の層が依存するのはむしろ逆を行っています。では、なぜそのような設計にする のでしょうか。 それは、「最も重要なドメイン層を、独立させて修正しやすくするため」です。 最も避けたいことは、DBやフレームワークの都合で「こんな実装にしたいけどこうい
70
6.8 Q&A(ドメインオブジェクト)
う事情があるからしょうがないんだよね…」というように、理想的ではない実装で妥協す るようなことです。そのような妥協を積み重ねると、モデルと実装が乖離し、目指したい 問題解決ができなくなってしまいます。 そのため、特定の DB やフレームワークに依存せず、層自体を独立させることによっ て、修正しやすさを維持することを目指します。
なお、影響に関しては、テストで対応します。ユースケース層でテストを書けば、ドメ イン層の修正があっても影響範囲は確実に把握することが可能になり、内容に応じて修正 判断できるようになります。
6.8.2 プリミティブ型の使用可否
すべてを値オブジェクトにするのが好ましいのはわかっているのですが、時間や工数的な意味合いであ る程度端折ってプリミティブ型を使うことも多いです。実際はどこまで妥協しても良いでしょうか？
「すべてを値オブジェクトにするのが好ましい」とありますが、なぜでしょうか？ 第 1章の「課題ドリブン」の節で、解決したい課題を明確にして判断しよう、というこ とを書きました。値オブジェクトにする目的を明確にし、それに合うなら値オブジェクト に、合わないならプリミティブ型を使う、といった判断ができれば良いでしょう。 理由もなく、どのようなシチュエーションでもすべてを値オブジェクトにしなければい けない、と言うことはありません。
6.8.3 DBの値からインスタンスを再構成する方法
コンストラクタ内に生成条件(初期状態)を実装した場合、DBから取ってきた値はどのように反映する のでしょうか？
専用のコンストラクタを設けます。このコンストラクタはすべての属性の値をそのまま 受け取り、バリデーションをしません。
Javaのようにパッケージプライベートの可視性がある場合は、このコンストラクタの 可視性をパッケージプライベートにし、同じパッケージのリポジトリからは呼べますが他 のパッケージ (特にユースケース層のクラス)からは呼べないようにします。パッケージ プライベートがない場合は、「fromRepository」や「reconstruct」といった命名規則で回 避します。
71
第 6章ドメイン層の実装
6.8.4 再構成メソッドを書くべきレイヤー
エンティティ・値オブジェクトの再構成用のコンストラクタは、 ドメイン知識を表現しているわけではないのでインフラ層の責務ではないでしょうか？
たしかに、そのように捉えることは可能です。しかし、実際にドメイン層に再構成コン ストラクタを持たせず、インフラ層のみで実現しようとすると、Javaの場合はリフレク ションの利用が避けられなくなります。そして、その場合は型の恩恵が受けられなくなる という大きなデメリットが生じてしまいます。 ここは実際のメリット/デメリットを考慮して、ドメイン層のエンティティに再構成用 のコンストラクタを持たせるのが現実解だと考えています。 この判断は言語にもよりますので、第 1章でも述べた通り課題ドリブンで、解消したい
課題とメリット/デメリットを考慮して判断してください。
6.9 Q&A(リポジトリ)
6.9.1 ドメインオブジェクトと DBの対応
基本的に、ドメインオブジェクトのフィールドは、DBにおける該当テーブルのカラムと1対1で対応す るという認識で合っていますか？
そうとは限りません。対応させることもできますし、させないこともできます。 一部のカラムはテーブルを分けたり、(適切と判断できればですが) 一部の複数の項目
を json型のカラムにまとめたり、といった選択も可能です。オブジェクトのデータ自体 を 1 つの状態ではなく履歴型で保存するような選択肢もあります。また、テーブルには updateAtといったドメインオブジェクトには存在しないカラムを設けても良いのです。 リポジトリのインターフェイスがドメイン層、実装クラスがインフラ層で、依存の方向 がインフラ層からドメイン層の向きであるのはそこにポイントがあります。ドメイン層で はインフラ層の影響を受けない抽象的なオブジェクトを定義し、インフラ層はインフラ層 の事情 (パフォーマンスやトラッキング要件)などを考慮して最適な判断をすることがで きるのです。 この自由度が生まれることは、Active Record型ライブラリを使用してテーブルとオブ
ジェクトが 1対 1に制限されるときには無い面白さです。
72
6.9 Q&A(リポジトリ)
6.9.2 ソートの実装方法
ソートはどこで行うのが良いのでしょうか？
リポジトリのインターフェイスでは、永続化層に依存しない抽象的な実装 (enumなど) でソート順を引数で指定できるようにします。そして、実際のソート処理のためのクエ リ組み立てなどはインフラ層のリポジトリ実装クラスで行います。永続化層が RDBの場 合、引数で指定された内容を元に order by句を作成します。 このようにすると層の責務の矛盾なく、ソートキーを可変にできます。
6.9.3 キャッシュの実装方法
リポジトリのデータをパフォーマンス上の制約からキャッシュしたいとき、キャッシュはどこでどのよ うに実装すればいいでしょうか？
リポジトリでキャッシュを考えるより、CQRS の使用を検討するのが良いでしょう。 「第 8章 CQRS」で詳しく解説しますが、概要としてはドメイン層のモデルとは別に、参 照に特化したクエリ用のモデルを定義するのです。クエリパフォーマンスをあげるのであ れば、クエリモデルで情報取得するところでキャッシュ、という方が役割としては適切と 考えられます。
6.9.4 外部 APIとリポジトリの関係
Twitterのような外部APIを利用する時も、リポジトリパターンを使うのが良いでしょうか？
外部 APIに渡す値、外部 APIから取得する値が、ドメインモデルとして意味を持つの であれば、ドメイン層のものとして定義してリポジトリで設計します。 そうではない例として、通知を扱う例を考えます。ユースケースとして通知を行い ますが、ドメインモデルとしては定義しないと判断した場合は、ユースケース層に NotificationAdapterといった名前のインターフェイスを定義し、実装クラスはインフラ 層に配置します。Adapterという名前は、ポートアンドアダプターパターンから引用して いますが、他にしっくりくる名前があればそちらを選択してください。
73
第 6章ドメイン層の実装
6.9.5 外部 APIから取得した値の詰め替え方法
APIからデータを取ってきて、それをドメインオブジェクトに変換する際は「リポジトリの実装クラス 内でAPIを呼び出し、取得したデータをドメインオブジェクトに変換する」という処理で良いでしょう か。それとも「ユースケースクラスでMapper的なクラスを呼び出す」のが良いのでしょうか？
前者の選択肢が良いです。リポジトリのインターフェイスはドメイン層であり、ドメイ ンの知識としては「どういう条件を指定したらどういうオブジェクトが取得できるか」と いう定義 (What)にだけ関心があり、その Howは隠蔽したいのです。APIの呼び出し方 や、取得結果を戻り値のオブジェクトに変換する方法はあくまでインフラ層の関心ごとに なるので、インフラ層のクラスの中で完全に隠蔽するのが望ましいです。
6.9.6 エンティティ同士の紐付け
User→Taskという1:Nのエンティティがあったとします。 この関係を表すには、以下のどちらの実装が良いでしょうか？
案1. TaskクラスにUserIdを持たせる 案2. UserクラスにTaskのListを持たせる
これは集約の設計に依存します。「第 2 章 2.1.2 ドメインモデル図」で解説した通り、 オブジェクト間の参照関係は、集約内はインスタンス参照、集約外は ID参照です。その ため、Taskと Userが異なる集約なら案 1、同じ集約なら案 2になります。 案 1で Taskと Userの紐付けを変更する場合、Taskに assignUser(UserId userId
)と言ったメソッドを持たせます。また、「ステータスがアクティブな Userのみアサイン 可能とする」というバリデーションを入れたい場合、引数に IDではなく Userオブジェ クト自体を渡す事も可能です。 一方、案 2 の場合、変更前の User 内部の Task の List から該当する Task を除外し、 新しいアサイン先の User内部の Listに追加します。この場合両方の Userをリポジトリ に渡して保存する必要があります。これは若干違和感があるように思えますが、それは Task と User の集約が同じであることに無理があることが原因です。こういった気付き があったら、その段階で集約範囲を変更し、案 1の実装に切り替えます。
6.9.7 リポジトリのインターフェイスを定義するレイヤー
74
6.10 Q&A(その他)
リポジトリのインターフェイスを、ユースケース層ではなくドメイン層に置く理由はありますか？
ドメイン層のオブジェクトで、集約の範囲を明示するためです。リポジトリのメソッド はエンティティや値オブジェクトをどの単位で永続化するかを定義するので、この定義が ユースケース層にある場合、ユースケースによって集約の境界が異なってしまう可能性が あります。集約はドメインモデルの設計上非常に重要な意味を持つので、ドメイン層で確 実に定義する必要があります。 実装上の都合でいうと、ドメイン層のドメインサービスからリポジトリを参照する必要 性は時に発生しますが、ユースケース層に定義すると参照できなくなってしまうのも困り ます。
6.9.8 一部カラムを更新するときの扱い
エンティティの一部分だけの更新をしたい場合、一部分だけリポジトリに渡すのでは無く、エンティ ティを丸ごと渡して丸ごと更新する必要がありますか？
その通りです。リポジトリは必ず集約単位で更新処理を行います。集約は「必ず守りた い強い整合性を持ったオブジェクトのまとまり」なので、整合性を集約ルートのオブジェ クトに管理させます。一部のデータを直接永続化をしてしまうことは、整合性の管理がで きなくなってしまうために避けます。
6.9.9 ドメインオブジェクトからリポジトリ操作の可否
ユースケースからではなく、エンティティからリポジトリを利用して、DBからの取得や更新などの操 作をしても良いものでしょうか？
エンティティが複数の責務を持つことになるので、非推奨です。第 4 章で解説した通 り、一般的に責務が増えることは凝集度が下がり、可読性や保守性を下げます。
6.10 Q&A(その他)
6.10.1 ドメインサービスの命名
75
第 6章ドメイン層の実装
ドメインサービスも責務に応じた名前が付けられると思います。 何からの距離計算をするサービスに対して、「DistanceCalculationDomainService」ではなく 「DistanceCalculator」といった「Service」がつかない名前でも問題ないでしょうか？
特に問題ありません、名前が適切になるのは良いことです。その場合は命名規約を作 り、「Service」をつける、つけないは統一しましょう。
6.10.2 リポジトリを通じた削除方法
リポジトリでエンティティを削除する場合、削除対象のエンティティを渡すのか、IDだけ渡すのか、ど ちらが良いでしょうか？
IDだけで良いでしょう。集合に対する操作として、削除したいオブジェクトを識別子 で指定して削除する、と言うことは概念としても矛盾がありません。 実装面でも、取得結果を別の用途で使う場合を除いて、削除対象のエンティティを一度 取得するコストは無駄になるので不要です。
76
第 7章
ユースケース (アプリケーション) 層の実装
本章では、ユースケース層に実装するクラスの詳細を解説します。 エヴァンス本のレイヤードアーキテクチャや、オニオンアーキテクチャの原本では「ア プリケーション層」という名前ですが、責務を明確にするために本書は「ユースケース層」 という名前で呼び換えています。詳しい理由は「第 5章 5.3 オニオンアーキテクチャ」の コラムに書いてあるので、そちらを参照してください。 同様に、アプリケーションサービスクラスもユースケースクラスと呼び換えています。
7.1 ユースケース ユースケースクラスは、ドメイン層のクラスが公開しているメソッドを組み合わせて、 ユースケースを実現します。具体的には、ドメインオブジェクトの生成や状態の変更、リ ポジトリを使用した永続化などを行います。 第 2章のタスク延期のユースケースクラスを見直しましょう。
▼リスト 7.1 TaskPostponeUseCase.java
public class TaskPostponeUseCase { @Autowired private TaskRepository taskRepository; @Transactional public void postpone(Long taskId) {
Task task = taskRepository.findById(taskId); task.postpone();　 taskRepository.save(task);
} }
77
第 7章ユースケース (アプリケーション)層の実装
ドメイン知識 (ルール/制約)をドメイン層のクラスに実装できると、ユースケースクラ スには抽象度の高い、ユースケース記述のような実装が残ります。 リスト 7.1の postponeメソッドでは、「更新対象のタスクを取得し、延期を指示し、保 存する」ということ (What) を行なっていますが、延期をどのように処理するか (How) はドメイン層のクラスに隠蔽されています。 ドメイン層が整合性を保証できるメソッドのみを公開していれば、ユースケース層はそ れを組み合わせることで安心してユースケースを実現できます。この組み合わせを行うこ とが、ユースケースクラスの責務ということになります。
7.2 ユースケースからの戻り値クラス ユースケース層からプレゼンテーション層に返す値の型については、以下の 2つの方針 が考えられます。
1. 専用の戻り値クラスに詰め替えて返す 2. ドメイン層のクラス (ドメインオブジェクト)をそのまま返す
長期的に保守性を高めるには、1の方が有利です。1のメリットデメリットを比較する と、以下の通りです。
• メリット – ドメインオブジェクトに、プレゼンテーションに関連する処理が混入するのを 防げる
– ドメイン層の修正の影響を、プレゼンテーション層が直接受けなくなる
• デメリット
– ドメインオブジェクトからの詰め替えコストが発生する
2の選択肢は、1のメリットデメリットの裏返しとなります。
ドメインオブジェクトをプレゼンテーション層に渡してしまうと、表示に関わるメソッ ド (数値の書式を変換するなど)をついドメインオブジェクトに生やしてしまいがちです。 ドメインオブジェクトの責務はドメイン知識 (ルール/制約)を表現することなので、表示 に関する処理は責務外の処理になります。このような事態を最初から防ぐために、ドメイ ンオブジェクトを返さない、というのは有効な方針です。 最初は、詰め替えコストを嫌がって 2の選択肢を取りがちですが、気がついたらドメイ
78
7.3 Q&A
ンオブジェクトが責務外のメソッドで膨れ上がっている (低凝集になっている)、という事 態を誘発します。それを回避するには、1の選択肢を取るのが良いでしょう。
戻り値クラスの名称 ユースケース層の戻り値専用クラスの名称は DDDで特に定義はされていないので、プ
ロジェクトごとに決める必要があります。 本書では、このクラスを DTO(Data Transfer Object)と定義しています。DTOとい うのはレイヤ間の受け渡しに広く使われがちですが、ユースケースからの戻り値のみに使 用し、他のクラスは別の名称を使用します。命名の例を図 7.1に示します。
▲図 7.1 値受け渡しクラスの命名例
7.3 Q&A
7.3.1 クラスの分割単位
ユースケースクラスは、どのような粒度で分割するのが良いでしょうか。
「1 クラスに 1 パブリックメソッド」とするのが良いでしょう。1 クラスに複数のパブ リックメソッドを書くと、凝集度が下がり、保守性が下がります。具体的なデメリットと して、次のようなものがあります。
• 複数メソッド分の依存クラス (リポジトリなど)やプライベートメソッドを持つこ とになり、参照関係が追いにくくなる
• テストクラス側のメソッド数がその数倍に増えて対応がわかりにくくなる
79
第 7章ユースケース (アプリケーション)層の実装
この対応として、パブリックメソッド単位でクラスを分割すると、ユースケースの凝集 度が高まり、保守性が高まります。共通の処理が欲しくなった場合は、プライベートメ ソッドではなく、その責務を負ったクラスとして切り出すのが良いでしょう。例えば、共 通の変換処理があればコンバーターと名のつくクラスとして切り出し、複数ユースケース クラスで共有する、といったものです。
この方針は YAGNI(必要になったら) でも構いません。最初は 1 つのクラスにまとめ て、明らかに分割が必要になってから分割するのも選択肢の一つです。 ただし、1クラスに複数メソッドを詰め込む理由が、「慣習」「面倒くさい」といった理 由ではないか、考えてみましょう。高凝集・低結合の原則を思い出してください。ユース ケースクラスの責務は明確で、保持するデータと、メソッドは関連があるでしょうか。関 連が薄い場合、それは低凝集となり、可読性や保守性が下がるのです。
7.3.2 命名規則
ユースケース層のクラスの命名規則や、ユースケースを実行するメソッドの命名規則はどのようにすれ ば良いでしょうか？
これはプロジェクトごとに決めて良いものですが、一例として紹介します。 メソッド名は、ユースケース図の吹き出し一つに該当するような名前にすることが多い です。吹き出しで「タスクを作成する」だったら createTaskといった形です。 クラス名は、1クラスに複数メソッドある場合は動詞を抜いたような名前 (TaskUseCa
se)、1クラスに 1メソッドの場合はメソッド名に UseCaseをつけた名前 (CreateTaskU
seCase)にすることが多いです。
80
第 8章
CQRS
CQRS(Command Query Responsibility Segregation: コマンドクエリ責務分離) は、 DDD を実装する上で避けられない課題を解決する方法です。レイヤーとしてはユース ケース層に定義する内容になりますが、ボリュームが大きいためユースケース層に続いて 独立した章として解説します。
8.1 DDDの参照系処理で発生する問題 DDDの戦術的設計パターンを使っていると、永続化層との入出力はリポジトリを使う ことになります。更新系の処理では、エンティティや値オブジェクトでドメイン知識を表 現し、リポジトリを使って集約単位で永続化するという構成をとると、非常に保守性の良 いものになります。 しかし、参照系の処理、特に一覧画面で複数の集約の情報を表示したいような場面で、 リポジトリを使用するだけだと問題が発生することがあります。
例として、次のようなケースを考えます。タスク、ユーザー、ラベルという 3つの集約 があり (図 8.2)、それぞれにリポジトリがあるとします。
81
第 8章 CQRS
▲図 8.1 サンプルドメインモデル
そのような場合に、以下のようなタスク一覧画面を作成することになりました。
▲図 8.2 タスク一覧画面の表示例
これを 1つのユースケースクラスで実現しようとすると、3つのリポジトリからそれぞ れ値を取得し、戻り値のクラスに詰め替えるような実装にせざるを得ません。すると、以 下のような問題が発生します。
• 複数の集約から値を取得して戻り値の型に詰め替える処理が、ループが増えて読み にくいコードになる
• 画面に返す必要のない値を取得するのでパフォーマンスが悪化する
• 複数集約の条件で絞り込んでのページングができない
図 8.2のような一覧画面が必要になることは多いので、ほとんどのプロジェクトで突き 当たる問題です。
82
8.2 解決策
8.2 解決策 CQRSを導入します。CQRSとは、「参照に使用するモデルと更新に使用するモデルを 分離する」というアーキテクチャです。モデルという言葉は多義語ですが、この文脈では アプリケーションコード上のモデル、つまり更新系のクラスと参照系のクラスを分けると いうことになります。
▲図 8.3 CQRS 概念図
更新系モデルは、ドメインオブジェクト (エンティティ、値オブジェクトなど)をその まま使用します。 参照系モデルは、特定のユースケースに特化した値の型を定義します。また、その値
を取得するためのサービスも独自に定義します。例として、以下のようなクラスになり ます。
▼リスト 8.1 TaskDto
public class TaskDto { private String taskId; private String taskName; private String userName; private String labelName;
}
▼リスト 8.2 TaskQueryService
public interface TaskQueryService { public List<TaskDto> fetchByUserId(UserId userId);
}
83
第 8章 CQRS
本書では参照用モデルの型を DTO、それを取得するためのサービスをクエリサービス という命名にしています。これは公式な定義は特にないので、各プロジェクトで決めてく ださい。
8.2.1 参照用モデルの型を定義するレイヤー 参照用モデルの型を定義するクラスは、アーキテクチャ上どのように位置付けられるの でしょうか。 クエリサービスのインターフェイスと戻りの型をユースケース層に、クエリサービスの 実装クラスはインフラ層に配置します。ユースケース層は「引数でこのような条件を指定 すると、このような型で返ってくる」という抽象的な知識 (What)だけ持ち、値の取得に 関する具体的な知識 (How)はインフラ層に隠蔽します。(クエリサービスのインターフェ イスがドメイン層ではなくユースケース層である理由は後述します)
▲図 8.4 オニオンアーキテクチャにおける CQRS
永続化層が RDBの場合、クエリサービスの実装クラスでは DTOに詰め替えるのに必 要な値を取得するクエリを書きます。この際のクエリは、複数テーブルを JOINして 1リ クエストで取得する、必要なカラムのみ SELECTする、というようにパフォーマンスを 最適化させるために自由に記述することができます。このチューニングが自由になること がリポジトリを使用する場合との大きな違いです。 また、クエリを実装する方法も、保守性を考慮して最適な方法を選ぶことができます。 直接 Stringで SQLを書いても、クエリビルダのようなライブラリを使用しても良く、更 新系で使用しているものとは異なるライブラリを使用しても構いません。
84
8.3 メリット、デメリット
なお、筆者が Javaのプロジェクトで実装するときは、リポジトリもクエリサービスも jOOQ *1というタイプセーフにクエリを実行できるライブラリを使用しています。
8.3 メリット、デメリット 前述の問題の裏返しになりますが、以下のようなメリットがあります。
• 複数集約にまたがるデータを取得する際のコードがシンプルになり、保守性が高 まる
• クエリパフォーマンスが上がる、チューニングしやすくなる
• 複数集約の条件で絞り込んでのページングができるようになる
一方、デメリットは以下のようなものがあります。
• ドメインオブジェクトのデータが参照されている場所が追いにくくなる
• アーキテクチャ自体が複雑になり、理解にコストがかかる
デメリットの 1つ目について補足します。CQRSを使用しない場合、ドメインオブジェ クトのデータがどこで使用されるかを調べるためには、ドメインオブジェクトのゲッター から参照元を追えばすべて把握できます。しかし、CQRS を使用すると、参照系のオブ ジェクトが別途作られることにより、その方法ではすべての参照が追えなくなってしまい ます。
このように、メリットは非常に大きいですが、デメリットも確実にあるため、常に使用 すれば良いというものではありません。しかし、「問題」の最後に述べた通り、DDDを用 いている限りは避けられない重要な問題を解決する手法です。問題の大きさ、メリットデ メリットを考慮して導入判断できることが重要です。
8.4 実装時の注意事項 8.4.1 部分的導入の可否 誤解されることがありますが、CQRSは部分的な導入が可能です。 つまり、「参照用モデルと更新用モデルを完全に分ける必要はない」ということです。 必要なところだけ参照に特化したモデルを導入するのが適切です。
*1 <https://www.jooq.org/>
85
第 8章 CQRS
8.4.2 型を定義するレイヤーがユースケース層である理由 なぜ参照用モデルの型をユースケース層に定義するのでしょうか。それは、最適な参照 用モデルは個別のユースケースに依存したものだからです。 例えば、図 8.2 のタスク一覧画面とはとは別に、自分のタスクだけを表示する画面が あったとします。(図 8.5)
▲図 8.5 自分のタスクを表示する画面
その他に、ユーザーごとに最後に完了したタスクを表示する画面もあったとします。 (図 8.6)
▲図 8.6 最後に完了したタスクを表示する画面
表示時に取得する内容は画面、ユースケースによって異なっています。そのため、取得 内容を定義する型は個別に定義するべきものです。そして、ドメイン知識 (ルール・制約) は一切表現していないので、ドメイン層の責務には含めるべきではないでしょう。以上の ことから、ユースケース層に定義します。
また、これらの戻り値の型は完全に一致しない限り使い回すべきではありません。ある DTOには 10個の項目があり、ユースケース Aでは 1～5個目を、ユースケース Bでは 3, 4, 7～10個目を使用する、ユースケース Cでは・・・という風に最大公約数な項目を 持つ DTOを定義してしまうと、どこで何を使っているのかがわからなくなり、肥大化し て保守性がどんどん落ちていきます。
86
8.5 よくある誤解
ここでも責務を意識することが重要です。ユースケース A、B、Cで使い回すクラスは、 「このクラスは何をするクラスか？」という問いに端的に答えられるでしょうか？ ユース ケースごとに型を分ければ、「このクラスは×××ユースケースで取得する値を表現する クラス」というように責務が明確に定義できます。
8.4.3 更新系との整合性を確保する方法 ユースケース層でテストを書きましょう。参照処理だけのテストだけでも書くのが最低 限ですが、業務上重要な部分に関しては、更新処理との結合テストを書くと良いでしょう。 例えば、承認処理をした結果を一覧画面に反映する、と言ったケースでは、承認処理の ユースケースと、参照処理のユースケースを続けて呼び出すテストを書きましょう。 モデルを分けても、テストさえあればバグの混入を防ぐことは可能です。
8.5 よくある誤解 8.5.1 データソース分離の必要性 データソースを分離するアーキテクチャは、以下のようなものです。
▲図 8.7 データソースを分離するアーキテクチャ
「CQRS = データソース分離」と思われることがありますが、これは誤解です。 データソース分離は、別の問題の解決のために行う、モデル分離の次のステップと考え ることができます。解決する問題は、パフォーマンス問題です。 参照系処理のパフォーマンスを上げたい場合、参照用インスタンスを更新系のレプリカ にすれば、参照系のインスタンスだけスケールアウトするなどのパフォーマンスチューニ ングが可能になります。インスタンス単位で分けなくても、参照系処理向けにマテリアル ビューを作成する、というものデータソース分離の一環として考えることができます。 また、更新系処理のパフォーマンスを上げたい場合は、更新時には NoSQLに高速に書
87
第 8章 CQRS
き込んでおき、参照時には集計結果を表示するといった手段などが選択可能です。 データソース分離が解決する問題はモデル分離とは別のものなので、きちんと問題と解 決策が対応しているかを判断して、導入を判断する必要があります。
8.5.2 イベントソーシングとの関係 「CQRS = イベントソーシング」も誤解です。 こちらも CQRS の文脈でよく一緒に出てくるので混乱しやすいですが、「CQRS とイ ベントソーシングは相性が良い」というだけであり、その二つは別で考えることができ ます。 イベントソーシングとは、データ永続化時にドメインオブジェクトの状態をそのまま保 存するのではなく、「ユーザーが登録された」「タスクが完了された」といった イベントそ のものを永続化する というアーキテクチャです。 参照時にすぐクエリできるように、参照用データを別途集計する処理を挟むと、必然的 に参照/更新のモデルの分離や、データソースの分離が行われます。 つまりイベントソーシングは CQRS、データソース分離と併せて導入されますが、
CQRS=イベントソーシングではないのです。 なお、イベントソーシングの導入目的はパフォーマンス最適化以外に、データを積み上 げ型で永続化して証跡を残せることや、データ更新によるバグ発生を防ぐことなどが挙げ られます。
8.6 Q&A
8.6.1 クエリサービスの分割判断
1回DBから取得した結果を用いて再度検索をしたい場合、ユースケースクラスで複数のクエリサービス を使っても良いでしょうか？ それとも、1つのクエリサービスでユースケースを通さず、全処理を行っ てDTOを作るほうが良いのでしょうか？
2つの検索の関係がシンプルであれば、1つのクエリサービスでも良いと思います。 1つ目の検索結果に応じて 2つ目の検索条件を変えるなど、クエリサービス内の処理が 複雑になる場合は、分離した方がテストが書きやすくなるので良いでしょう。
8.6.2 DTOとして返した値の扱い
88
8.6 Q&A
クエリサービスが返すDTOは、コントローラー側でテンプレートエンジン用のViewModelや、APIが返 すjson用クラスなどに変換するイメージでしょうか。
まさしくその通りです。クエリサービスの戻り値はクライアントに依存しない抽象的な 型で、コントローラーがそこからクライアントに応じたクラスに詰め替えるのです。
8.6.3 参照用モデルの使い所
何らかのマスタデータを使用する際、そのマスターのメンテナンス画面では更新用モデルを使うと思い ますが、セレクトボックスなどで表示用にデータを取得するのはクエリサービスでよいのでしょうか？
「8.4.1 部分的導入の可否」の節で、「必要なところだけ参照に特化したモデルを導入す る」のが良いと書きました。どのような画面でも、参照用モデルを定義する必要性がなけ れば、更新用モデルであるドメインオブジェクトを使用します。 そのため、セレクトボックスのデータを取得するのに、何らかの必要性がなければクエ リサービスを定義せず、リポジトリを利用する方法で構いません。
8.6.4 実装の都合にドメイン層が影響を受ける場合
N+1クエリやトランザクションの都合に合わせて、泣く泣くドメインモデルを変更することがあるので すが、そのようにアプリケーション全体の観点から仕方なくドメインモデルを曲げられることはありま すか？
トランザクション範囲を考慮して集約の範囲を検討することは必要なことなので、よく あります。 しかし、N+1問題という参照時の (しかも、使用するライブラリにも依存する)問題に 起因してドメインモデルが歪められるのは望ましくありません。そのような事情はインフ ラ層に隠蔽できないか検討し、必要であれば CQRSの導入も選択肢に入れます。
8.6.5 集約内の一部の値だけ取得したい場合の対応方法
89
第 8章 CQRS 集約内の要素である大きめの値オブジェクトだけデータを取得したい場合はどのようにすれば良いで しょうか？
基本的にはリポジトリでドメインオブジェクトを取得し、ユースケースの処理で必要な 項目だけ詰め替えれば良いですが、パフォーマンスが問題になる場合は CQRSの導入を 検討します。
90
第 9章
プレゼンテーション層の実装
本章では、プレゼンテーション層の実装に関する詳細を解説します。
9.1 プレゼンテーション層の処理概要 プレゼンテーション層は、クライアントとアプリケーションの入出力を実現します。そ のために、クライアントとユースケース層の間に位置し、リクエスト/レスポンスの変換 を行います。
▲図 9.1 異なる種類のクライアント
あるコントローラーでは json 形式のリクエストを受け、json 形式のレスポンスを返 しますが、別のコントローラーでは HTML のフォームから application/x-www-form-urlencoded形式のリクエストを受け、HTMLをレンダリングして返すかもしれません。 その時、ユースケースクラスのリクエストとレスポンスは、特定のクライアントに依存し ない、ピュアなオブジェクト (Javaではいわゆる POJOと呼ばれるもの)にします。
91
第 9章プレゼンテーション層の実装
これは、1つのアプリケーションの中で複数のプロトコルのコントローラーが存在しな くても必要です。「クライアントとアプリケーションの入出力の実現」という責務をプレ ゼンテーション層で完結させることにより、プレゼンテーション層、ユースケース層以下 の凝集度を高め、可読性や保守性を高めることができます。
9.2 プレゼンテーション層のクラス、ファイル この層には一般にコントローラーと呼ばれるクラスが定義されます。それ以外に、
HTML テンプレートや、使用するWeb アプリケーションフレームワークに応じたルー ティング設定ファイルもこのレイヤーのものだと考えられるでしょう。 クライアントとの入出力に必要なものは、すべてこのレイヤーのものになります。
9.3 リクエスト仕様の定義 リクエスト仕様の定義として、通信プロトコル、エンドポイント、パラメーターといっ たことを決定します。 例として、プレゼンテーション層が jsonリクエストを受ける APIの場合、APIドキュ メントとしてその仕様を公開します。HTMLレンダリングするプレゼンテーション層の 場合はそのように仕様が明示されませんが、何らかの実装で暗黙的に意思決定をしている ことは同じです。 コントローラーの実装は多くの場合Webアプリケーションフレームワークに強く依存 しますが、その依存をプレゼンテーション層のみに限定できれば、ユースケース層以下は 特定のフレームワークに依存しない実装にすることが可能です。
9.4 レスポンス仕様の定義 レスポンスの仕様を定義します。HTML レンダリングを行うコントローラーの場合、
UIにまつわるもの (色、文字の書式など)を決めるのもプレゼンテーション層の責務です。 特に書式に関するものがこの層の責務であるということは重要です。例えば、ユース ケースが数値を表す型で「1000」という数値を返したものを、画面ではカンマ区切りで単 位をつけて表示するとします。(図 9.2)
92
9.4 レスポンス仕様の定義
▲図 9.2 数値の書式変換
この変換に関する責務を持つのは、プレゼンテーション層です。ユースケース層やドメ イン層のオブジェクトが、保持する値を表示用にフォーマットするメソッドを持っていた ら、それは責務違反となります。凝集度が下がり、結果として可読性、保守性を下げるこ とになります。これは避けるべきです。(図 9.3)
▲図 9.3 責務違反となる処理
そのような処理は、プレゼンテーション層の責務として行うべきです (図 9.4)。方法と してはコントローラーごとにメソッドを追加する、型に対応したコンバーターを作成する などが考えられます。この最適解は内容によって異なるので一意に示せませんが、まずは レイヤーの責務を守ることが重要です。
93
第 9章プレゼンテーション層の実装
▲図 9.4 レイヤーの責務を守った処理
Ruby on Railsのコントローラーとの違い
本章で解説しているコントローラーは、Ruby on Rails のコントローラーとは 全く別の責務を持つものです。
Ruby on Rails では、基本的には Model、View、Controller の 3 つでアプリ ケーションを構成します。この場合の各モジュールの責務を整理すると以下のよ うになります。
▲図 9.5 Ruby on Rails の MVC
これらのモジュール同士は責務の切り分けがうまくできておらず、各モジュー ルが複数の責務を負っている＝凝集度が低い、特定の責務を複数のモジュールを
94
9.5 Q&A
結合しないと完結できない=結合度が高い、という設計になっています。繰り返し になりますが、低凝集・高結合になると可読性や保守性が下がります。 ファットモデル、ファットコントローラー問題の根本原因は、各モジュールの 責務分割がきちんとできていないことだと考えられます。
9.5 Q&A
9.5.1 コントローラーの処理内容
コントローラーはアプリケーション層に置き、プレゼンテーション層はUI的な物を置くイメージでし た。 なぜコントローラーがプレゼンテーション層になるのでしょうか？
名称が同じなため、Railsのコントローラーと混同してしまうことがありますが、別のも のです。図 9.5と、第 4章のオニオンアーキテクチャの節の図を見比べてみてください。
9.5.2 プレゼンテーション層における値オブジェクト生成
コントローラーで値オブジェクトを生成して良いでしょうか？
値オブジェクトはドメイン層のオブジェクトで、整合性が確保された生成メソッドのみ 公開します。ドメインオブジェクトの公開されたメソッドを組み合わせて、ユースケース を実現するのは、ユースケース層の責務です。そのため、値オブジェクトの生成を行うの はユースケース層に寄せる方が適切だと考えます。 なお、例外的に IDを表す値オブジェクトだけはコントローラーで生成を許可すること があります。生成時にロジックが含まれることがあまりなく、ユースケースメソッドの引 数がどのオブジェクトの識別子かが型で表現できるため、後続の処理が書きやすくなるた めです。 このように「この場合は OK」というルールが言語化でき、保守性が高まるのであれば 例外をルール化することは価値があると考えられます。
95
第 10章
アーキテクチャ全般・ライブラリ など
本章では、アーキテクチャ全般にまたがる話題や、その他ライブラリ、フレームワーク、 言語、ツールと言った話題について解説します。 本章の内容は、他の章に比べて言語の影響を受けやすいものになります。ここでは Java
前提での解説を行うため、異なる言語で適用する場合は適宜読み替えが必要になります、 ご了承ください。
10.1 例外処理 例外処理の方針は言語によって大きく異なります。検査例外がない、例外ではなく
Either などで処理を行うのが通常といった言語の場合は、基本的な発想のみ参考に読み 替えてください。 また、例外を使っての処理方針はさまざまな考え方があるため、ここで紹介する方針は 一例として参考にしてください。
10.1.1 例外の種類 例外は大きく以下の 2種類に分けることができます。
• 想定外の例外
• 想定通常のユースケースで発生しうる例外
例外処理は、この種類に応じて方針を切り分けることが重要です。
96
10.1 例外処理
想定外の例外 サーバー側の問題で、500系のレスポンスを返すような場合です。 代表的なものとしては、メソッド呼び出しの前提条件を満たさない場合のエラーがあり ます。not null と定義されている引数に null を渡してしまった場合や、配列で存在しな いインデックスを指定して取得した場合などが挙げられます。 他にも、外部リソース*1 との入出力で、接続エラーや値の読み込みエラーといったもの
も一般的です。 また、データの整合性が想定外に崩れている場合 (データ Aがあれば Bがあるはずな
のに、取得したら結果が 0件といったケース)も、アプリケーション側の問題なのでこち らに該当します。
このような例外が発生した場合、ユーザーは通常ユースケースとしての回避策がないた め、内部エラー時の共通のレスポンスを返すことになります。 実装方法としては、非検査例外を投げ、プレゼンテーション層の共通クラスで一律 キャッチします。キャッチした共通クラスにおける返し方はクライアントの種類によって 変わります。共通のエラーページの HTMLを返すか、エラー用の jsonレスポンスを返す のが良いでしょう。
通常のユースケースで発生しうる例外 こちらは、クライアント側の問題で、400系のレスポンスを返すような場合です。いわ
ゆるバリデーションでエラーだった場合などです。注意しなければいけないのは、内容に 応じてその例外を投げるレイヤーは異なるということです。それぞれのレイヤーの責務 に応じたバリデーションを行い、異常があればそのレイヤーで定義している例外を投げ ます。
まず、プレゼンテーション層が例外を投げるのは、API仕様としてリクエストパラメー ターの必須/任意や最大文字数などの制限を公開しており、リクエストがその条件を満た さなかった場合です。その仕様を定義しているプレゼンテーション層でチェックし、例外 を投げます。(もしくは例外を使わずエラーレスポンスを返します)
ドメイン層では、ドメイン知識 (ルール/制約)をチェックし、違反した際にドメイン層 で定義する例外を投げます。この場合、ユースケース層はドメイン層から投げられた例外
*1 DB、ファイル、外部サービスなど
97
第 10章アーキテクチャ全般・ライブラリなど
を受け、呼び出し元にどう返すかの判断を行います。ドメイン層の例外に対してそのまま エラーで処理を終えるのか、代わりに別の処理を行うのかはユースケースの問題です。そ の判断を委ねるために、ドメイン層の例外は検査例外とします。
ユースケース層では、あらかじめ想定する異常系の処理パターンだった時に、ユース ケース層で定義する例外を投げます。ユースケース内の分岐で例外を投げる場合と、前述 の通り、ドメイン層の例外をキャッチしてユースケース層の例外に詰め替えて投げる場合 があります。 例外がユースケース層のものかという判断は若干迷いやすいので、プレゼンテーション 層にもドメイン層にも該当しなければこちら、といった消去法的な判断をしても良いで しょう。
10.1.2 バリデーション内容の重複 ドメイン層とプレゼンテーション層などで、同じ内容のバリデーションをしたくなる場 合があります。この場合、メリットデメリットが一長一短な選択肢があるので、その観点 を整理します。
まず、ドメインのルール/制約は重要で、確実に守りたいものです。ドメイン層にこの バリデーションがない場合、「ある処理ではバリデーションされたが、別の処理ではバリ デーションを忘れた」ということが発生すると、データの整合性が保証できなくなりま す。これを回避するためには、ドメイン層のロジックとして実装し、それ以外の層からは 整合性を破壊できないようにします。このバリデーションは、他の層のものよりも優先す る方が良いでしょう。
一方、同じ内容のバリデーションをプレゼンテーション層で実装したい場合がありま す。考えられるケースは、API の仕様として外部にリクエストの仕様を公開する場合で す。APIの仕様としてドキュメントがある場合、それはプレゼンテーション層の責務とし てプレゼンテーション層で管理したくなります。特に、APIドキュメントからコントロー ラーを自動生成する場合には、自ずとこのバリデーションがプレゼンテーション層に実装 されます。 プレゼンテーション層にバリデーションを実装する場合、プレゼンテーション層でルー ルを明示的に管理できるメリットと、同じ内容のバリデーションがドメイン層と重複し、 仕様変更時に修正が漏れるリスクが発生する、というデメリットがあります。 また、UX向上のために同じ内容のバリデーションをフロントエンドモジュールに書く
98
10.2 パッケージ
こともあります。サーバー通信せず、キー入力のタイミングでバリデーションをかける場 合などです。この場合も同様に、実装の重複による修正漏れリスクがあります。
これらのメリットデメリットは一長一短なため、一概にどちらが良いとは決められませ ん。各プロジェクトにおいて、重視するポイントを考慮して決定することになります。
10.1.3 処理結果を例外で表現しない場合 例外を使用する場合は、例外が投げられればメソッド内の処理が失敗、投げられなけれ ば成功という判断を行います。一方、この表現を Success,Fail といった結果を表すオブ ジェクトを返す方針もあります。 メリットとしては、前述のような例外の使用が一般的でない言語やフレームワークを使 用している時に適用しやすいことです。デメリットとしては、チェックのたびに分岐して returnしなければいけないため、例外を使用する場合に比べて呼び出し元の記述が煩雑に なることです。
10.2 パッケージ 全体のパッケージ構成 パッケージングについては、レイヤーをパッケージのルートの階層で分けるのが良いで しょう。(図 10.1) 設計する上で一番初めに考えるべきなのは、設計対象の処理がどのレ イヤーの責務に属するかということであり、それをパッケージで明確に意識しやすくする ためです。
99
第 10章アーキテクチャ全般・ライブラリなど
▲図 10.1 パッケージ
そのパッケージ以下は、処理のカテゴリや、集約ごとに分けていきましょう。ドメイ ン層は特に、集約ごとにパッケージを分けて関わりのあるオブジェクトを表現すること、 (Javaの場合は)パッケージプライベートの可視性を有効利用することが非常に重要です。 集約をパッケージで表現できたら、複数の集約パッケージを意味的なまとまりでパッケー ジで整理しても良いでしょう。
共有されるオブジェクトのパッケージ 複数の箇所で使用するオブジェクトは、該当するレイヤーのパッケージ以下に「shared」 などの意図が明確な名前のパッケージを作り、そこにまとめます。 配置するレイヤーをきちんと検討した上で決定することは重要です。例えば、日付を扱 う処理に関して、業務的に意味のある日付を処理するオブジェクトであればそれはドメイ ン層に属するものであり、表示時の日付のフォーマットを変換するオブジェクトであれば プレゼンテーション層に属するものとなります。レイヤーを意識せずに共有オブジェクト を作成すると、責務が曖昧で凝集度が低く、保守性が低いものになる可能性が高くなり ます。 一部アプリケーション起動に必要なオブジェクトなど、レイヤーの概念に当てはまらな いものも発生しますが、どこかのレイヤーに該当しないかしっかりと検討した上で、他の レイヤーと並列で配置するなどの判断を行います。
100
10.3 Webフレームワークへの依存
10.3 Webフレームワークへの依存 Webフレームワークには、どの程度まで依存を許容するのでしょうか。 特定のWebフレームワークに依存して移行に苦労した経験から、一切依存を除外した い、という意見があります。しかし、すべてのレイヤーにおいて完全に依存を排除するの は難しく、レイヤーごとにポリシーを決めるのが現実的です。以下、レイヤーごとに確認 していきましょう。
ドメイン層 ドメイン層では、一切依存しない形にするのが望ましいです。 一部、ドメインサービス内でリポジトリなど他のインスタンスを使用する場合、Depen-
dency Injection(以下、DI) が必要になる場合があります。これに関しては、DI なしで 自分でインスタンス管理をする場合に比べて、コストより得るものが大きいので、DIラ イブラリへの依存は許容範囲と考えても良いでしょう。DIはコンストラクタインジェク ション*2であれば必要な記述はコンストラクタとアノテーション程度となり、ロジック詳 細には影響せずに済むことが多いです。
ユースケース層 ユースケース層では、部分的な依存は必要になります。 DIに関しては、ドメイン層以上に必要になりますが、ドメイン層と同じ理由で許容範 囲と考えられます。 トランザクションに関しては、使用するフレームワークによって記述方法が大きく変わ りますが、ここはユースケース層で意識せざるを得ません。AOP*3の利用や共通クラス に処理を寄せるなど、極力個別のユースケースメソッドに意識させないようにするなどの 工夫ができると望ましいです。 ロギングに関してはどうでしょうか。明示的にログを吐く場合、ユースケース層にロ ガーのインターフェイスを定義し、実装クラスをインフラ層に配置するようにすれば、 ユースケース層が特定のロギングライブラリに依存することは避けられます。
*2 <https://ja.wikipedia.org/wiki/依存性の注入> *3 <https://docs.spring.io/spring/docs/2.5.x/reference/aop.html>
101
第 10章アーキテクチャ全般・ライブラリなど
プレゼンテーション層 こちらの層では、「第 9章 プレゼンテーション層の実装」で述べた通り、リクエストを 受け取ってアプリケーションコードに引き渡す処理など、必然的にフレームワーク固有の 実装が大変多くなりますが、これは責務上仕方ないことです。むしろ、フレームワーク固 有の実装を極力このレイヤーに閉じ込めることが重要です。
10.4 ORマッパー ORマッパーとは、どう付き合うのが良いでしょうか。代表的なものが Active Record
型の、テーブルと対応したクラスです。これらのクラスをドメイン層のクラスとしてその まま使ってはいけません。 そのまま使う場合、以下のような大きなデメリットがあります。
• すべての項目にセッターがあるため、更新処理に制御をかけられなくなる
• テーブルとオブジェクトが切り離せなくなるため、オブジェクトとテーブルの設計 に望ましくない制約がかかってしまう (詳細は次節にて説明)
そのため、Active Record型のテーブルに対応したクラスはインフラ層のリポジトリ実 装クラス内に閉じ込め、DBデータを取得した結果をドメイン層のクラスに詰め替える形 にします。こうすることで、ドメイン層、ユースケース層が特定の ORマッパーの知識を 持たせないように隠蔽できます。
オブジェクトとテーブルが分離できないことによる制約 前節で述べた「望ましくない制約」とはどういうことでしょうか、具体例で解説します。 ユーザーと住所が同じ集約で、ユーザーが住所をインスタンス参照するとします。この 関係をドメインモデル図で表すと、図 10.2のようになります。
▲図 10.2 ドメインモデル図 1
102
10.4 ORマッパー
この場合、住所はユーザーの情報を持たない値オブジェクトとして実装し、ユーザーが 住所オブジェクトをメンバー変数として保持します。 これをテーブルに永続化する際は、ER図は図 10.3のような形になります。
▲図 10.3 ER 図
テーブルの場合は住所からユーザーに、IDの参照を持ちます。ここで、オブジェクト とテーブルでは参照の向きが逆向きになっているのです。
さて、ここでテーブルとオブジェクトが分離できない場合どうなるでしょうか。住所オ ブジェクトがユーザーへの参照を持たなければいけない、という制約が発生するのです。 (図 10.4)
▲図 10.4 ドメインモデル図 2
「住所」というものを表現するオブジェクトを作成する時に、ユーザー IDを渡すという のは意味が成り立たず、住所オブジェクトが何を表すものなのかが曖昧になってしまいま した。これが「望ましくない制約がかかる」ということの一例になります。 このような制約と妥協が積み重なっていくと、せっかく作成したドメインモデル図と、 実装がどんどん乖離していきます。それでは 1章で解説した DDDのアプローチが取れな くなり、ソフトウェア価値を高めることの妨げになるのです。 ドメイン層のモデルはどこにも依存せず、制約を受けない形での実装にすることが非常 に重要です。
103
第 10章アーキテクチャ全般・ライブラリなど
10.5 言語 DDDを実装する際の言語について、向き不向きはあるでしょうか。 向いている条件として、静的型付け言語であることです。DDDでは、モデルのルール/ 制約をオブジェクト指向の型で表現します。動的型付け言語の場合、表現した制約を容易 に破れてしまうため、効果を十分に得にくいです。ただし、動的型付け言語の場合でも、 タイプヒントと静的解析の組み合わせで補完することはできます。 この条件を考えると、Java、Scalaは向いている、Python、PHP、JavaScriptでもで きる、Rubyは現時点では不向き、ということが言えるでしょう。
10.6 Q&A
10.6.1 アーキテクチャの部分適用
重要な箇所だけDDDにしようと思っていたところ、他のメンバーに「どこが重要なのかの判断がまちま ちになるので、全部クリーンアーキテクチャにすべき」と言われました。 全部やり出したところやはり手間がものすごくかかり、DBから単純にレコードを返すようなAPIまでク リーンアーキテクチャにする必要はないのではと思うのですが、どう思いますか？
部分適用する場合、適用する基準を明文化することが必要です。基準なく担当者個別で 判断をすると、あとあと収集がつかなくなります。 基準が明確化され、それぞれの場合の実装がうまくう切り分けられそうであれば、部分 適用することは良いでしょう。具体的には、特定の業務に関わるものであるとか、特定の タイミング以降に作るものといった基準が考えられます。 ただし、実装をうまく切り分ける、ということが結構難しいので、そこが解決できなけ れば全適用、という判断もありです。
104
第 11章
困った時には
本書では、DDD の目的から、モデリング、実装の各トピックまでを解説しました。 「DDDって、良さそうだけどよくわらかない」というところから、「良さはわかった、やっ てみよう」という一歩を踏み出すきっかけになればと思っています。 ただ、実際に手を動かしてみると困ることが発生するでしょう。最後に、そういった場 合に参考になる対処方法をいくつか紹介します。 なお、紹介する内容はいずれも 2020年 2月時点のものです。紹介している内容が変更、 終了などになる可能性はありますのでご了承ください。
11.1 ドメイン駆動設計入門 「ドメイン駆動設計入門 ボトムアップでわかる！ ドメイン駆動設計の基本*1」は、成 瀬允宣 (@nrslib) さん執筆で 2020/2/13 に発売された書籍です。値オブジェクト、エン ティティから入り、DDDの戦術的設計パターンを 1章で 1つずつ、コードを用いて詳細 に解説されています。「ボトムアップ」とある通り、コードから理解を進めるにはぴった りの書籍です。本書は DDDの目的から入るトップダウンな構成になっているため、「ド メイン駆動設計入門」はちょうど補完的な内容になっています。
11.2 実践ドメイン駆動設計 「実践ドメイン駆動設計*2」は、重厚で最初から読み進めるには大変ですが、手を動かし てから突き当たる課題に対する解決策が紹介されています。本書で全体像や概念をざっと 理解できれば、細かいトピックをご自分で読み解く際に進めやすくなります。
*1 <https://www.amazon.co.jp/dp/B082WXZVPC/>*2 <https://www.amazon.co.jp/dp/479813161X/>
105
第 11章困った時には
11.3 英語で検索 インターネット上にある DDDの知識は、日本語より英語の方が圧倒的に豊富です。そ のために、Googleの検索対象の言語を英語にして検索してみると、欲しかった答えを見 つけられることがあります。 言語を英語に指定するには、以下の URLからアクセスします。hlは言語を、glは国/
地域を指定するパラメーターです。 <https://www.google.co.jp/search?hl=en&gl=us> 「英語…ウッ」となってしまう方もいるかもしれませんが、ブラウザの Google翻訳アド オンを使うと、ページ単位の和訳も可能です。最近は Google翻訳の精度が非常に良いの で、これだけでもある程度読み進めることが可能です。苦手意識があっても、ぜひ一度試 してみてください。
11.4 DDD Community Jp
筆者が運営している、DDD Community Jp というオンラインコミュニティがありま す。Discord というオンラインチャットツールを利用しており、チャットで質問を行う チャンネルや、ボイスチャットで開催されるオンライン勉強会などがあります。 また、オフラインでも不定期でミートアップなどのイベントも開催しています。質問だ けではなく、DDDに興味がある人たち同士で色々話す機会は刺激になります。ぜひ、お 気軽にコミュニティに登録してみてください。 紹介記事: <https://little-hands.hatenablog.com/entry/dddcj> connpassのコミュニティページ: <https://ddd-community-jp.connpass.com/>
11.5 筆者に質問 また、筆者個人で Twitterや質問箱というサービスで質問を受け付けています。質問箱 では匿名で質問することが可能です。お気軽にご質問ください。
Twitter: <https://twitter.com/little_hand_s> 質問箱: <https://peing.net/ja/little_hands> この本がお手にとっていただいた方のお役に立てれば幸いです。お読みいただき、どう もありがとうございました！
106
著者紹介
文章: 松岡幸一郎 (@little_hand_s) アーキテクチャや開発プロセスなど、 エンジニアが幸せに開発するための仕組みや手法が好きです。 ブログ: <https://little-hands.hatenablog.com/>
表紙: 岡本ちひろ (@haco_kiwi) 絵を描いています。とりが好きです。
107
ドメイン駆動設計モデリング/実装ガイド
2020年 3月 1日　技術書典 8版 v1.0.3
著　者 松岡 幸一郎 発行所 little_hand_s 印刷所 有限会社 ねこのしっぽ

(C) 2020 @little_hand_s
108
